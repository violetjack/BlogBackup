{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape-plus/source/css/bdshare.styl","path":"css/bdshare.styl","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/img/scrollup.png","path":"img/scrollup.png","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/landscape-plus/.gitattributes","hash":"082442a106c29adb09669f321f984c1bf606f780","modified":1517902347408},{"_id":"themes/landscape-plus/.gitignore","hash":"b64fca798c2e9164bd1c9d8d641c4b2b22334da5","modified":1518058394091},{"_id":"themes/landscape-plus/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1517902347408},{"_id":"themes/landscape-plus/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1517902347408},{"_id":"themes/landscape-plus/README.md","hash":"3b370d9fc7e2c86d3e3e79d1b0eeeb2af461815f","modified":1517902347409},{"_id":"themes/landscape-plus/_config.yml","hash":"a4c192ff2224cf1cd20521bc53fb8b6aab5f2754","modified":1518058604605},{"_id":"themes/landscape-plus/package.json","hash":"5deaa023c44f9f59f3df6e2a033a5fc2586797e6","modified":1517902347416},{"_id":"source/_posts/ES6 学习笔记（上）.md","hash":"a001b69ccaf62bac6b8aef6e6060224dce5a521c","modified":1517970437705},{"_id":"source/_posts/ES6 学习笔记（下）.md","hash":"1f839286548d5cba9fb5bb0115323674905fb909","modified":1517970431112},{"_id":"source/_posts/Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）.md","hash":"8d9999ea412e06669a238c73ef534b6261683a01","modified":1517970681829},{"_id":"source/_posts/Vue.js学习系列七 —— Vue服务器渲染Nuxt学习.md","hash":"f47824adb161074b2508cfe000cb6ae9f3d88b4b","modified":1517970411136},{"_id":"source/_posts/Vue.js学习系列三 —— axios和网络传输相关知识的学习实践.md","hash":"7a9d0fac9412ec298c241a974a4237ef09d7bed4","modified":1517970634883},{"_id":"source/_posts/Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）.md","hash":"060cb43c1b38285dff7316f87afe3801bc3fc8e5","modified":1517970672170},{"_id":"source/_posts/Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint.md","hash":"7278e24586e53bf5518c9cb936771f73819b2129","modified":1517970582893},{"_id":"source/_posts/Vue.js学习系列八 —— Vue源码学习之State学习.md","hash":"aab45ce5b98541c80691ed79de8e15d894e3ab31","modified":1517972117244},{"_id":"source/_posts/Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记.md","hash":"d68db3f89076bc80297448f1af5fcdc4d15b5064","modified":1517970571765},{"_id":"source/_posts/Vue.js学习系列四 —— Webpack学习实践.md","hash":"bb1233c21019d0a63bd0a34f605ffbbd7dcd8905","modified":1517970605597},{"_id":"source/_posts/Vue学习系列倡议书.md","hash":"6ec1ac4f4c2b8f58f548ac4369d748dd4d9cb9f4","modified":1517970386752},{"_id":"source/_posts/Vue源码学习笔记.md","hash":"675ea4d21b274dcfbbcd1e8f232f929521de7333","modified":1517970486353},{"_id":"source/_posts/Weex控制Android返回键解决方案.md","hash":"a779dbed81b43a4a391e0d384a5a2cf30d55de83","modified":1517970809117},{"_id":"source/_posts/weex 踩坑记（持续更新中……）.md","hash":"b52b8b691748cd7ec3b5b8afb3ebe1a8c96ff089","modified":1517970803535},{"_id":"source/_posts/weex项目弃坑小结.md","hash":"5a2a46833b5a56b20b01601cff176f98424888a9","modified":1517970506177},{"_id":"source/_posts/将表单从jQuery转Vue框架实践总结.md","hash":"9ddaf890bae410ba410395c87dafb6ccd98e9d04","modified":1517970700155},{"_id":"source/_posts/巧用jQuery选择器写表单办法总结（提高效率）.md","hash":"581b94883aa956cf461a8d2d48921098e54a9b09","modified":1517970651901},{"_id":"source/_posts/用hexo搭建博客笔记.md","hash":"4168f2a12939c5c9380517aea38b45e953ab89f2","modified":1518054118146},{"_id":"source/about/index.md","hash":"a410e3e5b1b29f296ea7694af1972881966cf30c","modified":1517970740041},{"_id":"source/info/index.md","hash":"1401ea1ba850f4f48099d4fce77587d497066040","modified":1518044782210},{"_id":"themes/landscape-plus/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1517902347401},{"_id":"themes/landscape-plus/.git/config","hash":"6be24f9f89fe0669da53b67e023130d908148e59","modified":1517902347403},{"_id":"themes/landscape-plus/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1517902340329},{"_id":"themes/landscape-plus/.git/index","hash":"c90730e3639699b810d07d7e00f756a5f9da67b8","modified":1517902351807},{"_id":"themes/landscape-plus/.git/packed-refs","hash":"37915f5293cf10ee9f30f3bbcb6ce91a47acb19b","modified":1517902347399},{"_id":"themes/landscape-plus/languages/default.yml","hash":"0270b76db4c94f8905d4c0dc2303da5d5e756a19","modified":1517902347409},{"_id":"themes/landscape-plus/languages/zh-CN.yml","hash":"e043d662bc48ea28b6072de76e032ed049457acc","modified":1517903141839},{"_id":"themes/landscape-plus/languages/zh-TW.yml","hash":"1187826de31c687542e882835fc8062c2bc7a551","modified":1517902347409},{"_id":"themes/landscape-plus/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1517902347414},{"_id":"themes/landscape-plus/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1517902347414},{"_id":"themes/landscape-plus/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1517902347415},{"_id":"themes/landscape-plus/layout/layout.ejs","hash":"3626a74826657529bea744fb014dd9607e9834d0","modified":1517902347415},{"_id":"themes/landscape-plus/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1517902347415},{"_id":"themes/landscape-plus/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1517902347415},{"_id":"themes/landscape-plus/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1517902347415},{"_id":"themes/landscape-plus/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1517902347416},{"_id":"themes/landscape-plus/source/css/bdshare.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1517902347421},{"_id":"themes/landscape-plus/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1517902340330},{"_id":"themes/landscape-plus/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1517902340330},{"_id":"themes/landscape-plus/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1517902340331},{"_id":"themes/landscape-plus/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1517902340331},{"_id":"themes/landscape-plus/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1517902340330},{"_id":"themes/landscape-plus/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1517902340331},{"_id":"themes/landscape-plus/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1517902340330},{"_id":"themes/landscape-plus/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1517902340331},{"_id":"themes/landscape-plus/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1517902340331},{"_id":"themes/landscape-plus/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1517902340332},{"_id":"themes/landscape-plus/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1517902340329},{"_id":"themes/landscape-plus/.git/logs/HEAD","hash":"03a2ea9f7891c77051aa10a34911347fc705c110","modified":1517902347402},{"_id":"themes/landscape-plus/layout/_partial/after-footer.ejs","hash":"999505b46330ff068bbae49aea4700e0bca57e88","modified":1517902347410},{"_id":"themes/landscape-plus/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1517902347410},{"_id":"themes/landscape-plus/layout/_partial/archive.ejs","hash":"ff1e925ab5f512a89a7adb2c337f4bd021982154","modified":1517902347410},{"_id":"themes/landscape-plus/layout/_partial/article.ejs","hash":"2116236daed16cb9f97855ee93b4bc580249d7d2","modified":1517902347410},{"_id":"themes/landscape-plus/layout/_partial/footer.ejs","hash":"46d36b67fdb672c3d308c0ba3574811cbba5bbc6","modified":1517902347410},{"_id":"themes/landscape-plus/layout/_partial/google-analytics.ejs","hash":"78823298e9e47d8e6556fc2bb4598fc2814f2d52","modified":1517902347411},{"_id":"themes/landscape-plus/layout/_partial/head.ejs","hash":"b37dfc4cae60ff4900aa53b3cf2e07bba12441de","modified":1517902347411},{"_id":"themes/landscape-plus/layout/_partial/header.ejs","hash":"e9bd1af5969f641611251076b13d07002065b2aa","modified":1517902347411},{"_id":"themes/landscape-plus/layout/_partial/mathjax.ejs","hash":"204ed307e7b7cedb6d598b9ee14769b8d41180ca","modified":1517902347411},{"_id":"themes/landscape-plus/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1517902347411},{"_id":"themes/landscape-plus/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1517902347412},{"_id":"themes/landscape-plus/layout/_partial/totop.ejs","hash":"aa3a3eadf31d9b3e4d3081cd3ca61860e55ef553","modified":1517902347413},{"_id":"themes/landscape-plus/layout/_widget/archive.ejs","hash":"bbb86beab343e08e689a372ddb60bfa782e93bc4","modified":1517902347413},{"_id":"themes/landscape-plus/layout/_widget/category.ejs","hash":"ae96217d072f637925c907f5f467450083863f50","modified":1517902347413},{"_id":"themes/landscape-plus/layout/_widget/links.ejs","hash":"ff4eb9afa0b9e5b31c55c6775880452222c57f53","modified":1517902347413},{"_id":"themes/landscape-plus/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1517902347414},{"_id":"themes/landscape-plus/layout/_widget/tag.ejs","hash":"b461390feb5ef82df7aef9677a31d5137c352f61","modified":1517902347414},{"_id":"themes/landscape-plus/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1517902347414},{"_id":"themes/landscape-plus/source/css/_extend.styl","hash":"3f8a9e4e63b7249408ac54559a5f9633d703e132","modified":1517902347417},{"_id":"themes/landscape-plus/source/css/_variables.styl","hash":"5e4e6940979c312b58d2edb88383dd7935c577f7","modified":1517902347421},{"_id":"themes/landscape-plus/source/css/style.styl","hash":"30fdb982f5324d0023f38c28e83238b9518f2756","modified":1517902347428},{"_id":"themes/landscape-plus/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1517902347428},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1517902347429},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1517902347429},{"_id":"themes/landscape-plus/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1517902347429},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1517902347429},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1517902347430},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1517902347431},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1517902347432},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1517902347432},{"_id":"themes/landscape-plus/source/img/favicon.png","hash":"7192dfc87e31d5ff5490f0be38a0a3c85584f6ac","modified":1517902807036},{"_id":"themes/landscape-plus/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1517902347433},{"_id":"themes/landscape-plus/source/js/script.js","hash":"89f3a9ba53e1481a0609cbb62e9530ca339b052d","modified":1517902347433},{"_id":"themes/landscape-plus/.git/objects/pack/pack-cfa8a84922e878689c194cbde35fba05ca4cd157.idx","hash":"f879aaabed5646530834feef78d9aa3b56c061b6","modified":1517902347390},{"_id":"themes/landscape-plus/.git/refs/heads/master","hash":"1577bf49971ab7aa396a37216dd4e701e4e2e78d","modified":1517902347402},{"_id":"themes/landscape-plus/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1517902347411},{"_id":"themes/landscape-plus/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1517902347412},{"_id":"themes/landscape-plus/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1517902347412},{"_id":"themes/landscape-plus/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1517902347412},{"_id":"themes/landscape-plus/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1517902347412},{"_id":"themes/landscape-plus/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1517902347412},{"_id":"themes/landscape-plus/source/css/_partial/archive.styl","hash":"19b5af4e0969d93fb757577bd6ff380ef2224eb9","modified":1517902347417},{"_id":"themes/landscape-plus/source/css/_partial/article.styl","hash":"1bd06c119e4b64b85dbc37ba22f5210edf10e0b4","modified":1517902347418},{"_id":"themes/landscape-plus/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1517902347418},{"_id":"themes/landscape-plus/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1517902347418},{"_id":"themes/landscape-plus/source/css/_partial/header.styl","hash":"888a579a733d852201c9dc5d56e4fee98dd5795d","modified":1517903844730},{"_id":"themes/landscape-plus/source/css/_partial/highlight.styl","hash":"a3c2f696d9477223bd45b49e5f996d7998ae52e5","modified":1517902347419},{"_id":"themes/landscape-plus/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1517902347419},{"_id":"themes/landscape-plus/source/css/_partial/sidebar-aside.styl","hash":"c9ea5b3956b73418dc8b1572e32eb65dc68ca0e5","modified":1517902347419},{"_id":"themes/landscape-plus/source/css/_partial/sidebar-bottom.styl","hash":"bc5487b9a0bfe5f745423331824d3f3637ccd430","modified":1517902347420},{"_id":"themes/landscape-plus/source/css/_partial/sidebar.styl","hash":"b7bdc11effa98c6d88850eff75634e2ea9207c14","modified":1517902347420},{"_id":"themes/landscape-plus/source/css/_partial/totop.styl","hash":"817f36dd591d6beef9d41011ae8490d31d5e2e50","modified":1517902347420},{"_id":"themes/landscape-plus/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1517902347420},{"_id":"themes/landscape-plus/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1517902347421},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1517902347423},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1517902347426},{"_id":"themes/landscape-plus/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1517902347430},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1517902347430},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1517902347430},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1517902347431},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1517902347431},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1517902347431},{"_id":"themes/landscape-plus/source/css/fonts/FontAwesome.otf","hash":"6270a4a561a69fef5f5cc18cdf9efc256ec2ccbe","modified":1517902347422},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1517902347426},{"_id":"themes/landscape-plus/.git/logs/refs/heads/master","hash":"03a2ea9f7891c77051aa10a34911347fc705c110","modified":1517902347402},{"_id":"themes/landscape-plus/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1517902347401},{"_id":"themes/landscape-plus/source/css/images/banner.jpg","hash":"843d9d47bf2b7b75495db11b3d765efaaae442a9","modified":1517902347428},{"_id":"themes/landscape-plus/.git/logs/refs/remotes/origin/HEAD","hash":"03a2ea9f7891c77051aa10a34911347fc705c110","modified":1517902347401},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.svg","hash":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1517902347424},{"_id":"themes/landscape-plus/.git/objects/pack/pack-cfa8a84922e878689c194cbde35fba05ca4cd157.pack","hash":"9da99b110659ec31ad040df2d9cfd6b44eda02e1","modified":1517902347389},{"_id":"public/atom.xml","hash":"69135829b97da8bf60c10097801cd1efcd248122","modified":1518058651546},{"_id":"public/about/index.html","hash":"fc23f344c088001ae57be9dbb9720440f5c722e8","modified":1518058651864},{"_id":"public/info/index.html","hash":"01c713c462854e54749c09be6dd5aaba75ed12ff","modified":1518058651864},{"_id":"public/archives/index.html","hash":"be8a682150366b57805ad8712fdff87c9ba4f781","modified":1518058651864},{"_id":"public/archives/page/2/index.html","hash":"c34ea41fe4cb083f22057a9675aed3c5ffd6daa4","modified":1518058651864},{"_id":"public/archives/2016/index.html","hash":"803fe9b9ca340fee9e3474c5a6118927da9c077f","modified":1518058651864},{"_id":"public/archives/2016/05/index.html","hash":"98c47e0622e77b61c5844548278632797d521dd4","modified":1518058651864},{"_id":"public/archives/2016/06/index.html","hash":"cf244862bb4e155f631d2fb0bea844ed56c953d0","modified":1518058651865},{"_id":"public/archives/2016/08/index.html","hash":"947aff5568907c150ccbfaab7031e85c79508d45","modified":1518058651865},{"_id":"public/archives/2016/12/index.html","hash":"b7adc3875cad0145f2406e9a2e45db9b07bf4ea8","modified":1518058651865},{"_id":"public/archives/2017/index.html","hash":"5714b07eb7032971927e02399ef8188ae2f30e47","modified":1518058651865},{"_id":"public/archives/2017/01/index.html","hash":"2fb8787744afe37b31bf995a007e70303db4ab80","modified":1518058651865},{"_id":"public/archives/2017/02/index.html","hash":"bfd337ffd3f053e727f5024adc155100c163261f","modified":1518058651865},{"_id":"public/archives/2017/05/index.html","hash":"de34b91a77423d86bb99d351f855ad4a0d25a4b7","modified":1518058651865},{"_id":"public/archives/2017/06/index.html","hash":"78f53887894f780c6830f0a21140932f4b626c33","modified":1518058651865},{"_id":"public/archives/2017/12/index.html","hash":"66051baa0a1012adece8fbc57a976d9231216d9c","modified":1518058651865},{"_id":"public/archives/2018/index.html","hash":"aba6225a0bce18777056d96c3a72f751a0993e09","modified":1518058651865},{"_id":"public/archives/2018/01/index.html","hash":"ef72022efdbe87469323d0057ad21525e0d37354","modified":1518058651865},{"_id":"public/archives/2018/02/index.html","hash":"2a61416f2661ee16113643e046c46e5f237b97f7","modified":1518058651865},{"_id":"public/2018/02/08/用hexo搭建博客笔记/index.html","hash":"239a77be234412bb1b75e8a5cf7cbb328b7f5da3","modified":1518058651866},{"_id":"public/2018/02/03/Vue.js学习系列八 —— Vue源码学习之State学习/index.html","hash":"90c93de0bb56f8ab1b7414817c0bfe37d7023b5e","modified":1518058651866},{"_id":"public/2018/01/29/Vue学习系列倡议书/index.html","hash":"c3c69dd8a0a08b3c0dd0d57220846d01051c61e3","modified":1518058651866},{"_id":"public/2018/01/26/Vue.js学习系列七 —— Vue服务器渲染Nuxt学习/index.html","hash":"d24a5406abc15b7720b1f30dba094578de798ebb","modified":1518058651866},{"_id":"public/2018/01/21/ES6 学习笔记（下）/index.html","hash":"a5dad8254e3b587970586f98c8d0cf64dd467429","modified":1518058651867},{"_id":"public/2018/01/18/ES6 学习笔记（上）/index.html","hash":"403e7435e6898b086d8561b3182846ed570f375d","modified":1518058651867},{"_id":"public/2017/12/01/weex项目弃坑小结/index.html","hash":"1f580ea555b271864eb9f245523551f1b239e779","modified":1518058651867},{"_id":"public/2017/12/01/Vue源码学习笔记/index.html","hash":"e45d510ac96eba7d67c33d1e648d00bf56477f1d","modified":1518058651867},{"_id":"public/2017/06/06/Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记/index.html","hash":"48f52796df0e1275bfcc2ee6f585470b962b7118","modified":1518058651867},{"_id":"public/2017/05/19/Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint/index.html","hash":"050ab4329070e45c806cd4f6d3c46394b2f65044","modified":1518058651867},{"_id":"public/2017/02/07/Vue.js学习系列四 —— Webpack学习实践/index.html","hash":"fe8f7427fa4a9a69dab85d74befd05590d78e545","modified":1518058651867},{"_id":"public/2017/01/09/Vue.js学习系列三 —— axios和网络传输相关知识的学习实践/index.html","hash":"3833b7df8db87d6ea9cc9180ba3f2e951472e091","modified":1518058651867},{"_id":"public/2016/12/31/Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）/index.html","hash":"858ccf01b9d5b3a1bc649229eb014eec0eabf42f","modified":1518058651867},{"_id":"public/2016/12/31/巧用jQuery选择器写表单办法总结（提高效率）/index.html","hash":"5662d0849c7a6d1c83d91a8fb547416f2e023daa","modified":1518058651868},{"_id":"public/2016/12/26/Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）/index.html","hash":"8b0b84093123ce2d22c1a07436c2d893daeed5f8","modified":1518058651868},{"_id":"public/2016/08/03/weex 踩坑记（持续更新中……）/index.html","hash":"fe4d5ef0542119d3b79e3c127c93d54b9c89e7ae","modified":1518058651868},{"_id":"public/2016/06/30/Weex控制Android返回键解决方案/index.html","hash":"b8aa441e70a9ff030784e4da5ee7fe79392bbfaa","modified":1518058651868},{"_id":"public/2016/05/19/将表单从jQuery转Vue框架实践总结/index.html","hash":"d2006cead3334c7173f21054ac72be28752563ec","modified":1518058651868},{"_id":"public/index.html","hash":"60ac7826944a8bdcd30d3b782abb1c6c2a4a3f1f","modified":1518058651868},{"_id":"public/page/2/index.html","hash":"f53af156c1e3ccc04b8c9b879600d5c07ced7268","modified":1518058651868},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1518058651872},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1518058651872},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1518058651872},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1518058651873},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1518058651873},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1518058651873},{"_id":"public/img/favicon.png","hash":"7192dfc87e31d5ff5490f0be38a0a3c85584f6ac","modified":1518058651873},{"_id":"public/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1518058651873},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1518058651873},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1518058651873},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1518058651873},{"_id":"public/css/fonts/FontAwesome.otf","hash":"6270a4a561a69fef5f5cc18cdf9efc256ec2ccbe","modified":1518058652298},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1518058652300},{"_id":"public/css/bdshare.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1518058652303},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1518058652303},{"_id":"public/js/script.js","hash":"89f3a9ba53e1481a0609cbb62e9530ca339b052d","modified":1518058652303},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1518058652304},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1518058652304},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1518058652304},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1518058652304},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1518058652304},{"_id":"public/css/style.css","hash":"c8df1c43438027b99009c1f70f50abc020da8f5f","modified":1518058652304},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1518058652304},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1518058652304},{"_id":"public/css/images/banner.jpg","hash":"843d9d47bf2b7b75495db11b3d765efaaae442a9","modified":1518058652308},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1518058652310}],"Category":[],"Data":[],"Page":[{"title":"关于我","date":"2018-02-06T08:20:52.000Z","_content":"\nVioletJack， 丁晓杰，Android、前端开发工程师。现专注于Vue相关技术的学习和分享。\n\n## 兴趣爱好\n\n看书、篮球、吉他、编程。\n\n## 梦想\n\n我的梦想有三个阶段：\n\n* 努力提高自我价值、挣足够的钱，然后通过投资实现财务自由，不做金钱的奴隶。\n* 积极创业，为社会提供工作机会、实现公司愿景，为社会带来价值。\n* 实现财富自由，在不工作的情况下有足够的现金流。然后专注于玩技术，维护开源项目，用代码改变世界。\n\n## 联系方式\n\n邮箱： [475966597@qq.com](475966597@qq.com)\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2018-02-06 16:20:52\n---\n\nVioletJack， 丁晓杰，Android、前端开发工程师。现专注于Vue相关技术的学习和分享。\n\n## 兴趣爱好\n\n看书、篮球、吉他、编程。\n\n## 梦想\n\n我的梦想有三个阶段：\n\n* 努力提高自我价值、挣足够的钱，然后通过投资实现财务自由，不做金钱的奴隶。\n* 积极创业，为社会提供工作机会、实现公司愿景，为社会带来价值。\n* 实现财富自由，在不工作的情况下有足够的现金流。然后专注于玩技术，维护开源项目，用代码改变世界。\n\n## 联系方式\n\n邮箱： [475966597@qq.com](475966597@qq.com)\n","updated":"2018-02-07T02:32:20.041Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjddwxbm00001i8bt0mzh0coc","content":"<p>VioletJack， 丁晓杰，Android、前端开发工程师。现专注于Vue相关技术的学习和分享。</p>\n<h2 id=\"兴趣爱好\"><a href=\"#兴趣爱好\" class=\"headerlink\" title=\"兴趣爱好\"></a>兴趣爱好</h2><p>看书、篮球、吉他、编程。</p>\n<h2 id=\"梦想\"><a href=\"#梦想\" class=\"headerlink\" title=\"梦想\"></a>梦想</h2><p>我的梦想有三个阶段：</p>\n<ul>\n<li>努力提高自我价值、挣足够的钱，然后通过投资实现财务自由，不做金钱的奴隶。</li>\n<li>积极创业，为社会提供工作机会、实现公司愿景，为社会带来价值。</li>\n<li>实现财富自由，在不工作的情况下有足够的现金流。然后专注于玩技术，维护开源项目，用代码改变世界。</li>\n</ul>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><p>邮箱： <a href=\"475966597@qq.com\">475966597@qq.com</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>VioletJack， 丁晓杰，Android、前端开发工程师。现专注于Vue相关技术的学习和分享。</p>\n<h2 id=\"兴趣爱好\"><a href=\"#兴趣爱好\" class=\"headerlink\" title=\"兴趣爱好\"></a>兴趣爱好</h2><p>看书、篮球、吉他、编程。</p>\n<h2 id=\"梦想\"><a href=\"#梦想\" class=\"headerlink\" title=\"梦想\"></a>梦想</h2><p>我的梦想有三个阶段：</p>\n<ul>\n<li>努力提高自我价值、挣足够的钱，然后通过投资实现财务自由，不做金钱的奴隶。</li>\n<li>积极创业，为社会提供工作机会、实现公司愿景，为社会带来价值。</li>\n<li>实现财富自由，在不工作的情况下有足够的现金流。然后专注于玩技术，维护开源项目，用代码改变世界。</li>\n</ul>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><p>邮箱： <a href=\"475966597@qq.com\">475966597@qq.com</a></p>\n"},{"title":"info","date":"2018-02-07T23:06:22.000Z","_content":"","source":"info/index.md","raw":"---\ntitle: info\ndate: 2018-02-08 07:06:22\n---\n","updated":"2018-02-07T23:06:22.210Z","path":"info/index.html","comments":1,"layout":"page","_id":"cjddwxbn2000ji8bt4bdqab5v","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ES6 学习笔记（上）","date":"2018-01-17T16:00:00.000Z","_content":"\n > 认真学习了一遍ES6，发现很多很好用的功能。\n学习资料：[《ECMAScript 6 入门》](http://es6.ruanyifeng.com/#README)\n\n之前写JS，虽然也遇到一些ES6语法，基本就是理解就行，没有深入学习过。这次认真看了一遍ES6，发现里面有许多实用的东西。下面是对本书学习的一些笔记\n\n# let 和 const 命令\n解决var变量提升、变量全局的问题。\n\n**let 和 const 都只作用域本块级作用域内。**\n```\nlet a = 123\n{\n    let a = 456\n    console.log(a)\n}\nconsole.log(a)\n\n// 456\n// 123\n```\n\n**let 和 const 定义的变量不能同名。**\n**let 和 const 定义的变量不可以变量提升。**\n```\na = 5\nlet a\n\n// Error: a is not defined\n```\n**const定义的量内存不可变**\n```\nconst a = 6\nconst obj = {\n    name: 'violetjack'\n}\n\n// 以下写法会报错，因为他们指向了另一个内存地址\n// a = 6\n// obj = {}\n\nobj.name = 'jerry'\nobj.age = 56\nconsole.log(obj)\n\n// { name: 'jerry', age: 56 }\n```\n\n# 变量的结构与赋值\n快速赋值，优化代码可读性。\n\n**用法都差不多，一一对应即可**\n```\nlet [a, b, c] = [1, 2, 3] // 数组结构\nlet { name:mName, age: mAge} = { name:'violetjack', age: 28 } // 对象结构\nlet [e,f,g] = 'mmp' // 字符串结构\nconsole.log(a)\nconsole.log(mName)\nconsole.log(e + f + g)\n\n// 1\n// violetjack\n// mmp\n```\n\n# 字符串扩展\n提出了一些处理字符串的方式\n\n**提供了一些处理大于 `0xFFFF` 的字符串的方法**\n**字符串检索**\n```\nlet s = 'Hello world!';\n\ns.startsWith('Hello') // true\ns.endsWith('!') // true\ns.includes('o') // true\n\n// includes()：返回布尔值，表示是否找到了参数字符串。\n// startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。\n// endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。\n```\n**可以操作复制、填充字符串：`repeat`,`padStart`,`padEnd`**\n**模板字符串，解决字符串拼接问题。**\n```\nconst name = 'VioletJack'\nconst str = 'welcome to ' + name + \"'s blog\"\nconst str2 = `welcome to ${name}'s blog`\nconsole.log(str)\nconsole.log(str2)\n\n// welcome to VioletJack's blog\n// welcome to VioletJack's blog\n```\n相比于第一种方式，第二种方式可读性好很多。也避免了在使用 `'` `\"` 两个符号的时候需要转译的步骤。同时在引用数据上使用 `${value}` 的方式引用。非常方便！\n\n# 正则的扩展\n对于正则我一向晕晕乎乎，没啥收获。关于正则我要另外写篇博客涨涨姿势。\n\n# 数值的扩展\n主要提供了一些数字高级算法。\n**parseInt和parseFloat都在Number中调用，减少js中的全局方法。**\n```\n// ES5的写法\nparseInt('12.34') // 12\nparseFloat('123.45#') // 123.45\n\n// ES6的写法\nNumber.parseInt('12.34') // 12\nNumber.parseFloat('123.45#') // 123.45\n```\n**求指数，通过 `**` 实现**\n```\n2 ** 2 // 2*2 = 4\n2 ** 3 // 2*2*2 = 8\n```\n其他数学算法就不一一列举了，基本用不着，用到了百度即可。\n\n# 函数的扩展\n在函数参数传递方面实现了更多传递方式，实现了箭头函数。总体上是让函数应用上ES6的结构、`rest` 参数。此外还有几个提案，可以去书上看看。\n\n**更多的参数传递方式**\n```\n// 函数参数默认值\nfunction func01(a, b = 11) {\n    console.log(a + b)\n}\n\nfunc01(15)\nfunc01(10, undefined)\nfunc01(1, 1)\n\n// 参数解构\nfunction func02({a = 6, b}) {\n    console.log(a + b)\n}\n\nfunc02({a: 11, b: 12})\nfunc02({b: 6})\n\n// rest参数\nfunction func03(...vals) {\n    let count = 0\n    for (let value of vals) {\n        count += value\n    }\n    console.log(count)\n}\n\nfunc03(1, 2, 3, 4, 5)\nfunc03(11, 22, 33, 44, 55)\n```\n**提出箭头函数，简化代码。**\n```\nvar f = v => v;\n// 等同于\nvar f = function(v) {\n  return v;\n};\n\nvar f = () => 5;\n// 等同于\nvar f = function () { return 5 };\n\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {\n  return num1 + num2;\n};\n```\n注意如果参数或者返回结果是对象，需要用`()`包裹。\n```\nvar fun = ({ a, b }) => a + b\nvar fun02 = a => ({ value: a })\n```\n另外一个特别要注意的就是 `this`，我看到过好几篇博客来解释箭头函数的 `this` 的，可见这个 `this` 的特殊性。可以[在掘金搜索箭头函数](https://juejin.im/search?query=%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0)，里面全是解释（tu cao）箭头函数的~\n下面搬运书上对箭头函数的注意点。\n\n> 箭头函数有几个使用注意点。\n（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。\n上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。\n\n# 数组的扩展\n**扩展运算符，和函数中的rest参数是一回事。我的理解就是把数组拆分成一个个值。**\n```\nlet arr = [1, 2, 3, 4]\nconsole.log(...arr)\nconsole.log([0, 8, 6, ...arr, 10])\nlet str = 'jack'\nconsole.log(...str)\n\n// 1 2 3 4\n// [ 0, 8, 6, 1, 2, 3, 4, 10 ]\n// j a c k\n```\n**Array.from 将类数组对象转为真正的数组。**\n**Array.of 将多个值转为数组**\n```\nArray.of(3, 11, 8) \n// [3,11,8]\n```\n**copyWithin 将数组中某些内容来替换指定内容**\n**find 和 findIndex 用于找到数组中第一个符合条件的值和索引位置。**\n```\nvar a = [1, 4, -5, 10].find((n) => n < 2)\nconsole.log(a)\nvar b = [1, 5, 10, 15].findIndex(function (value, index, arr) {\n    return value > 11;\n}) \nconsole.log(b)\n\n// 1\n// 3\n```\n**fill 用于填充数组**\n**entries、keys和values用来遍历数组非常方便，通过不同方法返回所需数组内容。**\n```\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n```\n**includes 方法与字符串的 includes 类似，用于查找数组中是否有某个值，返回布尔类型的值。**\n**ES6中将数组空位转为undefined**\n```\nconsole.log([...['a',,'b']])\n// [ \"a\", undefined, \"b\" ]\n```\n\n# 对象的扩展\n**对象属性的简洁表示法，也就是我们常看到的ES6的写法。对象中不再必须要传递 `key-value` 的形式了。**\n```\nlet a = 12\nlet b = 22\nlet obj = { a, b }\nconsole.log(obj)\n\n// { a: 12. b: 22 }\n\nlet obj02 = {\n    log() {\n        console.log('Hello!')\n    }\n}\n```\n**对于对象属性名，支持使用 `[字符串]` 的形式来作为对象属性名。**\n```\nlet obj = {\n    name: 'jack',\n    ['age']: 28,\n    ['se' + 'x']: 'male'\n}\nconsole.log(obj)\n\n// {name: \"jack\", age: 28, sex: \"male\"}\n```\n**Object.is方法用于比较两个值是否严格相等。**\n**Object.assign 用于对象的合并，如果有同名属性，后添加的覆盖之前的属性。**\n```\nlet obj1 = {\n    name: 'jack'\n}\n\nlet obj2 = {\n    ['age']: 28,\n    ['se' + 'x']: 'male'\n}\n\nlet obj3 = {\n    job: 'js'\n}\n\nlet obj4 = {\n    name: 'rose',\n    hobby: 'game'\n}\n\nObject.assign(obj1, obj2, obj3, obj4)\nconsole.log(obj1)\n\n// {name: \"rose\", age: 28, sex: \"male\", job: \"js\", hobby: \"game\"}\n```\n**对象的__proto__属性是一个内部属性，所以前后有下划线。不建议修改该属性。**\n**ES6的super关键字用于继承，可以理解为java的super关键字。**\n**Object.keys()，Object.values()，Object.entries()和Array的类似，是对对象的一个遍历过程。**\n```\nlet {keys, values, entries} = Object;\nlet obj = { a: 1, b: 2, c: 3 };\n\nfor (let key of keys(obj)) {\n  console.log(key); // 'a', 'b', 'c'\n}\n\nfor (let value of values(obj)) {\n  console.log(value); // 1, 2, 3\n}\n\nfor (let [key, value] of entries(obj)) {\n  console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]\n}\n```\n**在对象中也可以使用扩展运算符 `...`**\n\n# Symbol\n这玩意的用处我不太理解，就是为了表示一个唯一的值？\n**ES6 的7中原始数据类型：`Symbol`、`undefined`、`null`、`Boolean`、`String`、`Number`、`Object`**\n\n# Set 和 Map 数据结构\n**Set是一个构造函数，它的值都是唯一的。**\n```\nconst s = new Set();\n\n[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));\n\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n```\n**Set可用于去除数组中的重复项。**\n```\nconst set = new Set([1, 2, 3, 4, 4]);\n[...set]\n// [1, 2, 3, 4]\n```\n**操作Set的语法如下**\n```\nadd(value)：添加某个值，返回 Set 结构本身。\ndelete(value)：删除某个值，返回一个布尔值，表示删除是否成功。\nhas(value)：返回一个布尔值，表示该值是否为Set的成员。\nclear()：清除所有成员，没有返回值。\n```\n**WeakSet与Set的不同点**\n> WeakSet 的成员只能是对象，而不能是其他类型的值。\nWeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。\n\n**Map不同于传统Object对象的地方在于，Object的属性名只能是String类型的。而Map可以有任意类型的属性名。**\n**Map的key如果是一个对象，那么这个key应该指向同一个内存（可以用const定义之后再当做参数传入map作为属性名。）。**\n```\n// error\nconst map = new Map();\n\nmap.set(['a'], 555);\nmap.get(['a']) // undefined\n\n// success\nconst map = new Map();\n\nconst k1 = ['a'];\nconst k2 = ['a'];\n\nmap\n.set(k1, 111)\n.set(k2, 222);\n\nmap.get(k1) // 111\nmap.get(k2) // 222\n```\n**WeakMap与Map的区别：**\n> WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。\nWeakMap的键名所指向的对象，不计入垃圾回收机制。\n\n好吧，暂时先到这儿。另外一部分后面继续整理吧~知识点还是蛮多的。\n","source":"_posts/ES6 学习笔记（上）.md","raw":"---\ntitle: ES6 学习笔记（上）\ndate: 2018-01-18\n---\n\n > 认真学习了一遍ES6，发现很多很好用的功能。\n学习资料：[《ECMAScript 6 入门》](http://es6.ruanyifeng.com/#README)\n\n之前写JS，虽然也遇到一些ES6语法，基本就是理解就行，没有深入学习过。这次认真看了一遍ES6，发现里面有许多实用的东西。下面是对本书学习的一些笔记\n\n# let 和 const 命令\n解决var变量提升、变量全局的问题。\n\n**let 和 const 都只作用域本块级作用域内。**\n```\nlet a = 123\n{\n    let a = 456\n    console.log(a)\n}\nconsole.log(a)\n\n// 456\n// 123\n```\n\n**let 和 const 定义的变量不能同名。**\n**let 和 const 定义的变量不可以变量提升。**\n```\na = 5\nlet a\n\n// Error: a is not defined\n```\n**const定义的量内存不可变**\n```\nconst a = 6\nconst obj = {\n    name: 'violetjack'\n}\n\n// 以下写法会报错，因为他们指向了另一个内存地址\n// a = 6\n// obj = {}\n\nobj.name = 'jerry'\nobj.age = 56\nconsole.log(obj)\n\n// { name: 'jerry', age: 56 }\n```\n\n# 变量的结构与赋值\n快速赋值，优化代码可读性。\n\n**用法都差不多，一一对应即可**\n```\nlet [a, b, c] = [1, 2, 3] // 数组结构\nlet { name:mName, age: mAge} = { name:'violetjack', age: 28 } // 对象结构\nlet [e,f,g] = 'mmp' // 字符串结构\nconsole.log(a)\nconsole.log(mName)\nconsole.log(e + f + g)\n\n// 1\n// violetjack\n// mmp\n```\n\n# 字符串扩展\n提出了一些处理字符串的方式\n\n**提供了一些处理大于 `0xFFFF` 的字符串的方法**\n**字符串检索**\n```\nlet s = 'Hello world!';\n\ns.startsWith('Hello') // true\ns.endsWith('!') // true\ns.includes('o') // true\n\n// includes()：返回布尔值，表示是否找到了参数字符串。\n// startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。\n// endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。\n```\n**可以操作复制、填充字符串：`repeat`,`padStart`,`padEnd`**\n**模板字符串，解决字符串拼接问题。**\n```\nconst name = 'VioletJack'\nconst str = 'welcome to ' + name + \"'s blog\"\nconst str2 = `welcome to ${name}'s blog`\nconsole.log(str)\nconsole.log(str2)\n\n// welcome to VioletJack's blog\n// welcome to VioletJack's blog\n```\n相比于第一种方式，第二种方式可读性好很多。也避免了在使用 `'` `\"` 两个符号的时候需要转译的步骤。同时在引用数据上使用 `${value}` 的方式引用。非常方便！\n\n# 正则的扩展\n对于正则我一向晕晕乎乎，没啥收获。关于正则我要另外写篇博客涨涨姿势。\n\n# 数值的扩展\n主要提供了一些数字高级算法。\n**parseInt和parseFloat都在Number中调用，减少js中的全局方法。**\n```\n// ES5的写法\nparseInt('12.34') // 12\nparseFloat('123.45#') // 123.45\n\n// ES6的写法\nNumber.parseInt('12.34') // 12\nNumber.parseFloat('123.45#') // 123.45\n```\n**求指数，通过 `**` 实现**\n```\n2 ** 2 // 2*2 = 4\n2 ** 3 // 2*2*2 = 8\n```\n其他数学算法就不一一列举了，基本用不着，用到了百度即可。\n\n# 函数的扩展\n在函数参数传递方面实现了更多传递方式，实现了箭头函数。总体上是让函数应用上ES6的结构、`rest` 参数。此外还有几个提案，可以去书上看看。\n\n**更多的参数传递方式**\n```\n// 函数参数默认值\nfunction func01(a, b = 11) {\n    console.log(a + b)\n}\n\nfunc01(15)\nfunc01(10, undefined)\nfunc01(1, 1)\n\n// 参数解构\nfunction func02({a = 6, b}) {\n    console.log(a + b)\n}\n\nfunc02({a: 11, b: 12})\nfunc02({b: 6})\n\n// rest参数\nfunction func03(...vals) {\n    let count = 0\n    for (let value of vals) {\n        count += value\n    }\n    console.log(count)\n}\n\nfunc03(1, 2, 3, 4, 5)\nfunc03(11, 22, 33, 44, 55)\n```\n**提出箭头函数，简化代码。**\n```\nvar f = v => v;\n// 等同于\nvar f = function(v) {\n  return v;\n};\n\nvar f = () => 5;\n// 等同于\nvar f = function () { return 5 };\n\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {\n  return num1 + num2;\n};\n```\n注意如果参数或者返回结果是对象，需要用`()`包裹。\n```\nvar fun = ({ a, b }) => a + b\nvar fun02 = a => ({ value: a })\n```\n另外一个特别要注意的就是 `this`，我看到过好几篇博客来解释箭头函数的 `this` 的，可见这个 `this` 的特殊性。可以[在掘金搜索箭头函数](https://juejin.im/search?query=%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0)，里面全是解释（tu cao）箭头函数的~\n下面搬运书上对箭头函数的注意点。\n\n> 箭头函数有几个使用注意点。\n（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。\n（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。\n上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。\n\n# 数组的扩展\n**扩展运算符，和函数中的rest参数是一回事。我的理解就是把数组拆分成一个个值。**\n```\nlet arr = [1, 2, 3, 4]\nconsole.log(...arr)\nconsole.log([0, 8, 6, ...arr, 10])\nlet str = 'jack'\nconsole.log(...str)\n\n// 1 2 3 4\n// [ 0, 8, 6, 1, 2, 3, 4, 10 ]\n// j a c k\n```\n**Array.from 将类数组对象转为真正的数组。**\n**Array.of 将多个值转为数组**\n```\nArray.of(3, 11, 8) \n// [3,11,8]\n```\n**copyWithin 将数组中某些内容来替换指定内容**\n**find 和 findIndex 用于找到数组中第一个符合条件的值和索引位置。**\n```\nvar a = [1, 4, -5, 10].find((n) => n < 2)\nconsole.log(a)\nvar b = [1, 5, 10, 15].findIndex(function (value, index, arr) {\n    return value > 11;\n}) \nconsole.log(b)\n\n// 1\n// 3\n```\n**fill 用于填充数组**\n**entries、keys和values用来遍历数组非常方便，通过不同方法返回所需数组内容。**\n```\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n```\n**includes 方法与字符串的 includes 类似，用于查找数组中是否有某个值，返回布尔类型的值。**\n**ES6中将数组空位转为undefined**\n```\nconsole.log([...['a',,'b']])\n// [ \"a\", undefined, \"b\" ]\n```\n\n# 对象的扩展\n**对象属性的简洁表示法，也就是我们常看到的ES6的写法。对象中不再必须要传递 `key-value` 的形式了。**\n```\nlet a = 12\nlet b = 22\nlet obj = { a, b }\nconsole.log(obj)\n\n// { a: 12. b: 22 }\n\nlet obj02 = {\n    log() {\n        console.log('Hello!')\n    }\n}\n```\n**对于对象属性名，支持使用 `[字符串]` 的形式来作为对象属性名。**\n```\nlet obj = {\n    name: 'jack',\n    ['age']: 28,\n    ['se' + 'x']: 'male'\n}\nconsole.log(obj)\n\n// {name: \"jack\", age: 28, sex: \"male\"}\n```\n**Object.is方法用于比较两个值是否严格相等。**\n**Object.assign 用于对象的合并，如果有同名属性，后添加的覆盖之前的属性。**\n```\nlet obj1 = {\n    name: 'jack'\n}\n\nlet obj2 = {\n    ['age']: 28,\n    ['se' + 'x']: 'male'\n}\n\nlet obj3 = {\n    job: 'js'\n}\n\nlet obj4 = {\n    name: 'rose',\n    hobby: 'game'\n}\n\nObject.assign(obj1, obj2, obj3, obj4)\nconsole.log(obj1)\n\n// {name: \"rose\", age: 28, sex: \"male\", job: \"js\", hobby: \"game\"}\n```\n**对象的__proto__属性是一个内部属性，所以前后有下划线。不建议修改该属性。**\n**ES6的super关键字用于继承，可以理解为java的super关键字。**\n**Object.keys()，Object.values()，Object.entries()和Array的类似，是对对象的一个遍历过程。**\n```\nlet {keys, values, entries} = Object;\nlet obj = { a: 1, b: 2, c: 3 };\n\nfor (let key of keys(obj)) {\n  console.log(key); // 'a', 'b', 'c'\n}\n\nfor (let value of values(obj)) {\n  console.log(value); // 1, 2, 3\n}\n\nfor (let [key, value] of entries(obj)) {\n  console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]\n}\n```\n**在对象中也可以使用扩展运算符 `...`**\n\n# Symbol\n这玩意的用处我不太理解，就是为了表示一个唯一的值？\n**ES6 的7中原始数据类型：`Symbol`、`undefined`、`null`、`Boolean`、`String`、`Number`、`Object`**\n\n# Set 和 Map 数据结构\n**Set是一个构造函数，它的值都是唯一的。**\n```\nconst s = new Set();\n\n[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));\n\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n```\n**Set可用于去除数组中的重复项。**\n```\nconst set = new Set([1, 2, 3, 4, 4]);\n[...set]\n// [1, 2, 3, 4]\n```\n**操作Set的语法如下**\n```\nadd(value)：添加某个值，返回 Set 结构本身。\ndelete(value)：删除某个值，返回一个布尔值，表示删除是否成功。\nhas(value)：返回一个布尔值，表示该值是否为Set的成员。\nclear()：清除所有成员，没有返回值。\n```\n**WeakSet与Set的不同点**\n> WeakSet 的成员只能是对象，而不能是其他类型的值。\nWeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。\n\n**Map不同于传统Object对象的地方在于，Object的属性名只能是String类型的。而Map可以有任意类型的属性名。**\n**Map的key如果是一个对象，那么这个key应该指向同一个内存（可以用const定义之后再当做参数传入map作为属性名。）。**\n```\n// error\nconst map = new Map();\n\nmap.set(['a'], 555);\nmap.get(['a']) // undefined\n\n// success\nconst map = new Map();\n\nconst k1 = ['a'];\nconst k2 = ['a'];\n\nmap\n.set(k1, 111)\n.set(k2, 222);\n\nmap.get(k1) // 111\nmap.get(k2) // 222\n```\n**WeakMap与Map的区别：**\n> WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。\nWeakMap的键名所指向的对象，不计入垃圾回收机制。\n\n好吧，暂时先到这儿。另外一部分后面继续整理吧~知识点还是蛮多的。\n","slug":"ES6 学习笔记（上）","published":1,"updated":"2018-02-07T02:27:17.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjddwxblw0000i8btlvrckhqh","content":"<blockquote>\n<p>认真学习了一遍ES6，发现很多很好用的功能。<br>学习资料：<a href=\"http://es6.ruanyifeng.com/#README\" target=\"_blank\" rel=\"noopener\">《ECMAScript 6 入门》</a></p>\n</blockquote>\n<p>之前写JS，虽然也遇到一些ES6语法，基本就是理解就行，没有深入学习过。这次认真看了一遍ES6，发现里面有许多实用的东西。下面是对本书学习的一些笔记</p>\n<h1 id=\"let-和-const-命令\"><a href=\"#let-和-const-命令\" class=\"headerlink\" title=\"let 和 const 命令\"></a>let 和 const 命令</h1><p>解决var变量提升、变量全局的问题。</p>\n<p><strong>let 和 const 都只作用域本块级作用域内。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = 123</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    let a = 456</span><br><span class=\"line\">    console.log(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(a)</span><br><span class=\"line\"></span><br><span class=\"line\">// 456</span><br><span class=\"line\">// 123</span><br></pre></td></tr></table></figure></p>\n<p><strong>let 和 const 定义的变量不能同名。</strong><br><strong>let 和 const 定义的变量不可以变量提升。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 5</span><br><span class=\"line\">let a</span><br><span class=\"line\"></span><br><span class=\"line\">// Error: a is not defined</span><br></pre></td></tr></table></figure></p>\n<p><strong>const定义的量内存不可变</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = 6</span><br><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">    name: &apos;violetjack&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 以下写法会报错，因为他们指向了另一个内存地址</span><br><span class=\"line\">// a = 6</span><br><span class=\"line\">// obj = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.name = &apos;jerry&apos;</span><br><span class=\"line\">obj.age = 56</span><br><span class=\"line\">console.log(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">// &#123; name: &apos;jerry&apos;, age: 56 &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"变量的结构与赋值\"><a href=\"#变量的结构与赋值\" class=\"headerlink\" title=\"变量的结构与赋值\"></a>变量的结构与赋值</h1><p>快速赋值，优化代码可读性。</p>\n<p><strong>用法都差不多，一一对应即可</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [a, b, c] = [1, 2, 3] // 数组结构</span><br><span class=\"line\">let &#123; name:mName, age: mAge&#125; = &#123; name:&apos;violetjack&apos;, age: 28 &#125; // 对象结构</span><br><span class=\"line\">let [e,f,g] = &apos;mmp&apos; // 字符串结构</span><br><span class=\"line\">console.log(a)</span><br><span class=\"line\">console.log(mName)</span><br><span class=\"line\">console.log(e + f + g)</span><br><span class=\"line\"></span><br><span class=\"line\">// 1</span><br><span class=\"line\">// violetjack</span><br><span class=\"line\">// mmp</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"字符串扩展\"><a href=\"#字符串扩展\" class=\"headerlink\" title=\"字符串扩展\"></a>字符串扩展</h1><p>提出了一些处理字符串的方式</p>\n<p><strong>提供了一些处理大于 <code>0xFFFF</code> 的字符串的方法</strong><br><strong>字符串检索</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let s = &apos;Hello world!&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">s.startsWith(&apos;Hello&apos;) // true</span><br><span class=\"line\">s.endsWith(&apos;!&apos;) // true</span><br><span class=\"line\">s.includes(&apos;o&apos;) // true</span><br><span class=\"line\"></span><br><span class=\"line\">// includes()：返回布尔值，表示是否找到了参数字符串。</span><br><span class=\"line\">// startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</span><br><span class=\"line\">// endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</span><br></pre></td></tr></table></figure></p>\n<p><strong>可以操作复制、填充字符串：<code>repeat</code>,<code>padStart</code>,<code>padEnd</code></strong><br><strong>模板字符串，解决字符串拼接问题。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const name = &apos;VioletJack&apos;</span><br><span class=\"line\">const str = &apos;welcome to &apos; + name + &quot;&apos;s blog&quot;</span><br><span class=\"line\">const str2 = `welcome to $&#123;name&#125;&apos;s blog`</span><br><span class=\"line\">console.log(str)</span><br><span class=\"line\">console.log(str2)</span><br><span class=\"line\"></span><br><span class=\"line\">// welcome to VioletJack&apos;s blog</span><br><span class=\"line\">// welcome to VioletJack&apos;s blog</span><br></pre></td></tr></table></figure></p>\n<p>相比于第一种方式，第二种方式可读性好很多。也避免了在使用 <code>&#39;</code> <code>&quot;</code> 两个符号的时候需要转译的步骤。同时在引用数据上使用 <code>${value}</code> 的方式引用。非常方便！</p>\n<h1 id=\"正则的扩展\"><a href=\"#正则的扩展\" class=\"headerlink\" title=\"正则的扩展\"></a>正则的扩展</h1><p>对于正则我一向晕晕乎乎，没啥收获。关于正则我要另外写篇博客涨涨姿势。</p>\n<h1 id=\"数值的扩展\"><a href=\"#数值的扩展\" class=\"headerlink\" title=\"数值的扩展\"></a>数值的扩展</h1><p>主要提供了一些数字高级算法。<br><strong>parseInt和parseFloat都在Number中调用，减少js中的全局方法。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ES5的写法</span><br><span class=\"line\">parseInt(&apos;12.34&apos;) // 12</span><br><span class=\"line\">parseFloat(&apos;123.45#&apos;) // 123.45</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6的写法</span><br><span class=\"line\">Number.parseInt(&apos;12.34&apos;) // 12</span><br><span class=\"line\">Number.parseFloat(&apos;123.45#&apos;) // 123.45</span><br></pre></td></tr></table></figure></p>\n<p><strong>求指数，通过 `</strong>` 实现**<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 ** 2 // 2*2 = 4</span><br><span class=\"line\">2 ** 3 // 2*2*2 = 8</span><br></pre></td></tr></table></figure></p>\n<p>其他数学算法就不一一列举了，基本用不着，用到了百度即可。</p>\n<h1 id=\"函数的扩展\"><a href=\"#函数的扩展\" class=\"headerlink\" title=\"函数的扩展\"></a>函数的扩展</h1><p>在函数参数传递方面实现了更多传递方式，实现了箭头函数。总体上是让函数应用上ES6的结构、<code>rest</code> 参数。此外还有几个提案，可以去书上看看。</p>\n<p><strong>更多的参数传递方式</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 函数参数默认值</span><br><span class=\"line\">function func01(a, b = 11) &#123;</span><br><span class=\"line\">    console.log(a + b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func01(15)</span><br><span class=\"line\">func01(10, undefined)</span><br><span class=\"line\">func01(1, 1)</span><br><span class=\"line\"></span><br><span class=\"line\">// 参数解构</span><br><span class=\"line\">function func02(&#123;a = 6, b&#125;) &#123;</span><br><span class=\"line\">    console.log(a + b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func02(&#123;a: 11, b: 12&#125;)</span><br><span class=\"line\">func02(&#123;b: 6&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// rest参数</span><br><span class=\"line\">function func03(...vals) &#123;</span><br><span class=\"line\">    let count = 0</span><br><span class=\"line\">    for (let value of vals) &#123;</span><br><span class=\"line\">        count += value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(count)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func03(1, 2, 3, 4, 5)</span><br><span class=\"line\">func03(11, 22, 33, 44, 55)</span><br></pre></td></tr></table></figure></p>\n<p><strong>提出箭头函数，简化代码。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f = v =&gt; v;</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">var f = function(v) &#123;</span><br><span class=\"line\">  return v;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var f = () =&gt; 5;</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">var f = function () &#123; return 5 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var sum = (num1, num2) =&gt; num1 + num2;</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">var sum = function(num1, num2) &#123;</span><br><span class=\"line\">  return num1 + num2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>注意如果参数或者返回结果是对象，需要用<code>()</code>包裹。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fun = (&#123; a, b &#125;) =&gt; a + b</span><br><span class=\"line\">var fun02 = a =&gt; (&#123; value: a &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>另外一个特别要注意的就是 <code>this</code>，我看到过好几篇博客来解释箭头函数的 <code>this</code> 的，可见这个 <code>this</code> 的特殊性。可以<a href=\"https://juejin.im/search?query=%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\" target=\"_blank\" rel=\"noopener\">在掘金搜索箭头函数</a>，里面全是解释（tu cao）箭头函数的~<br>下面搬运书上对箭头函数的注意点。</p>\n<blockquote>\n<p>箭头函数有几个使用注意点。<br>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。<br>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。<br>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。<br>上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。</p>\n</blockquote>\n<h1 id=\"数组的扩展\"><a href=\"#数组的扩展\" class=\"headerlink\" title=\"数组的扩展\"></a>数组的扩展</h1><p><strong>扩展运算符，和函数中的rest参数是一回事。我的理解就是把数组拆分成一个个值。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1, 2, 3, 4]</span><br><span class=\"line\">console.log(...arr)</span><br><span class=\"line\">console.log([0, 8, 6, ...arr, 10])</span><br><span class=\"line\">let str = &apos;jack&apos;</span><br><span class=\"line\">console.log(...str)</span><br><span class=\"line\"></span><br><span class=\"line\">// 1 2 3 4</span><br><span class=\"line\">// [ 0, 8, 6, 1, 2, 3, 4, 10 ]</span><br><span class=\"line\">// j a c k</span><br></pre></td></tr></table></figure></p>\n<p><strong>Array.from 将类数组对象转为真正的数组。</strong><br><strong>Array.of 将多个值转为数组</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.of(3, 11, 8) </span><br><span class=\"line\">// [3,11,8]</span><br></pre></td></tr></table></figure></p>\n<p><strong>copyWithin 将数组中某些内容来替换指定内容</strong><br><strong>find 和 findIndex 用于找到数组中第一个符合条件的值和索引位置。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = [1, 4, -5, 10].find((n) =&gt; n &lt; 2)</span><br><span class=\"line\">console.log(a)</span><br><span class=\"line\">var b = [1, 5, 10, 15].findIndex(function (value, index, arr) &#123;</span><br><span class=\"line\">    return value &gt; 11;</span><br><span class=\"line\">&#125;) </span><br><span class=\"line\">console.log(b)</span><br><span class=\"line\"></span><br><span class=\"line\">// 1</span><br><span class=\"line\">// 3</span><br></pre></td></tr></table></figure></p>\n<p><strong>fill 用于填充数组</strong><br><strong>entries、keys和values用来遍历数组非常方便，通过不同方法返回所需数组内容。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</span><br><span class=\"line\">  console.log(index);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 0</span><br><span class=\"line\">// 1</span><br><span class=\"line\"></span><br><span class=\"line\">for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123;</span><br><span class=\"line\">  console.log(elem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// &apos;a&apos;</span><br><span class=\"line\">// &apos;b&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</span><br><span class=\"line\">  console.log(index, elem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 0 &quot;a&quot;</span><br><span class=\"line\">// 1 &quot;b&quot;</span><br></pre></td></tr></table></figure></p>\n<p><strong>includes 方法与字符串的 includes 类似，用于查找数组中是否有某个值，返回布尔类型的值。</strong><br><strong>ES6中将数组空位转为undefined</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log([...[&apos;a&apos;,,&apos;b&apos;]])</span><br><span class=\"line\">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"对象的扩展\"><a href=\"#对象的扩展\" class=\"headerlink\" title=\"对象的扩展\"></a>对象的扩展</h1><p><strong>对象属性的简洁表示法，也就是我们常看到的ES6的写法。对象中不再必须要传递 <code>key-value</code> 的形式了。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = 12</span><br><span class=\"line\">let b = 22</span><br><span class=\"line\">let obj = &#123; a, b &#125;</span><br><span class=\"line\">console.log(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">// &#123; a: 12. b: 22 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj02 = &#123;</span><br><span class=\"line\">    log() &#123;</span><br><span class=\"line\">        console.log(&apos;Hello!&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>对于对象属性名，支持使用 <code>[字符串]</code> 的形式来作为对象属性名。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    name: &apos;jack&apos;,</span><br><span class=\"line\">    [&apos;age&apos;]: 28,</span><br><span class=\"line\">    [&apos;se&apos; + &apos;x&apos;]: &apos;male&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">// &#123;name: &quot;jack&quot;, age: 28, sex: &quot;male&quot;&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Object.is方法用于比较两个值是否严格相等。</strong><br><strong>Object.assign 用于对象的合并，如果有同名属性，后添加的覆盖之前的属性。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj1 = &#123;</span><br><span class=\"line\">    name: &apos;jack&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj2 = &#123;</span><br><span class=\"line\">    [&apos;age&apos;]: 28,</span><br><span class=\"line\">    [&apos;se&apos; + &apos;x&apos;]: &apos;male&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj3 = &#123;</span><br><span class=\"line\">    job: &apos;js&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj4 = &#123;</span><br><span class=\"line\">    name: &apos;rose&apos;,</span><br><span class=\"line\">    hobby: &apos;game&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.assign(obj1, obj2, obj3, obj4)</span><br><span class=\"line\">console.log(obj1)</span><br><span class=\"line\"></span><br><span class=\"line\">// &#123;name: &quot;rose&quot;, age: 28, sex: &quot;male&quot;, job: &quot;js&quot;, hobby: &quot;game&quot;&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>对象的<strong>proto</strong>属性是一个内部属性，所以前后有下划线。不建议修改该属性。</strong><br><strong>ES6的super关键字用于继承，可以理解为java的super关键字。</strong><br><strong>Object.keys()，Object.values()，Object.entries()和Array的类似，是对对象的一个遍历过程。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;keys, values, entries&#125; = Object;</span><br><span class=\"line\">let obj = &#123; a: 1, b: 2, c: 3 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let key of keys(obj)) &#123;</span><br><span class=\"line\">  console.log(key); // &apos;a&apos;, &apos;b&apos;, &apos;c&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let value of values(obj)) &#123;</span><br><span class=\"line\">  console.log(value); // 1, 2, 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let [key, value] of entries(obj)) &#123;</span><br><span class=\"line\">  console.log([key, value]); // [&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>在对象中也可以使用扩展运算符 <code>...</code></strong></p>\n<h1 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h1><p>这玩意的用处我不太理解，就是为了表示一个唯一的值？<br><strong>ES6 的7中原始数据类型：<code>Symbol</code>、<code>undefined</code>、<code>null</code>、<code>Boolean</code>、<code>String</code>、<code>Number</code>、<code>Object</code></strong></p>\n<h1 id=\"Set-和-Map-数据结构\"><a href=\"#Set-和-Map-数据结构\" class=\"headerlink\" title=\"Set 和 Map 数据结构\"></a>Set 和 Map 数据结构</h1><p><strong>Set是一个构造函数，它的值都是唯一的。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const s = new Set();</span><br><span class=\"line\"></span><br><span class=\"line\">[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));</span><br><span class=\"line\"></span><br><span class=\"line\">for (let i of s) &#123;</span><br><span class=\"line\">  console.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 2 3 5 4</span><br></pre></td></tr></table></figure></p>\n<p><strong>Set可用于去除数组中的重复项。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const set = new Set([1, 2, 3, 4, 4]);</span><br><span class=\"line\">[...set]</span><br><span class=\"line\">// [1, 2, 3, 4]</span><br></pre></td></tr></table></figure></p>\n<p><strong>操作Set的语法如下</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(value)：添加某个值，返回 Set 结构本身。</span><br><span class=\"line\">delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</span><br><span class=\"line\">has(value)：返回一个布尔值，表示该值是否为Set的成员。</span><br><span class=\"line\">clear()：清除所有成员，没有返回值。</span><br></pre></td></tr></table></figure></p>\n<p><strong>WeakSet与Set的不同点</strong></p>\n<blockquote>\n<p>WeakSet 的成员只能是对象，而不能是其他类型的值。<br>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>\n</blockquote>\n<p><strong>Map不同于传统Object对象的地方在于，Object的属性名只能是String类型的。而Map可以有任意类型的属性名。</strong><br><strong>Map的key如果是一个对象，那么这个key应该指向同一个内存（可以用const定义之后再当做参数传入map作为属性名。）。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// error</span><br><span class=\"line\">const map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">map.set([&apos;a&apos;], 555);</span><br><span class=\"line\">map.get([&apos;a&apos;]) // undefined</span><br><span class=\"line\"></span><br><span class=\"line\">// success</span><br><span class=\"line\">const map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">const k1 = [&apos;a&apos;];</span><br><span class=\"line\">const k2 = [&apos;a&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">map</span><br><span class=\"line\">.set(k1, 111)</span><br><span class=\"line\">.set(k2, 222);</span><br><span class=\"line\"></span><br><span class=\"line\">map.get(k1) // 111</span><br><span class=\"line\">map.get(k2) // 222</span><br></pre></td></tr></table></figure></p>\n<p><strong>WeakMap与Map的区别：</strong></p>\n<blockquote>\n<p>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。<br>WeakMap的键名所指向的对象，不计入垃圾回收机制。</p>\n</blockquote>\n<p>好吧，暂时先到这儿。另外一部分后面继续整理吧~知识点还是蛮多的。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>认真学习了一遍ES6，发现很多很好用的功能。<br>学习资料：<a href=\"http://es6.ruanyifeng.com/#README\" target=\"_blank\" rel=\"noopener\">《ECMAScript 6 入门》</a></p>\n</blockquote>\n<p>之前写JS，虽然也遇到一些ES6语法，基本就是理解就行，没有深入学习过。这次认真看了一遍ES6，发现里面有许多实用的东西。下面是对本书学习的一些笔记</p>\n<h1 id=\"let-和-const-命令\"><a href=\"#let-和-const-命令\" class=\"headerlink\" title=\"let 和 const 命令\"></a>let 和 const 命令</h1><p>解决var变量提升、变量全局的问题。</p>\n<p><strong>let 和 const 都只作用域本块级作用域内。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = 123</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    let a = 456</span><br><span class=\"line\">    console.log(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(a)</span><br><span class=\"line\"></span><br><span class=\"line\">// 456</span><br><span class=\"line\">// 123</span><br></pre></td></tr></table></figure></p>\n<p><strong>let 和 const 定义的变量不能同名。</strong><br><strong>let 和 const 定义的变量不可以变量提升。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 5</span><br><span class=\"line\">let a</span><br><span class=\"line\"></span><br><span class=\"line\">// Error: a is not defined</span><br></pre></td></tr></table></figure></p>\n<p><strong>const定义的量内存不可变</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = 6</span><br><span class=\"line\">const obj = &#123;</span><br><span class=\"line\">    name: &apos;violetjack&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 以下写法会报错，因为他们指向了另一个内存地址</span><br><span class=\"line\">// a = 6</span><br><span class=\"line\">// obj = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.name = &apos;jerry&apos;</span><br><span class=\"line\">obj.age = 56</span><br><span class=\"line\">console.log(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">// &#123; name: &apos;jerry&apos;, age: 56 &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"变量的结构与赋值\"><a href=\"#变量的结构与赋值\" class=\"headerlink\" title=\"变量的结构与赋值\"></a>变量的结构与赋值</h1><p>快速赋值，优化代码可读性。</p>\n<p><strong>用法都差不多，一一对应即可</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [a, b, c] = [1, 2, 3] // 数组结构</span><br><span class=\"line\">let &#123; name:mName, age: mAge&#125; = &#123; name:&apos;violetjack&apos;, age: 28 &#125; // 对象结构</span><br><span class=\"line\">let [e,f,g] = &apos;mmp&apos; // 字符串结构</span><br><span class=\"line\">console.log(a)</span><br><span class=\"line\">console.log(mName)</span><br><span class=\"line\">console.log(e + f + g)</span><br><span class=\"line\"></span><br><span class=\"line\">// 1</span><br><span class=\"line\">// violetjack</span><br><span class=\"line\">// mmp</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"字符串扩展\"><a href=\"#字符串扩展\" class=\"headerlink\" title=\"字符串扩展\"></a>字符串扩展</h1><p>提出了一些处理字符串的方式</p>\n<p><strong>提供了一些处理大于 <code>0xFFFF</code> 的字符串的方法</strong><br><strong>字符串检索</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let s = &apos;Hello world!&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">s.startsWith(&apos;Hello&apos;) // true</span><br><span class=\"line\">s.endsWith(&apos;!&apos;) // true</span><br><span class=\"line\">s.includes(&apos;o&apos;) // true</span><br><span class=\"line\"></span><br><span class=\"line\">// includes()：返回布尔值，表示是否找到了参数字符串。</span><br><span class=\"line\">// startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</span><br><span class=\"line\">// endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</span><br></pre></td></tr></table></figure></p>\n<p><strong>可以操作复制、填充字符串：<code>repeat</code>,<code>padStart</code>,<code>padEnd</code></strong><br><strong>模板字符串，解决字符串拼接问题。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const name = &apos;VioletJack&apos;</span><br><span class=\"line\">const str = &apos;welcome to &apos; + name + &quot;&apos;s blog&quot;</span><br><span class=\"line\">const str2 = `welcome to $&#123;name&#125;&apos;s blog`</span><br><span class=\"line\">console.log(str)</span><br><span class=\"line\">console.log(str2)</span><br><span class=\"line\"></span><br><span class=\"line\">// welcome to VioletJack&apos;s blog</span><br><span class=\"line\">// welcome to VioletJack&apos;s blog</span><br></pre></td></tr></table></figure></p>\n<p>相比于第一种方式，第二种方式可读性好很多。也避免了在使用 <code>&#39;</code> <code>&quot;</code> 两个符号的时候需要转译的步骤。同时在引用数据上使用 <code>${value}</code> 的方式引用。非常方便！</p>\n<h1 id=\"正则的扩展\"><a href=\"#正则的扩展\" class=\"headerlink\" title=\"正则的扩展\"></a>正则的扩展</h1><p>对于正则我一向晕晕乎乎，没啥收获。关于正则我要另外写篇博客涨涨姿势。</p>\n<h1 id=\"数值的扩展\"><a href=\"#数值的扩展\" class=\"headerlink\" title=\"数值的扩展\"></a>数值的扩展</h1><p>主要提供了一些数字高级算法。<br><strong>parseInt和parseFloat都在Number中调用，减少js中的全局方法。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ES5的写法</span><br><span class=\"line\">parseInt(&apos;12.34&apos;) // 12</span><br><span class=\"line\">parseFloat(&apos;123.45#&apos;) // 123.45</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6的写法</span><br><span class=\"line\">Number.parseInt(&apos;12.34&apos;) // 12</span><br><span class=\"line\">Number.parseFloat(&apos;123.45#&apos;) // 123.45</span><br></pre></td></tr></table></figure></p>\n<p><strong>求指数，通过 `</strong>` 实现**<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 ** 2 // 2*2 = 4</span><br><span class=\"line\">2 ** 3 // 2*2*2 = 8</span><br></pre></td></tr></table></figure></p>\n<p>其他数学算法就不一一列举了，基本用不着，用到了百度即可。</p>\n<h1 id=\"函数的扩展\"><a href=\"#函数的扩展\" class=\"headerlink\" title=\"函数的扩展\"></a>函数的扩展</h1><p>在函数参数传递方面实现了更多传递方式，实现了箭头函数。总体上是让函数应用上ES6的结构、<code>rest</code> 参数。此外还有几个提案，可以去书上看看。</p>\n<p><strong>更多的参数传递方式</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 函数参数默认值</span><br><span class=\"line\">function func01(a, b = 11) &#123;</span><br><span class=\"line\">    console.log(a + b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func01(15)</span><br><span class=\"line\">func01(10, undefined)</span><br><span class=\"line\">func01(1, 1)</span><br><span class=\"line\"></span><br><span class=\"line\">// 参数解构</span><br><span class=\"line\">function func02(&#123;a = 6, b&#125;) &#123;</span><br><span class=\"line\">    console.log(a + b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func02(&#123;a: 11, b: 12&#125;)</span><br><span class=\"line\">func02(&#123;b: 6&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// rest参数</span><br><span class=\"line\">function func03(...vals) &#123;</span><br><span class=\"line\">    let count = 0</span><br><span class=\"line\">    for (let value of vals) &#123;</span><br><span class=\"line\">        count += value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(count)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func03(1, 2, 3, 4, 5)</span><br><span class=\"line\">func03(11, 22, 33, 44, 55)</span><br></pre></td></tr></table></figure></p>\n<p><strong>提出箭头函数，简化代码。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f = v =&gt; v;</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">var f = function(v) &#123;</span><br><span class=\"line\">  return v;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var f = () =&gt; 5;</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">var f = function () &#123; return 5 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var sum = (num1, num2) =&gt; num1 + num2;</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">var sum = function(num1, num2) &#123;</span><br><span class=\"line\">  return num1 + num2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>注意如果参数或者返回结果是对象，需要用<code>()</code>包裹。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fun = (&#123; a, b &#125;) =&gt; a + b</span><br><span class=\"line\">var fun02 = a =&gt; (&#123; value: a &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>另外一个特别要注意的就是 <code>this</code>，我看到过好几篇博客来解释箭头函数的 <code>this</code> 的，可见这个 <code>this</code> 的特殊性。可以<a href=\"https://juejin.im/search?query=%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\" target=\"_blank\" rel=\"noopener\">在掘金搜索箭头函数</a>，里面全是解释（tu cao）箭头函数的~<br>下面搬运书上对箭头函数的注意点。</p>\n<blockquote>\n<p>箭头函数有几个使用注意点。<br>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。<br>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。<br>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。<br>上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。</p>\n</blockquote>\n<h1 id=\"数组的扩展\"><a href=\"#数组的扩展\" class=\"headerlink\" title=\"数组的扩展\"></a>数组的扩展</h1><p><strong>扩展运算符，和函数中的rest参数是一回事。我的理解就是把数组拆分成一个个值。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1, 2, 3, 4]</span><br><span class=\"line\">console.log(...arr)</span><br><span class=\"line\">console.log([0, 8, 6, ...arr, 10])</span><br><span class=\"line\">let str = &apos;jack&apos;</span><br><span class=\"line\">console.log(...str)</span><br><span class=\"line\"></span><br><span class=\"line\">// 1 2 3 4</span><br><span class=\"line\">// [ 0, 8, 6, 1, 2, 3, 4, 10 ]</span><br><span class=\"line\">// j a c k</span><br></pre></td></tr></table></figure></p>\n<p><strong>Array.from 将类数组对象转为真正的数组。</strong><br><strong>Array.of 将多个值转为数组</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.of(3, 11, 8) </span><br><span class=\"line\">// [3,11,8]</span><br></pre></td></tr></table></figure></p>\n<p><strong>copyWithin 将数组中某些内容来替换指定内容</strong><br><strong>find 和 findIndex 用于找到数组中第一个符合条件的值和索引位置。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = [1, 4, -5, 10].find((n) =&gt; n &lt; 2)</span><br><span class=\"line\">console.log(a)</span><br><span class=\"line\">var b = [1, 5, 10, 15].findIndex(function (value, index, arr) &#123;</span><br><span class=\"line\">    return value &gt; 11;</span><br><span class=\"line\">&#125;) </span><br><span class=\"line\">console.log(b)</span><br><span class=\"line\"></span><br><span class=\"line\">// 1</span><br><span class=\"line\">// 3</span><br></pre></td></tr></table></figure></p>\n<p><strong>fill 用于填充数组</strong><br><strong>entries、keys和values用来遍历数组非常方便，通过不同方法返回所需数组内容。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</span><br><span class=\"line\">  console.log(index);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 0</span><br><span class=\"line\">// 1</span><br><span class=\"line\"></span><br><span class=\"line\">for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123;</span><br><span class=\"line\">  console.log(elem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// &apos;a&apos;</span><br><span class=\"line\">// &apos;b&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</span><br><span class=\"line\">  console.log(index, elem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 0 &quot;a&quot;</span><br><span class=\"line\">// 1 &quot;b&quot;</span><br></pre></td></tr></table></figure></p>\n<p><strong>includes 方法与字符串的 includes 类似，用于查找数组中是否有某个值，返回布尔类型的值。</strong><br><strong>ES6中将数组空位转为undefined</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log([...[&apos;a&apos;,,&apos;b&apos;]])</span><br><span class=\"line\">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"对象的扩展\"><a href=\"#对象的扩展\" class=\"headerlink\" title=\"对象的扩展\"></a>对象的扩展</h1><p><strong>对象属性的简洁表示法，也就是我们常看到的ES6的写法。对象中不再必须要传递 <code>key-value</code> 的形式了。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = 12</span><br><span class=\"line\">let b = 22</span><br><span class=\"line\">let obj = &#123; a, b &#125;</span><br><span class=\"line\">console.log(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">// &#123; a: 12. b: 22 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj02 = &#123;</span><br><span class=\"line\">    log() &#123;</span><br><span class=\"line\">        console.log(&apos;Hello!&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>对于对象属性名，支持使用 <code>[字符串]</code> 的形式来作为对象属性名。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    name: &apos;jack&apos;,</span><br><span class=\"line\">    [&apos;age&apos;]: 28,</span><br><span class=\"line\">    [&apos;se&apos; + &apos;x&apos;]: &apos;male&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">// &#123;name: &quot;jack&quot;, age: 28, sex: &quot;male&quot;&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Object.is方法用于比较两个值是否严格相等。</strong><br><strong>Object.assign 用于对象的合并，如果有同名属性，后添加的覆盖之前的属性。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj1 = &#123;</span><br><span class=\"line\">    name: &apos;jack&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj2 = &#123;</span><br><span class=\"line\">    [&apos;age&apos;]: 28,</span><br><span class=\"line\">    [&apos;se&apos; + &apos;x&apos;]: &apos;male&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj3 = &#123;</span><br><span class=\"line\">    job: &apos;js&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj4 = &#123;</span><br><span class=\"line\">    name: &apos;rose&apos;,</span><br><span class=\"line\">    hobby: &apos;game&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.assign(obj1, obj2, obj3, obj4)</span><br><span class=\"line\">console.log(obj1)</span><br><span class=\"line\"></span><br><span class=\"line\">// &#123;name: &quot;rose&quot;, age: 28, sex: &quot;male&quot;, job: &quot;js&quot;, hobby: &quot;game&quot;&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>对象的<strong>proto</strong>属性是一个内部属性，所以前后有下划线。不建议修改该属性。</strong><br><strong>ES6的super关键字用于继承，可以理解为java的super关键字。</strong><br><strong>Object.keys()，Object.values()，Object.entries()和Array的类似，是对对象的一个遍历过程。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;keys, values, entries&#125; = Object;</span><br><span class=\"line\">let obj = &#123; a: 1, b: 2, c: 3 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let key of keys(obj)) &#123;</span><br><span class=\"line\">  console.log(key); // &apos;a&apos;, &apos;b&apos;, &apos;c&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let value of values(obj)) &#123;</span><br><span class=\"line\">  console.log(value); // 1, 2, 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let [key, value] of entries(obj)) &#123;</span><br><span class=\"line\">  console.log([key, value]); // [&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>在对象中也可以使用扩展运算符 <code>...</code></strong></p>\n<h1 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h1><p>这玩意的用处我不太理解，就是为了表示一个唯一的值？<br><strong>ES6 的7中原始数据类型：<code>Symbol</code>、<code>undefined</code>、<code>null</code>、<code>Boolean</code>、<code>String</code>、<code>Number</code>、<code>Object</code></strong></p>\n<h1 id=\"Set-和-Map-数据结构\"><a href=\"#Set-和-Map-数据结构\" class=\"headerlink\" title=\"Set 和 Map 数据结构\"></a>Set 和 Map 数据结构</h1><p><strong>Set是一个构造函数，它的值都是唯一的。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const s = new Set();</span><br><span class=\"line\"></span><br><span class=\"line\">[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));</span><br><span class=\"line\"></span><br><span class=\"line\">for (let i of s) &#123;</span><br><span class=\"line\">  console.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 2 3 5 4</span><br></pre></td></tr></table></figure></p>\n<p><strong>Set可用于去除数组中的重复项。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const set = new Set([1, 2, 3, 4, 4]);</span><br><span class=\"line\">[...set]</span><br><span class=\"line\">// [1, 2, 3, 4]</span><br></pre></td></tr></table></figure></p>\n<p><strong>操作Set的语法如下</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(value)：添加某个值，返回 Set 结构本身。</span><br><span class=\"line\">delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</span><br><span class=\"line\">has(value)：返回一个布尔值，表示该值是否为Set的成员。</span><br><span class=\"line\">clear()：清除所有成员，没有返回值。</span><br></pre></td></tr></table></figure></p>\n<p><strong>WeakSet与Set的不同点</strong></p>\n<blockquote>\n<p>WeakSet 的成员只能是对象，而不能是其他类型的值。<br>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>\n</blockquote>\n<p><strong>Map不同于传统Object对象的地方在于，Object的属性名只能是String类型的。而Map可以有任意类型的属性名。</strong><br><strong>Map的key如果是一个对象，那么这个key应该指向同一个内存（可以用const定义之后再当做参数传入map作为属性名。）。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// error</span><br><span class=\"line\">const map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">map.set([&apos;a&apos;], 555);</span><br><span class=\"line\">map.get([&apos;a&apos;]) // undefined</span><br><span class=\"line\"></span><br><span class=\"line\">// success</span><br><span class=\"line\">const map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">const k1 = [&apos;a&apos;];</span><br><span class=\"line\">const k2 = [&apos;a&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">map</span><br><span class=\"line\">.set(k1, 111)</span><br><span class=\"line\">.set(k2, 222);</span><br><span class=\"line\"></span><br><span class=\"line\">map.get(k1) // 111</span><br><span class=\"line\">map.get(k2) // 222</span><br></pre></td></tr></table></figure></p>\n<p><strong>WeakMap与Map的区别：</strong></p>\n<blockquote>\n<p>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。<br>WeakMap的键名所指向的对象，不计入垃圾回收机制。</p>\n</blockquote>\n<p>好吧，暂时先到这儿。另外一部分后面继续整理吧~知识点还是蛮多的。</p>\n"},{"title":"ES6 学习笔记（下）","date":"2018-01-20T16:00:00.000Z","_content":"\n > 认真学习了一遍ES6，发现很多很好用的功能。\n学习资料：[《ECMAScript 6 入门》](http://es6.ruanyifeng.com/#README)\n\n好啦，继续下半部分的学习。\n\n# Proxy\nProxy 用于修改对象的某些操作行为。套用书上的栗子，实现了对象的set、get方法拦截。\n```\nvar obj = new Proxy({}, {\n    get: function (target, key, receiver) {\n        console.log(`getting ${key}!`);\n        return Reflect.get(target, key, receiver);\n    },\n    set: function (target, key, value, receiver) {\n        console.log(`setting ${key}!`);\n        return Reflect.set(target, key, value, receiver);\n    }\n});\n\nobj.count = 1\nobj.name = 'jack'\nobj.count++\n\n// setting count\n// setting name\n// getting count\n// setting count\n```\n**实例方法整理**\n* get 方法拦截属性的读取操作。\n* set 方法拦截赋值操。\n* apply 方法拦截函数的调用。\n* has 方法拦截 `HasProperty` 操作，即查找对象中是否有某属性。可用来隐藏一些属性不被 `in` 运算符发现。\n* construct 方法拦截 `new` 指令。即在 `new` 指令创建实例的时候可以对对象中的参数进行一些初始化修改操作。\n* deleteProperty方法拦截 `delete` 指令，可用来保护某些对象属性无法被删除。\n* defineProperty方法拦截了Object.defineProperty操作。\n* getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined\n* getPrototypeOf方法主要用来拦截获取对象原型。\n* isExtensible方法拦截Object.isExtensible操作。\n* ownKeys方法用来拦截对象自身属性的读取操作。\n* preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。\n* setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。\n\napply方法的使用\n```\nvar target = function () { return 'I am the target'; };\nvar handler = {\n    apply: function () {\n        return 'I am the proxy';\n    }\n};\n\nvar p = new Proxy(target, handler);\n\nconsole.log(p())\n// \"I am the proxy\"\n```\nhas方法的使用\n```\nvar handler = {\n    has (target, key) {\n        if (key[0] === '_') {\n            return false;\n        }\n        return key in target;\n    }\n};\nvar target = { _prop: 'foo', prop: 'foo' };\nvar proxy = new Proxy(target, handler);\nconsole.log('_prop' in proxy)\n// false\n```\nconstruct方法的使用\n```\nvar p = new Proxy(function () {}, {\n    construct: function(target, args) {\n        console.log('called: ' + args.join(', '));\n        return { value: args[0] * 5 + 12 };\n    }\n});\n\nconsole.log(new p(1))\nconsole.log(new p(1).value)\n\n// call: 1\n// { value: 17 }\n// call: 1\n// 17\n```\n所以，我理解的 Proxy 对象主要功能就是拦截对象属性的一些操作。\n\n# Reflect\n我理解的Reflect对象：\n* 是Object的高级版本，Object对对象的操作方法Reflect对象都有，并且未来操作对象的新方法只放在Reflect对象中有。\n* 发生错误不会报错而是返回false，可直接在判断中使用。\n* 让Object操作都变成函数行为，统一表现形式。某些Object操作是命令式，比如 `name in obj` 和 `delete obj[name]` ，而 `Reflect.has(obj, name)` 和 `Reflect.deleteProperty(obj, name)` 让它们变成了函数行为。\n* Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。Proxy对象拦截对象属性方法，进行重新定义。而Reflect对象立即执行对象属性方法。下面例子中使用set和get做演示。\n```\nvar myObject = {\n    foo: 1,\n    bar: 2,\n    get baz() {\n        return this.foo + this.bar;\n    },\n}\n\nconsole.log(Reflect.get(myObject, 'foo')) \nconsole.log(Reflect.get(myObject, 'bar')) \nconsole.log(Reflect.get(myObject, 'baz')) \n\nconsole.log(Reflect.set(myObject, 'foo', 100))\nconsole.log(myObject.foo)\n\n// 1\n// 2\n// 3\n// true\n// 100\n```\n\n# Promise 对象\nPromise 对象登场啦~这是 ES6 语法中非常常用的对象。\n我理解的 Promise 对象：\n* Promise 对象让异步操作的写法从回调函数变为链式操作，可读性更强。\n* Promise 对象一旦改变，就会锁死，不再改变。\n\n**基本用法**\nPromise 的定义，定义一个 Promise对象，参数为resolve和reject，resolve为执行成功的方法，而reject为执行失败的方法。\n```\nconst promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n基本调用方式\n```\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\n**Promise 函数一旦用 new 指令创建，立即执行。并且数据为不可变。**\n```\nlet success = true\nlet name = 'jack'\n\nconst promise = new Promise((resolve, reject) => {\n    console.log('create')\n    if (success) {\n        resolve(name)\n    } else {\n        reject('error promise')\n    }\n})\n\nsuccess = false\nname = 'rose'\nconsole.log('before then')\n\npromise.then(value => {\n    console.log(value)\n}).catch(error => {\n    console.log(error)\n})\n\n// create\n// before then\n// jack\n```\n由此可见，在定义了Promise之后，我们再去修改 `name` 返回的还是定义Promise时候的值。说明了Promise对象定义即执行，并且不可变。\n\n**Promise 推荐使用 `promise.then().catch()`  写法。**\n```\n// bad\npromise.then(value => {\n    console.log(value)\n}, error => {\n    console.log(error)\n})\n\n// good\npromise.then(value => {\n    console.log(value)\n}).catch(error => {\n    console.log(error)\n})\n```\n**then方法链式写法表达，then方法的返回值可以传递给下一个then方法。**\n```\nconst promise = new Promise((resolve, reject) => {\n    resolve('jack')\n})\n\npromise.then(value => {\n    console.log(value)\n    return 'violet' + value\n}).then(value => {\n    console.log(value)\n    return 'welcome to ' + value\n}).then(value => {\n    console.log(value)\n    return  value + ' blog'\n}).then(value => {\n    console.log(value)\n})\n\n// jack\n// violetjack\n// welcome to violetjack\n// welcome to violetjack blog\n```\n**catch方法用于捕获Promise对象的异常行为（可能是 reject 函数返回的错误，也可能是`throw new Error('error')`）。**\n**Promise.all() 方法将多个Promise实例包装成一个Promise实例。如下示例，如果p1、p2、p3都执行成功，则执行then方法，返回的参数为三个实例的参数数组；如果有任意一个Promise实例报错，则在catch方法中返回该实例的错误信息。**\n```\nconst p1 = new Promise((resolve, reject) => {\n    resolve('jack')\n})\n\nconst p2 = new Promise((resolve, reject) => {\n    // resolve('rose')\n    reject('rose error')\n})\n\nconst p3 = new Promise((resolve, reject) => {\n    resolve('james')\n})\n\nPromise.all([p1, p2, p3]).then(values => {\n    console.log(values)\n}).catch(error => {\n    console.log(error)\n})\n\n// [\"jack\", \"rose\", \"james\"]\n// rose error\n```\n**Promise.race() 方法用法与 all 方法一致，唯一不同点就是多个 Promise实例中只作用域最快有反映的Promise实例，并且返回该实例的正确或错误信息。如果多个Promise同时触发，按顺序返回第一个Promise实例。**\n**Promise.resolve() 和 Promise.reject()**\n```\nPromise.resolve('foo')\n// 等价于\nnew Promise(resolve => resolve('foo'))\n\nconst p = Promise.reject('出错了');\n// 等同于\nconst p = new Promise((resolve, reject) => reject('出错了'))\n```\n\n# Iterator 和 for...of 循环\n**默认Iterator接口部署在数据对象的 `Symbol.iterator` 属性中，`Symbol.iterator` 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。只要数据对象有了 `Symbol.iterator` 属性就可以进行遍历。如下对象添加了 `Symbol.iterator`  属性后实现了遍历操作。**\n```\nlet obj = {\n    data: [ 'hello', 'world' ],\n    [Symbol.iterator]() {\n        const self = this;\n        let index = 0;\n        return {\n            next() {\n                if (index < self.data.length) {\n                    return {\n                        value: self.data[index++],\n                        done: false\n                    };\n                } else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n    }\n};\n\nconsole.log([...obj])\n\n// [\"hello\", \"world\"]\n```\n**Iterator 接口主要供for...of消费。**\n**`for...in` 循环读取键名，`for...of` 循环读取键值。**\n```\nconst arr = ['red', 'green', 'blue'];\n\nfor(let v of arr) {\n    console.log(v); // red green blue\n}\nfor(let k in arr){\n    console.log(k) // 0 1 2\n}\n```\n# Generator 函数的语法\n**一种异步解决方案。函数执行返回一个对象，而函数中的数据只有在对象使用 next() 方法才会返回下一个用 `yield` 或者 `return` 定义的数据，否则对象状态就凝固在那里。**\n```\nfunction* helloGenerator() {\n    yield 'hello'\n    yield 'world'\n    return 'generator'\n}\n\nvar h = helloGenerator()\nconsole.log(h.next())\nconsole.log(h.next())\nconsole.log(h.next())\nconsole.log(h.next())\n\n// { value: 'hello', done: false}\n// { value: 'world', done: false}\n// { value: 'generator', done: true}\n// { value: undefined, done: true}\n```\n**next() 方法传值—— `next()` 方法返回的是 `yield` 表达式的计算结果。如果 `next(value)` 方法中传入value参数，则参数将替换上一个 `yield` 数据。如下示例中，`12` 替换了`(yield (x + 1))`，`13` 替换了`yield (y / 3)`，最后得到结果为42。**\n```\nfunction* foo(x) {\n  var y = 2 * (yield (x + 1));\n  // value  = 5 + 1\n  var z = yield (y / 3);\n  // y = 2 * 12 value = 24 / 3\n  return (x + y + z);\n  // z = 13 y = 24 z = 13 value = 5 + 24 + 13\n}\n\nvar a = foo(5);\na.next() // Object{value:6, done:false}\n// 如果不传递数据，则y=NaN\na.next() // Object{value:NaN, done:false}\na.next() // Object{value:NaN, done:true}\n\nvar b = foo(5);\n\nb.next() // { value:6, done:false }\nb.next(12) // { value:8, done:false }\nb.next(13) // { value:42, done:true }\n```\n**throw方法用于捕捉错误，return方法类似于 Genterator 函数的 `return xxx` 返回某个值，随后再使用next方法返回的都是 `undefined`**\n**对于 next、throw、return，引用书上的解释更清晰点。**\n> `next()` 是将 `yield` 表达式替换成一个值。\n`throw()` 是将 `yield` 表达式替换成一个 `throw` 语句。\n`return()` 是将 `yield` 表达式替换成一个 `return` 语句。\n\n`yield*` **用于将其他 Generator 函数合并到当前函数中，用法如下：**\n```\nfunction* bar() {\n    yield 'a'\n    yield 'b'\n}\n\nfunction* foo() {\n    yield 'x'\n    yield* bar()\n    yield 'y'\n}\n\nfor (let v of foo()){\n    console.log(v)\n}\n\n// x\n// a\n// b\n// y\n```\n**Generator 函数不能直接用 new 指令实例化对象，需要包装为普通函数再 new**\n```\nfunction* gen() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\n\nfunction F() {\n  return gen.call(gen.prototype);\n}\n\nvar f = new F();\n\nf.next();  // Object {value: 2, done: false}\nf.next();  // Object {value: 3, done: false}\nf.next();  // Object {value: undefined, done: true}\n\nf.a // 1\nf.b // 2\nf.c // 3\n```\n**自动执行所有Generator函数的方法：**\n```\nfunction run(fn) {\n  var gen = fn();\n\n  function next(err, data) {\n    var result = gen.next(data);\n    if (result.done) return;\n    result.value(next);\n  }\n\n  next();\n}\n\nfunction* g() {\n  // ...\n}\n\nrun(g);\n```\n**以上自动执行器还可以使用 `co` 模块来实现。**\n# async 函数\nasync函数用于处理异步操作，它是对Generator函数的改进。它相比于Generator有以下几个优点：\n* 内置执行器：相比于Generator 要自定义或者用 co 模块来实现自动执行器效果，async函数自带自动执行器。\n* 更好的语义：async 和 await，比起 * 和 yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n* 更广的适用性：co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n* 返回Promise：async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。\n\n我个人对async的感觉是写法方便、代码理解简单、代码写法也符合逻辑、操作异步行为方便。\n下面写了 Generator 函数和 async 函数实现异步的代码的对比。\n```\nconst readFile = function (fileName) {\n    return new Promise(function (resolve, reject) {\n        setTimeout(() => {\n            console.log(`reading ${fileName}`)\n            resolve(fileName)\n        }, 1000)\n    });\n};\n\n// Generator 写法\nconst gen = function* () {\n    const f1 = yield readFile('/etc/fstab');\n    const f2 = yield readFile('/etc/shells');\n    console.log(f1.toString());\n    console.log(f2.toString());\n};\n\nvar g = gen()\ng.next().value.then(value => {\n    g.next(value).value.then(value => {\n        g.next(value)\n    })\n})\n\n// async 写法\nasync function gan() {\n    const f1 = await readFile('/etc/fstab');\n    const f2 = await readFile('/etc/shells');\n    console.log(f1.toString());\n    console.log(f2.toString());\n}\n\ngan()\n```\n两种函数的实现结果是一样的。\n但从上面的例子中可以看出，Generator 函数需要不断调用next方法，并且将上一个next方法的结果传递给当前next方法当做参数。而async函数直接调用函数本身就会自动往下执行。Generator多了一步执行的过程。\n另外，async await的语义很清晰，就算没学过ES6的大致都能看懂是什么意思啦~\n\n# Class\nclass其实就是一个函数实例化的语法糖~具体功能也类似Java这类有Class的语言~\n所以，下面两种写法的结果是相等的。\n**传统写法**\n```\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nPoint.prototype.toString = function () {\n    return '(' + this.x + ', ' + this.y + ')';\n};\n\nvar p = new Point(1, 2);\nconsole.log(p)\n```\n**ES6 Class写法**\n```\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    toString() {\n        return '(' + this.x + ', ' + this.y + ')';\n    }\n}\n\nvar p = new Point(1, 2);\nconsole.log(p)\n```\n![结果](http://upload-images.jianshu.io/upload_images/1987062-3f972d9e15d96308.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n对象结果如上图所示，构造函数中this对象的属性在实例中，而Class里面的函数再实例对象的 `__proto__` 中。\n**使用 `new target` 在构造函数中判断对象是否为 `new` 指令创建的。**\n```\n// 另一种写法\nfunction Person(name) {\n  if (new.target === Person) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用 new 命令生成实例');\n  }\n}\n\nvar person = new Person('张三'); // 正确\nvar notAPerson = Person.call(person, '张三');  // 报错\n```\n# 修饰器\n类似于Java的修饰器 `@Override` ， 现有一个提案，将修饰器加入到 ECMAScript 中。\n\n# Module\n在 ES6 中添加了模块化功能，很常见用法也很简单。\n**模块加载**\n```\nimport { stat, exists, readFile } from 'fs'; // 多个模块加载\nimport { lastName as surname } from './profile.js'; // 模块加载重命名\nimport * as circle from './circle'; // 整理加载\n```\n**模块输出**\n```\n// 输出变量\nexport let a = 100\n// 输出方法\nexport function hello() {\n    console.log('hello world')\n}\n// 输出多个变量\nconst b = 200\nconst c = 300\nconst d = 400\nexport {b, c, d}\n// 输出变量重命名\nexport {b as value}\n// 输出默认值\nexport default function () {\n    console.log('hello default')\n}\n```\n**`CommonJS` 语法中模块输出和加载的写法**\n```\nlet { stat, exists, readFile } = require('fs');\n\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n```\n# ArrayBuffer\nArrayBuffer对象、TypedArray视图和DataView视图是 JavaScript 操作二进制数据的一个接口。\n\n> **二进制数组由三类对象组成。**\n（1）ArrayBuffer对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。\n（2）TypedArray视图：共包括 9 种类型的视图，比如Uint8Array（无符号 8 位整数）数组视图, Int16Array（16 位整数）数组视图, Float32Array（32 位浮点数）数组视图等等。\n（3）DataView视图：可以自定义复合格式的视图，比如第一个字节是 Uint8（无符号 8 位整数）、第二、三个字节是 Int16（16 位整数）、第四个字节开始是 Float32（32 位浮点数）等等，此外还可以自定义字节序。\n简单说，ArrayBuffer对象代表原始的二进制数据，TypedArray 视图用来读写简单类型的二进制数据，DataView视图用来读写复杂类型的二进制数据。\n\n这方面知识点不太常用，了解下，等到用的时候查查就是了。\n\n# 其他\n* [编程风格](http://es6.ruanyifeng.com/#docs/style) —— 主要参考了 [Airbnb](https://github.com/airbnb/javascript) 公司的 JavaScript 风格规范。\n* [读懂 ECMAScript 规格](http://es6.ruanyifeng.com/#docs/spec) —— 对于规格的学习建议，阮一峰老师的建议如下：\n> 规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。\n一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。\n\n# 最后\n好啦~终于把下半部分写完了。有点虎头蛇尾，一开始写的东西很具体，到后来内容有点少。主要是因为前面部分我觉得是比较麻烦和常用的。写这篇博客主要是系统复习下ES6语法，简略地提一下各个语法的用法、注意点。大致知道了有些什么，以后遇到问题知道如何查资料如何解决就好了。\n感觉自己写博客速度忒慢了，写ES6笔记断断续续花了我十个小时……\n最后呢，还是那句话——**由自己整理写出博客的知识点才是真正牢牢掌握的知识点！**至此，我对ES6语法的理解加深了很多。看到此文的你可以去试试用写博客的方式来复习知识点哦~\n希望我写的东西能帮助到一些朋友。\n\n# 关于我\nVioletJack，内驱工程师~专注于Vue前端相关的知识点整理、源码学习、内容分享。欢迎喜欢我文章的朋友关注我哦，我会努力产出优质内容~让我们始终相信：code change world!","source":"_posts/ES6 学习笔记（下）.md","raw":"---\ntitle: ES6 学习笔记（下）\ndate: 2018-01-21\n---\n\n > 认真学习了一遍ES6，发现很多很好用的功能。\n学习资料：[《ECMAScript 6 入门》](http://es6.ruanyifeng.com/#README)\n\n好啦，继续下半部分的学习。\n\n# Proxy\nProxy 用于修改对象的某些操作行为。套用书上的栗子，实现了对象的set、get方法拦截。\n```\nvar obj = new Proxy({}, {\n    get: function (target, key, receiver) {\n        console.log(`getting ${key}!`);\n        return Reflect.get(target, key, receiver);\n    },\n    set: function (target, key, value, receiver) {\n        console.log(`setting ${key}!`);\n        return Reflect.set(target, key, value, receiver);\n    }\n});\n\nobj.count = 1\nobj.name = 'jack'\nobj.count++\n\n// setting count\n// setting name\n// getting count\n// setting count\n```\n**实例方法整理**\n* get 方法拦截属性的读取操作。\n* set 方法拦截赋值操。\n* apply 方法拦截函数的调用。\n* has 方法拦截 `HasProperty` 操作，即查找对象中是否有某属性。可用来隐藏一些属性不被 `in` 运算符发现。\n* construct 方法拦截 `new` 指令。即在 `new` 指令创建实例的时候可以对对象中的参数进行一些初始化修改操作。\n* deleteProperty方法拦截 `delete` 指令，可用来保护某些对象属性无法被删除。\n* defineProperty方法拦截了Object.defineProperty操作。\n* getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined\n* getPrototypeOf方法主要用来拦截获取对象原型。\n* isExtensible方法拦截Object.isExtensible操作。\n* ownKeys方法用来拦截对象自身属性的读取操作。\n* preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。\n* setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。\n\napply方法的使用\n```\nvar target = function () { return 'I am the target'; };\nvar handler = {\n    apply: function () {\n        return 'I am the proxy';\n    }\n};\n\nvar p = new Proxy(target, handler);\n\nconsole.log(p())\n// \"I am the proxy\"\n```\nhas方法的使用\n```\nvar handler = {\n    has (target, key) {\n        if (key[0] === '_') {\n            return false;\n        }\n        return key in target;\n    }\n};\nvar target = { _prop: 'foo', prop: 'foo' };\nvar proxy = new Proxy(target, handler);\nconsole.log('_prop' in proxy)\n// false\n```\nconstruct方法的使用\n```\nvar p = new Proxy(function () {}, {\n    construct: function(target, args) {\n        console.log('called: ' + args.join(', '));\n        return { value: args[0] * 5 + 12 };\n    }\n});\n\nconsole.log(new p(1))\nconsole.log(new p(1).value)\n\n// call: 1\n// { value: 17 }\n// call: 1\n// 17\n```\n所以，我理解的 Proxy 对象主要功能就是拦截对象属性的一些操作。\n\n# Reflect\n我理解的Reflect对象：\n* 是Object的高级版本，Object对对象的操作方法Reflect对象都有，并且未来操作对象的新方法只放在Reflect对象中有。\n* 发生错误不会报错而是返回false，可直接在判断中使用。\n* 让Object操作都变成函数行为，统一表现形式。某些Object操作是命令式，比如 `name in obj` 和 `delete obj[name]` ，而 `Reflect.has(obj, name)` 和 `Reflect.deleteProperty(obj, name)` 让它们变成了函数行为。\n* Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。Proxy对象拦截对象属性方法，进行重新定义。而Reflect对象立即执行对象属性方法。下面例子中使用set和get做演示。\n```\nvar myObject = {\n    foo: 1,\n    bar: 2,\n    get baz() {\n        return this.foo + this.bar;\n    },\n}\n\nconsole.log(Reflect.get(myObject, 'foo')) \nconsole.log(Reflect.get(myObject, 'bar')) \nconsole.log(Reflect.get(myObject, 'baz')) \n\nconsole.log(Reflect.set(myObject, 'foo', 100))\nconsole.log(myObject.foo)\n\n// 1\n// 2\n// 3\n// true\n// 100\n```\n\n# Promise 对象\nPromise 对象登场啦~这是 ES6 语法中非常常用的对象。\n我理解的 Promise 对象：\n* Promise 对象让异步操作的写法从回调函数变为链式操作，可读性更强。\n* Promise 对象一旦改变，就会锁死，不再改变。\n\n**基本用法**\nPromise 的定义，定义一个 Promise对象，参数为resolve和reject，resolve为执行成功的方法，而reject为执行失败的方法。\n```\nconst promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n基本调用方式\n```\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\n**Promise 函数一旦用 new 指令创建，立即执行。并且数据为不可变。**\n```\nlet success = true\nlet name = 'jack'\n\nconst promise = new Promise((resolve, reject) => {\n    console.log('create')\n    if (success) {\n        resolve(name)\n    } else {\n        reject('error promise')\n    }\n})\n\nsuccess = false\nname = 'rose'\nconsole.log('before then')\n\npromise.then(value => {\n    console.log(value)\n}).catch(error => {\n    console.log(error)\n})\n\n// create\n// before then\n// jack\n```\n由此可见，在定义了Promise之后，我们再去修改 `name` 返回的还是定义Promise时候的值。说明了Promise对象定义即执行，并且不可变。\n\n**Promise 推荐使用 `promise.then().catch()`  写法。**\n```\n// bad\npromise.then(value => {\n    console.log(value)\n}, error => {\n    console.log(error)\n})\n\n// good\npromise.then(value => {\n    console.log(value)\n}).catch(error => {\n    console.log(error)\n})\n```\n**then方法链式写法表达，then方法的返回值可以传递给下一个then方法。**\n```\nconst promise = new Promise((resolve, reject) => {\n    resolve('jack')\n})\n\npromise.then(value => {\n    console.log(value)\n    return 'violet' + value\n}).then(value => {\n    console.log(value)\n    return 'welcome to ' + value\n}).then(value => {\n    console.log(value)\n    return  value + ' blog'\n}).then(value => {\n    console.log(value)\n})\n\n// jack\n// violetjack\n// welcome to violetjack\n// welcome to violetjack blog\n```\n**catch方法用于捕获Promise对象的异常行为（可能是 reject 函数返回的错误，也可能是`throw new Error('error')`）。**\n**Promise.all() 方法将多个Promise实例包装成一个Promise实例。如下示例，如果p1、p2、p3都执行成功，则执行then方法，返回的参数为三个实例的参数数组；如果有任意一个Promise实例报错，则在catch方法中返回该实例的错误信息。**\n```\nconst p1 = new Promise((resolve, reject) => {\n    resolve('jack')\n})\n\nconst p2 = new Promise((resolve, reject) => {\n    // resolve('rose')\n    reject('rose error')\n})\n\nconst p3 = new Promise((resolve, reject) => {\n    resolve('james')\n})\n\nPromise.all([p1, p2, p3]).then(values => {\n    console.log(values)\n}).catch(error => {\n    console.log(error)\n})\n\n// [\"jack\", \"rose\", \"james\"]\n// rose error\n```\n**Promise.race() 方法用法与 all 方法一致，唯一不同点就是多个 Promise实例中只作用域最快有反映的Promise实例，并且返回该实例的正确或错误信息。如果多个Promise同时触发，按顺序返回第一个Promise实例。**\n**Promise.resolve() 和 Promise.reject()**\n```\nPromise.resolve('foo')\n// 等价于\nnew Promise(resolve => resolve('foo'))\n\nconst p = Promise.reject('出错了');\n// 等同于\nconst p = new Promise((resolve, reject) => reject('出错了'))\n```\n\n# Iterator 和 for...of 循环\n**默认Iterator接口部署在数据对象的 `Symbol.iterator` 属性中，`Symbol.iterator` 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。只要数据对象有了 `Symbol.iterator` 属性就可以进行遍历。如下对象添加了 `Symbol.iterator`  属性后实现了遍历操作。**\n```\nlet obj = {\n    data: [ 'hello', 'world' ],\n    [Symbol.iterator]() {\n        const self = this;\n        let index = 0;\n        return {\n            next() {\n                if (index < self.data.length) {\n                    return {\n                        value: self.data[index++],\n                        done: false\n                    };\n                } else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n    }\n};\n\nconsole.log([...obj])\n\n// [\"hello\", \"world\"]\n```\n**Iterator 接口主要供for...of消费。**\n**`for...in` 循环读取键名，`for...of` 循环读取键值。**\n```\nconst arr = ['red', 'green', 'blue'];\n\nfor(let v of arr) {\n    console.log(v); // red green blue\n}\nfor(let k in arr){\n    console.log(k) // 0 1 2\n}\n```\n# Generator 函数的语法\n**一种异步解决方案。函数执行返回一个对象，而函数中的数据只有在对象使用 next() 方法才会返回下一个用 `yield` 或者 `return` 定义的数据，否则对象状态就凝固在那里。**\n```\nfunction* helloGenerator() {\n    yield 'hello'\n    yield 'world'\n    return 'generator'\n}\n\nvar h = helloGenerator()\nconsole.log(h.next())\nconsole.log(h.next())\nconsole.log(h.next())\nconsole.log(h.next())\n\n// { value: 'hello', done: false}\n// { value: 'world', done: false}\n// { value: 'generator', done: true}\n// { value: undefined, done: true}\n```\n**next() 方法传值—— `next()` 方法返回的是 `yield` 表达式的计算结果。如果 `next(value)` 方法中传入value参数，则参数将替换上一个 `yield` 数据。如下示例中，`12` 替换了`(yield (x + 1))`，`13` 替换了`yield (y / 3)`，最后得到结果为42。**\n```\nfunction* foo(x) {\n  var y = 2 * (yield (x + 1));\n  // value  = 5 + 1\n  var z = yield (y / 3);\n  // y = 2 * 12 value = 24 / 3\n  return (x + y + z);\n  // z = 13 y = 24 z = 13 value = 5 + 24 + 13\n}\n\nvar a = foo(5);\na.next() // Object{value:6, done:false}\n// 如果不传递数据，则y=NaN\na.next() // Object{value:NaN, done:false}\na.next() // Object{value:NaN, done:true}\n\nvar b = foo(5);\n\nb.next() // { value:6, done:false }\nb.next(12) // { value:8, done:false }\nb.next(13) // { value:42, done:true }\n```\n**throw方法用于捕捉错误，return方法类似于 Genterator 函数的 `return xxx` 返回某个值，随后再使用next方法返回的都是 `undefined`**\n**对于 next、throw、return，引用书上的解释更清晰点。**\n> `next()` 是将 `yield` 表达式替换成一个值。\n`throw()` 是将 `yield` 表达式替换成一个 `throw` 语句。\n`return()` 是将 `yield` 表达式替换成一个 `return` 语句。\n\n`yield*` **用于将其他 Generator 函数合并到当前函数中，用法如下：**\n```\nfunction* bar() {\n    yield 'a'\n    yield 'b'\n}\n\nfunction* foo() {\n    yield 'x'\n    yield* bar()\n    yield 'y'\n}\n\nfor (let v of foo()){\n    console.log(v)\n}\n\n// x\n// a\n// b\n// y\n```\n**Generator 函数不能直接用 new 指令实例化对象，需要包装为普通函数再 new**\n```\nfunction* gen() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\n\nfunction F() {\n  return gen.call(gen.prototype);\n}\n\nvar f = new F();\n\nf.next();  // Object {value: 2, done: false}\nf.next();  // Object {value: 3, done: false}\nf.next();  // Object {value: undefined, done: true}\n\nf.a // 1\nf.b // 2\nf.c // 3\n```\n**自动执行所有Generator函数的方法：**\n```\nfunction run(fn) {\n  var gen = fn();\n\n  function next(err, data) {\n    var result = gen.next(data);\n    if (result.done) return;\n    result.value(next);\n  }\n\n  next();\n}\n\nfunction* g() {\n  // ...\n}\n\nrun(g);\n```\n**以上自动执行器还可以使用 `co` 模块来实现。**\n# async 函数\nasync函数用于处理异步操作，它是对Generator函数的改进。它相比于Generator有以下几个优点：\n* 内置执行器：相比于Generator 要自定义或者用 co 模块来实现自动执行器效果，async函数自带自动执行器。\n* 更好的语义：async 和 await，比起 * 和 yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n* 更广的适用性：co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n* 返回Promise：async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。\n\n我个人对async的感觉是写法方便、代码理解简单、代码写法也符合逻辑、操作异步行为方便。\n下面写了 Generator 函数和 async 函数实现异步的代码的对比。\n```\nconst readFile = function (fileName) {\n    return new Promise(function (resolve, reject) {\n        setTimeout(() => {\n            console.log(`reading ${fileName}`)\n            resolve(fileName)\n        }, 1000)\n    });\n};\n\n// Generator 写法\nconst gen = function* () {\n    const f1 = yield readFile('/etc/fstab');\n    const f2 = yield readFile('/etc/shells');\n    console.log(f1.toString());\n    console.log(f2.toString());\n};\n\nvar g = gen()\ng.next().value.then(value => {\n    g.next(value).value.then(value => {\n        g.next(value)\n    })\n})\n\n// async 写法\nasync function gan() {\n    const f1 = await readFile('/etc/fstab');\n    const f2 = await readFile('/etc/shells');\n    console.log(f1.toString());\n    console.log(f2.toString());\n}\n\ngan()\n```\n两种函数的实现结果是一样的。\n但从上面的例子中可以看出，Generator 函数需要不断调用next方法，并且将上一个next方法的结果传递给当前next方法当做参数。而async函数直接调用函数本身就会自动往下执行。Generator多了一步执行的过程。\n另外，async await的语义很清晰，就算没学过ES6的大致都能看懂是什么意思啦~\n\n# Class\nclass其实就是一个函数实例化的语法糖~具体功能也类似Java这类有Class的语言~\n所以，下面两种写法的结果是相等的。\n**传统写法**\n```\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nPoint.prototype.toString = function () {\n    return '(' + this.x + ', ' + this.y + ')';\n};\n\nvar p = new Point(1, 2);\nconsole.log(p)\n```\n**ES6 Class写法**\n```\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    toString() {\n        return '(' + this.x + ', ' + this.y + ')';\n    }\n}\n\nvar p = new Point(1, 2);\nconsole.log(p)\n```\n![结果](http://upload-images.jianshu.io/upload_images/1987062-3f972d9e15d96308.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n对象结果如上图所示，构造函数中this对象的属性在实例中，而Class里面的函数再实例对象的 `__proto__` 中。\n**使用 `new target` 在构造函数中判断对象是否为 `new` 指令创建的。**\n```\n// 另一种写法\nfunction Person(name) {\n  if (new.target === Person) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用 new 命令生成实例');\n  }\n}\n\nvar person = new Person('张三'); // 正确\nvar notAPerson = Person.call(person, '张三');  // 报错\n```\n# 修饰器\n类似于Java的修饰器 `@Override` ， 现有一个提案，将修饰器加入到 ECMAScript 中。\n\n# Module\n在 ES6 中添加了模块化功能，很常见用法也很简单。\n**模块加载**\n```\nimport { stat, exists, readFile } from 'fs'; // 多个模块加载\nimport { lastName as surname } from './profile.js'; // 模块加载重命名\nimport * as circle from './circle'; // 整理加载\n```\n**模块输出**\n```\n// 输出变量\nexport let a = 100\n// 输出方法\nexport function hello() {\n    console.log('hello world')\n}\n// 输出多个变量\nconst b = 200\nconst c = 300\nconst d = 400\nexport {b, c, d}\n// 输出变量重命名\nexport {b as value}\n// 输出默认值\nexport default function () {\n    console.log('hello default')\n}\n```\n**`CommonJS` 语法中模块输出和加载的写法**\n```\nlet { stat, exists, readFile } = require('fs');\n\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n```\n# ArrayBuffer\nArrayBuffer对象、TypedArray视图和DataView视图是 JavaScript 操作二进制数据的一个接口。\n\n> **二进制数组由三类对象组成。**\n（1）ArrayBuffer对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。\n（2）TypedArray视图：共包括 9 种类型的视图，比如Uint8Array（无符号 8 位整数）数组视图, Int16Array（16 位整数）数组视图, Float32Array（32 位浮点数）数组视图等等。\n（3）DataView视图：可以自定义复合格式的视图，比如第一个字节是 Uint8（无符号 8 位整数）、第二、三个字节是 Int16（16 位整数）、第四个字节开始是 Float32（32 位浮点数）等等，此外还可以自定义字节序。\n简单说，ArrayBuffer对象代表原始的二进制数据，TypedArray 视图用来读写简单类型的二进制数据，DataView视图用来读写复杂类型的二进制数据。\n\n这方面知识点不太常用，了解下，等到用的时候查查就是了。\n\n# 其他\n* [编程风格](http://es6.ruanyifeng.com/#docs/style) —— 主要参考了 [Airbnb](https://github.com/airbnb/javascript) 公司的 JavaScript 风格规范。\n* [读懂 ECMAScript 规格](http://es6.ruanyifeng.com/#docs/spec) —— 对于规格的学习建议，阮一峰老师的建议如下：\n> 规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。\n一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。\n\n# 最后\n好啦~终于把下半部分写完了。有点虎头蛇尾，一开始写的东西很具体，到后来内容有点少。主要是因为前面部分我觉得是比较麻烦和常用的。写这篇博客主要是系统复习下ES6语法，简略地提一下各个语法的用法、注意点。大致知道了有些什么，以后遇到问题知道如何查资料如何解决就好了。\n感觉自己写博客速度忒慢了，写ES6笔记断断续续花了我十个小时……\n最后呢，还是那句话——**由自己整理写出博客的知识点才是真正牢牢掌握的知识点！**至此，我对ES6语法的理解加深了很多。看到此文的你可以去试试用写博客的方式来复习知识点哦~\n希望我写的东西能帮助到一些朋友。\n\n# 关于我\nVioletJack，内驱工程师~专注于Vue前端相关的知识点整理、源码学习、内容分享。欢迎喜欢我文章的朋友关注我哦，我会努力产出优质内容~让我们始终相信：code change world!","slug":"ES6 学习笔记（下）","published":1,"updated":"2018-02-07T02:27:11.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjddwxbm10002i8btx6c2ce33","content":"<blockquote>\n<p>认真学习了一遍ES6，发现很多很好用的功能。<br>学习资料：<a href=\"http://es6.ruanyifeng.com/#README\" target=\"_blank\" rel=\"noopener\">《ECMAScript 6 入门》</a></p>\n</blockquote>\n<p>好啦，继续下半部分的学习。</p>\n<h1 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h1><p>Proxy 用于修改对象的某些操作行为。套用书上的栗子，实现了对象的set、get方法拦截。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = new Proxy(&#123;&#125;, &#123;</span><br><span class=\"line\">    get: function (target, key, receiver) &#123;</span><br><span class=\"line\">        console.log(`getting $&#123;key&#125;!`);</span><br><span class=\"line\">        return Reflect.get(target, key, receiver);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: function (target, key, value, receiver) &#123;</span><br><span class=\"line\">        console.log(`setting $&#123;key&#125;!`);</span><br><span class=\"line\">        return Reflect.set(target, key, value, receiver);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">obj.count = 1</span><br><span class=\"line\">obj.name = &apos;jack&apos;</span><br><span class=\"line\">obj.count++</span><br><span class=\"line\"></span><br><span class=\"line\">// setting count</span><br><span class=\"line\">// setting name</span><br><span class=\"line\">// getting count</span><br><span class=\"line\">// setting count</span><br></pre></td></tr></table></figure></p>\n<p><strong>实例方法整理</strong></p>\n<ul>\n<li>get 方法拦截属性的读取操作。</li>\n<li>set 方法拦截赋值操。</li>\n<li>apply 方法拦截函数的调用。</li>\n<li>has 方法拦截 <code>HasProperty</code> 操作，即查找对象中是否有某属性。可用来隐藏一些属性不被 <code>in</code> 运算符发现。</li>\n<li>construct 方法拦截 <code>new</code> 指令。即在 <code>new</code> 指令创建实例的时候可以对对象中的参数进行一些初始化修改操作。</li>\n<li>deleteProperty方法拦截 <code>delete</code> 指令，可用来保护某些对象属性无法被删除。</li>\n<li>defineProperty方法拦截了Object.defineProperty操作。</li>\n<li>getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined</li>\n<li>getPrototypeOf方法主要用来拦截获取对象原型。</li>\n<li>isExtensible方法拦截Object.isExtensible操作。</li>\n<li>ownKeys方法用来拦截对象自身属性的读取操作。</li>\n<li>preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。</li>\n<li>setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。</li>\n</ul>\n<p>apply方法的使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var target = function () &#123; return &apos;I am the target&apos;; &#125;;</span><br><span class=\"line\">var handler = &#123;</span><br><span class=\"line\">    apply: function () &#123;</span><br><span class=\"line\">        return &apos;I am the proxy&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var p = new Proxy(target, handler);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(p())</span><br><span class=\"line\">// &quot;I am the proxy&quot;</span><br></pre></td></tr></table></figure></p>\n<p>has方法的使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var handler = &#123;</span><br><span class=\"line\">    has (target, key) &#123;</span><br><span class=\"line\">        if (key[0] === &apos;_&apos;) &#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return key in target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var target = &#123; _prop: &apos;foo&apos;, prop: &apos;foo&apos; &#125;;</span><br><span class=\"line\">var proxy = new Proxy(target, handler);</span><br><span class=\"line\">console.log(&apos;_prop&apos; in proxy)</span><br><span class=\"line\">// false</span><br></pre></td></tr></table></figure></p>\n<p>construct方法的使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p = new Proxy(function () &#123;&#125;, &#123;</span><br><span class=\"line\">    construct: function(target, args) &#123;</span><br><span class=\"line\">        console.log(&apos;called: &apos; + args.join(&apos;, &apos;));</span><br><span class=\"line\">        return &#123; value: args[0] * 5 + 12 &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(new p(1))</span><br><span class=\"line\">console.log(new p(1).value)</span><br><span class=\"line\"></span><br><span class=\"line\">// call: 1</span><br><span class=\"line\">// &#123; value: 17 &#125;</span><br><span class=\"line\">// call: 1</span><br><span class=\"line\">// 17</span><br></pre></td></tr></table></figure></p>\n<p>所以，我理解的 Proxy 对象主要功能就是拦截对象属性的一些操作。</p>\n<h1 id=\"Reflect\"><a href=\"#Reflect\" class=\"headerlink\" title=\"Reflect\"></a>Reflect</h1><p>我理解的Reflect对象：</p>\n<ul>\n<li>是Object的高级版本，Object对对象的操作方法Reflect对象都有，并且未来操作对象的新方法只放在Reflect对象中有。</li>\n<li>发生错误不会报错而是返回false，可直接在判断中使用。</li>\n<li>让Object操作都变成函数行为，统一表现形式。某些Object操作是命令式，比如 <code>name in obj</code> 和 <code>delete obj[name]</code> ，而 <code>Reflect.has(obj, name)</code> 和 <code>Reflect.deleteProperty(obj, name)</code> 让它们变成了函数行为。</li>\n<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。Proxy对象拦截对象属性方法，进行重新定义。而Reflect对象立即执行对象属性方法。下面例子中使用set和get做演示。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myObject = &#123;</span><br><span class=\"line\">    foo: 1,</span><br><span class=\"line\">    bar: 2,</span><br><span class=\"line\">    get baz() &#123;</span><br><span class=\"line\">        return this.foo + this.bar;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Reflect.get(myObject, &apos;foo&apos;)) </span><br><span class=\"line\">console.log(Reflect.get(myObject, &apos;bar&apos;)) </span><br><span class=\"line\">console.log(Reflect.get(myObject, &apos;baz&apos;)) </span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Reflect.set(myObject, &apos;foo&apos;, 100))</span><br><span class=\"line\">console.log(myObject.foo)</span><br><span class=\"line\"></span><br><span class=\"line\">// 1</span><br><span class=\"line\">// 2</span><br><span class=\"line\">// 3</span><br><span class=\"line\">// true</span><br><span class=\"line\">// 100</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"Promise-对象\"><a href=\"#Promise-对象\" class=\"headerlink\" title=\"Promise 对象\"></a>Promise 对象</h1><p>Promise 对象登场啦~这是 ES6 语法中非常常用的对象。<br>我理解的 Promise 对象：</p>\n<ul>\n<li>Promise 对象让异步操作的写法从回调函数变为链式操作，可读性更强。</li>\n<li>Promise 对象一旦改变，就会锁死，不再改变。</li>\n</ul>\n<p><strong>基本用法</strong><br>Promise 的定义，定义一个 Promise对象，参数为resolve和reject，resolve为执行成功的方法，而reject为执行失败的方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">  // ... some code</span><br><span class=\"line\"></span><br><span class=\"line\">  if (/* 异步操作成功 */)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>基本调用方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(function(value) &#123;</span><br><span class=\"line\">  // success</span><br><span class=\"line\">&#125;, function(error) &#123;</span><br><span class=\"line\">  // failure</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><strong>Promise 函数一旦用 new 指令创建，立即执行。并且数据为不可变。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let success = true</span><br><span class=\"line\">let name = &apos;jack&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;create&apos;)</span><br><span class=\"line\">    if (success) &#123;</span><br><span class=\"line\">        resolve(name)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        reject(&apos;error promise&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">success = false</span><br><span class=\"line\">name = &apos;rose&apos;</span><br><span class=\"line\">console.log(&apos;before then&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(value =&gt; &#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">&#125;).catch(error =&gt; &#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// create</span><br><span class=\"line\">// before then</span><br><span class=\"line\">// jack</span><br></pre></td></tr></table></figure></p>\n<p>由此可见，在定义了Promise之后，我们再去修改 <code>name</code> 返回的还是定义Promise时候的值。说明了Promise对象定义即执行，并且不可变。</p>\n<p><strong>Promise 推荐使用 <code>promise.then().catch()</code>  写法。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">promise.then(value =&gt; &#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">&#125;, error =&gt; &#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">promise.then(value =&gt; &#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">&#125;).catch(error =&gt; &#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>then方法链式写法表达，then方法的返回值可以传递给下一个then方法。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    resolve(&apos;jack&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(value =&gt; &#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">    return &apos;violet&apos; + value</span><br><span class=\"line\">&#125;).then(value =&gt; &#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">    return &apos;welcome to &apos; + value</span><br><span class=\"line\">&#125;).then(value =&gt; &#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">    return  value + &apos; blog&apos;</span><br><span class=\"line\">&#125;).then(value =&gt; &#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// jack</span><br><span class=\"line\">// violetjack</span><br><span class=\"line\">// welcome to violetjack</span><br><span class=\"line\">// welcome to violetjack blog</span><br></pre></td></tr></table></figure></p>\n<p><strong>catch方法用于捕获Promise对象的异常行为（可能是 reject 函数返回的错误，也可能是<code>throw new Error(&#39;error&#39;)</code>）。</strong><br><strong>Promise.all() 方法将多个Promise实例包装成一个Promise实例。如下示例，如果p1、p2、p3都执行成功，则执行then方法，返回的参数为三个实例的参数数组；如果有任意一个Promise实例报错，则在catch方法中返回该实例的错误信息。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    resolve(&apos;jack&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    // resolve(&apos;rose&apos;)</span><br><span class=\"line\">    reject(&apos;rose error&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">const p3 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    resolve(&apos;james&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([p1, p2, p3]).then(values =&gt; &#123;</span><br><span class=\"line\">    console.log(values)</span><br><span class=\"line\">&#125;).catch(error =&gt; &#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// [&quot;jack&quot;, &quot;rose&quot;, &quot;james&quot;]</span><br><span class=\"line\">// rose error</span><br></pre></td></tr></table></figure></p>\n<p><strong>Promise.race() 方法用法与 all 方法一致，唯一不同点就是多个 Promise实例中只作用域最快有反映的Promise实例，并且返回该实例的正确或错误信息。如果多个Promise同时触发，按顺序返回第一个Promise实例。</strong><br><strong>Promise.resolve() 和 Promise.reject()</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.resolve(&apos;foo&apos;)</span><br><span class=\"line\">// 等价于</span><br><span class=\"line\">new Promise(resolve =&gt; resolve(&apos;foo&apos;))</span><br><span class=\"line\"></span><br><span class=\"line\">const p = Promise.reject(&apos;出错了&apos;);</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">const p = new Promise((resolve, reject) =&gt; reject(&apos;出错了&apos;))</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Iterator-和-for…of-循环\"><a href=\"#Iterator-和-for…of-循环\" class=\"headerlink\" title=\"Iterator 和 for…of 循环\"></a>Iterator 和 for…of 循环</h1><p><strong>默认Iterator接口部署在数据对象的 <code>Symbol.iterator</code> 属性中，<code>Symbol.iterator</code> 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。只要数据对象有了 <code>Symbol.iterator</code> 属性就可以进行遍历。如下对象添加了 <code>Symbol.iterator</code>  属性后实现了遍历操作。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    data: [ &apos;hello&apos;, &apos;world&apos; ],</span><br><span class=\"line\">    [Symbol.iterator]() &#123;</span><br><span class=\"line\">        const self = this;</span><br><span class=\"line\">        let index = 0;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            next() &#123;</span><br><span class=\"line\">                if (index &lt; self.data.length) &#123;</span><br><span class=\"line\">                    return &#123;</span><br><span class=\"line\">                        value: self.data[index++],</span><br><span class=\"line\">                        done: false</span><br><span class=\"line\">                    &#125;;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    return &#123; value: undefined, done: true &#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([...obj])</span><br><span class=\"line\"></span><br><span class=\"line\">// [&quot;hello&quot;, &quot;world&quot;]</span><br></pre></td></tr></table></figure></p>\n<p><strong>Iterator 接口主要供for…of消费。</strong><br><strong><code>for...in</code> 循环读取键名，<code>for...of</code> 循环读取键值。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">for(let v of arr) &#123;</span><br><span class=\"line\">    console.log(v); // red green blue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for(let k in arr)&#123;</span><br><span class=\"line\">    console.log(k) // 0 1 2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Generator-函数的语法\"><a href=\"#Generator-函数的语法\" class=\"headerlink\" title=\"Generator 函数的语法\"></a>Generator 函数的语法</h1><p><strong>一种异步解决方案。函数执行返回一个对象，而函数中的数据只有在对象使用 next() 方法才会返回下一个用 <code>yield</code> 或者 <code>return</code> 定义的数据，否则对象状态就凝固在那里。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* helloGenerator() &#123;</span><br><span class=\"line\">    yield &apos;hello&apos;</span><br><span class=\"line\">    yield &apos;world&apos;</span><br><span class=\"line\">    return &apos;generator&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var h = helloGenerator()</span><br><span class=\"line\">console.log(h.next())</span><br><span class=\"line\">console.log(h.next())</span><br><span class=\"line\">console.log(h.next())</span><br><span class=\"line\">console.log(h.next())</span><br><span class=\"line\"></span><br><span class=\"line\">// &#123; value: &apos;hello&apos;, done: false&#125;</span><br><span class=\"line\">// &#123; value: &apos;world&apos;, done: false&#125;</span><br><span class=\"line\">// &#123; value: &apos;generator&apos;, done: true&#125;</span><br><span class=\"line\">// &#123; value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>next() 方法传值—— <code>next()</code> 方法返回的是 <code>yield</code> 表达式的计算结果。如果 <code>next(value)</code> 方法中传入value参数，则参数将替换上一个 <code>yield</code> 数据。如下示例中，<code>12</code> 替换了<code>(yield (x + 1))</code>，<code>13</code> 替换了<code>yield (y / 3)</code>，最后得到结果为42。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* foo(x) &#123;</span><br><span class=\"line\">  var y = 2 * (yield (x + 1));</span><br><span class=\"line\">  // value  = 5 + 1</span><br><span class=\"line\">  var z = yield (y / 3);</span><br><span class=\"line\">  // y = 2 * 12 value = 24 / 3</span><br><span class=\"line\">  return (x + y + z);</span><br><span class=\"line\">  // z = 13 y = 24 z = 13 value = 5 + 24 + 13</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var a = foo(5);</span><br><span class=\"line\">a.next() // Object&#123;value:6, done:false&#125;</span><br><span class=\"line\">// 如果不传递数据，则y=NaN</span><br><span class=\"line\">a.next() // Object&#123;value:NaN, done:false&#125;</span><br><span class=\"line\">a.next() // Object&#123;value:NaN, done:true&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var b = foo(5);</span><br><span class=\"line\"></span><br><span class=\"line\">b.next() // &#123; value:6, done:false &#125;</span><br><span class=\"line\">b.next(12) // &#123; value:8, done:false &#125;</span><br><span class=\"line\">b.next(13) // &#123; value:42, done:true &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>throw方法用于捕捉错误，return方法类似于 Genterator 函数的 <code>return xxx</code> 返回某个值，随后再使用next方法返回的都是 <code>undefined</code></strong><br><strong>对于 next、throw、return，引用书上的解释更清晰点。</strong></p>\n<blockquote>\n<p><code>next()</code> 是将 <code>yield</code> 表达式替换成一个值。<br><code>throw()</code> 是将 <code>yield</code> 表达式替换成一个 <code>throw</code> 语句。<br><code>return()</code> 是将 <code>yield</code> 表达式替换成一个 <code>return</code> 语句。</p>\n</blockquote>\n<p><code>yield*</code> <strong>用于将其他 Generator 函数合并到当前函数中，用法如下：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* bar() &#123;</span><br><span class=\"line\">    yield &apos;a&apos;</span><br><span class=\"line\">    yield &apos;b&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function* foo() &#123;</span><br><span class=\"line\">    yield &apos;x&apos;</span><br><span class=\"line\">    yield* bar()</span><br><span class=\"line\">    yield &apos;y&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let v of foo())&#123;</span><br><span class=\"line\">    console.log(v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// x</span><br><span class=\"line\">// a</span><br><span class=\"line\">// b</span><br><span class=\"line\">// y</span><br></pre></td></tr></table></figure></p>\n<p><strong>Generator 函数不能直接用 new 指令实例化对象，需要包装为普通函数再 new</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* gen() &#123;</span><br><span class=\"line\">  this.a = 1;</span><br><span class=\"line\">  yield this.b = 2;</span><br><span class=\"line\">  yield this.c = 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function F() &#123;</span><br><span class=\"line\">  return gen.call(gen.prototype);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var f = new F();</span><br><span class=\"line\"></span><br><span class=\"line\">f.next();  // Object &#123;value: 2, done: false&#125;</span><br><span class=\"line\">f.next();  // Object &#123;value: 3, done: false&#125;</span><br><span class=\"line\">f.next();  // Object &#123;value: undefined, done: true&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f.a // 1</span><br><span class=\"line\">f.b // 2</span><br><span class=\"line\">f.c // 3</span><br></pre></td></tr></table></figure></p>\n<p><strong>自动执行所有Generator函数的方法：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function run(fn) &#123;</span><br><span class=\"line\">  var gen = fn();</span><br><span class=\"line\"></span><br><span class=\"line\">  function next(err, data) &#123;</span><br><span class=\"line\">    var result = gen.next(data);</span><br><span class=\"line\">    if (result.done) return;</span><br><span class=\"line\">    result.value(next);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function* g() &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">run(g);</span><br></pre></td></tr></table></figure></p>\n<p><strong>以上自动执行器还可以使用 <code>co</code> 模块来实现。</strong></p>\n<h1 id=\"async-函数\"><a href=\"#async-函数\" class=\"headerlink\" title=\"async 函数\"></a>async 函数</h1><p>async函数用于处理异步操作，它是对Generator函数的改进。它相比于Generator有以下几个优点：</p>\n<ul>\n<li>内置执行器：相比于Generator 要自定义或者用 co 模块来实现自动执行器效果，async函数自带自动执行器。</li>\n<li>更好的语义：async 和 await，比起 * 和 yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li>\n<li>更广的适用性：co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li>\n<li>返回Promise：async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</li>\n</ul>\n<p>我个人对async的感觉是写法方便、代码理解简单、代码写法也符合逻辑、操作异步行为方便。<br>下面写了 Generator 函数和 async 函数实现异步的代码的对比。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const readFile = function (fileName) &#123;</span><br><span class=\"line\">    return new Promise(function (resolve, reject) &#123;</span><br><span class=\"line\">        setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            console.log(`reading $&#123;fileName&#125;`)</span><br><span class=\"line\">            resolve(fileName)</span><br><span class=\"line\">        &#125;, 1000)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Generator 写法</span><br><span class=\"line\">const gen = function* () &#123;</span><br><span class=\"line\">    const f1 = yield readFile(&apos;/etc/fstab&apos;);</span><br><span class=\"line\">    const f2 = yield readFile(&apos;/etc/shells&apos;);</span><br><span class=\"line\">    console.log(f1.toString());</span><br><span class=\"line\">    console.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var g = gen()</span><br><span class=\"line\">g.next().value.then(value =&gt; &#123;</span><br><span class=\"line\">    g.next(value).value.then(value =&gt; &#123;</span><br><span class=\"line\">        g.next(value)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// async 写法</span><br><span class=\"line\">async function gan() &#123;</span><br><span class=\"line\">    const f1 = await readFile(&apos;/etc/fstab&apos;);</span><br><span class=\"line\">    const f2 = await readFile(&apos;/etc/shells&apos;);</span><br><span class=\"line\">    console.log(f1.toString());</span><br><span class=\"line\">    console.log(f2.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">gan()</span><br></pre></td></tr></table></figure></p>\n<p>两种函数的实现结果是一样的。<br>但从上面的例子中可以看出，Generator 函数需要不断调用next方法，并且将上一个next方法的结果传递给当前next方法当做参数。而async函数直接调用函数本身就会自动往下执行。Generator多了一步执行的过程。<br>另外，async await的语义很清晰，就算没学过ES6的大致都能看懂是什么意思啦~</p>\n<h1 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h1><p>class其实就是一个函数实例化的语法糖~具体功能也类似Java这类有Class的语言~<br>所以，下面两种写法的结果是相等的。<br><strong>传统写法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Point(x, y) &#123;</span><br><span class=\"line\">    this.x = x;</span><br><span class=\"line\">    this.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point.prototype.toString = function () &#123;</span><br><span class=\"line\">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var p = new Point(1, 2);</span><br><span class=\"line\">console.log(p)</span><br></pre></td></tr></table></figure></p>\n<p><strong>ES6 Class写法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">    constructor(x, y) &#123;</span><br><span class=\"line\">        this.x = x;</span><br><span class=\"line\">        this.y = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    toString() &#123;</span><br><span class=\"line\">        return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var p = new Point(1, 2);</span><br><span class=\"line\">console.log(p)</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1987062-3f972d9e15d96308.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"结果\"><br>对象结果如上图所示，构造函数中this对象的属性在实例中，而Class里面的函数再实例对象的 <code>__proto__</code> 中。<br><strong>使用 <code>new target</code> 在构造函数中判断对象是否为 <code>new</code> 指令创建的。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 另一种写法</span><br><span class=\"line\">function Person(name) &#123;</span><br><span class=\"line\">  if (new.target === Person) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    throw new Error(&apos;必须使用 new 命令生成实例&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var person = new Person(&apos;张三&apos;); // 正确</span><br><span class=\"line\">var notAPerson = Person.call(person, &apos;张三&apos;);  // 报错</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"修饰器\"><a href=\"#修饰器\" class=\"headerlink\" title=\"修饰器\"></a>修饰器</h1><p>类似于Java的修饰器 <code>@Override</code> ， 现有一个提案，将修饰器加入到 ECMAScript 中。</p>\n<h1 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h1><p>在 ES6 中添加了模块化功能，很常见用法也很简单。<br><strong>模块加载</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; stat, exists, readFile &#125; from &apos;fs&apos;; // 多个模块加载</span><br><span class=\"line\">import &#123; lastName as surname &#125; from &apos;./profile.js&apos;; // 模块加载重命名</span><br><span class=\"line\">import * as circle from &apos;./circle&apos;; // 整理加载</span><br></pre></td></tr></table></figure></p>\n<p><strong>模块输出</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 输出变量</span><br><span class=\"line\">export let a = 100</span><br><span class=\"line\">// 输出方法</span><br><span class=\"line\">export function hello() &#123;</span><br><span class=\"line\">    console.log(&apos;hello world&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 输出多个变量</span><br><span class=\"line\">const b = 200</span><br><span class=\"line\">const c = 300</span><br><span class=\"line\">const d = 400</span><br><span class=\"line\">export &#123;b, c, d&#125;</span><br><span class=\"line\">// 输出变量重命名</span><br><span class=\"line\">export &#123;b as value&#125;</span><br><span class=\"line\">// 输出默认值</span><br><span class=\"line\">export default function () &#123;</span><br><span class=\"line\">    console.log(&apos;hello default&apos;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong><code>CommonJS</code> 语法中模块输出和加载的写法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123; stat, exists, readFile &#125; = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  counter: counter,</span><br><span class=\"line\">  incCounter: incCounter,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"ArrayBuffer\"><a href=\"#ArrayBuffer\" class=\"headerlink\" title=\"ArrayBuffer\"></a>ArrayBuffer</h1><p>ArrayBuffer对象、TypedArray视图和DataView视图是 JavaScript 操作二进制数据的一个接口。</p>\n<blockquote>\n<p><strong>二进制数组由三类对象组成。</strong><br>（1）ArrayBuffer对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。<br>（2）TypedArray视图：共包括 9 种类型的视图，比如Uint8Array（无符号 8 位整数）数组视图, Int16Array（16 位整数）数组视图, Float32Array（32 位浮点数）数组视图等等。<br>（3）DataView视图：可以自定义复合格式的视图，比如第一个字节是 Uint8（无符号 8 位整数）、第二、三个字节是 Int16（16 位整数）、第四个字节开始是 Float32（32 位浮点数）等等，此外还可以自定义字节序。<br>简单说，ArrayBuffer对象代表原始的二进制数据，TypedArray 视图用来读写简单类型的二进制数据，DataView视图用来读写复杂类型的二进制数据。</p>\n</blockquote>\n<p>这方面知识点不太常用，了解下，等到用的时候查查就是了。</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><ul>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/style\" target=\"_blank\" rel=\"noopener\">编程风格</a> —— 主要参考了 <a href=\"https://github.com/airbnb/javascript\" target=\"_blank\" rel=\"noopener\">Airbnb</a> 公司的 JavaScript 风格规范。</li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/spec\" target=\"_blank\" rel=\"noopener\">读懂 ECMAScript 规格</a> —— 对于规格的学习建议，阮一峰老师的建议如下：<blockquote>\n<p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。<br>一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>好啦~终于把下半部分写完了。有点虎头蛇尾，一开始写的东西很具体，到后来内容有点少。主要是因为前面部分我觉得是比较麻烦和常用的。写这篇博客主要是系统复习下ES6语法，简略地提一下各个语法的用法、注意点。大致知道了有些什么，以后遇到问题知道如何查资料如何解决就好了。<br>感觉自己写博客速度忒慢了，写ES6笔记断断续续花了我十个小时……<br>最后呢，还是那句话——<strong>由自己整理写出博客的知识点才是真正牢牢掌握的知识点！</strong>至此，我对ES6语法的理解加深了很多。看到此文的你可以去试试用写博客的方式来复习知识点哦~<br>希望我写的东西能帮助到一些朋友。</p>\n<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><p>VioletJack，内驱工程师~专注于Vue前端相关的知识点整理、源码学习、内容分享。欢迎喜欢我文章的朋友关注我哦，我会努力产出优质内容~让我们始终相信：code change world!</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>认真学习了一遍ES6，发现很多很好用的功能。<br>学习资料：<a href=\"http://es6.ruanyifeng.com/#README\" target=\"_blank\" rel=\"noopener\">《ECMAScript 6 入门》</a></p>\n</blockquote>\n<p>好啦，继续下半部分的学习。</p>\n<h1 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h1><p>Proxy 用于修改对象的某些操作行为。套用书上的栗子，实现了对象的set、get方法拦截。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = new Proxy(&#123;&#125;, &#123;</span><br><span class=\"line\">    get: function (target, key, receiver) &#123;</span><br><span class=\"line\">        console.log(`getting $&#123;key&#125;!`);</span><br><span class=\"line\">        return Reflect.get(target, key, receiver);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: function (target, key, value, receiver) &#123;</span><br><span class=\"line\">        console.log(`setting $&#123;key&#125;!`);</span><br><span class=\"line\">        return Reflect.set(target, key, value, receiver);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">obj.count = 1</span><br><span class=\"line\">obj.name = &apos;jack&apos;</span><br><span class=\"line\">obj.count++</span><br><span class=\"line\"></span><br><span class=\"line\">// setting count</span><br><span class=\"line\">// setting name</span><br><span class=\"line\">// getting count</span><br><span class=\"line\">// setting count</span><br></pre></td></tr></table></figure></p>\n<p><strong>实例方法整理</strong></p>\n<ul>\n<li>get 方法拦截属性的读取操作。</li>\n<li>set 方法拦截赋值操。</li>\n<li>apply 方法拦截函数的调用。</li>\n<li>has 方法拦截 <code>HasProperty</code> 操作，即查找对象中是否有某属性。可用来隐藏一些属性不被 <code>in</code> 运算符发现。</li>\n<li>construct 方法拦截 <code>new</code> 指令。即在 <code>new</code> 指令创建实例的时候可以对对象中的参数进行一些初始化修改操作。</li>\n<li>deleteProperty方法拦截 <code>delete</code> 指令，可用来保护某些对象属性无法被删除。</li>\n<li>defineProperty方法拦截了Object.defineProperty操作。</li>\n<li>getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined</li>\n<li>getPrototypeOf方法主要用来拦截获取对象原型。</li>\n<li>isExtensible方法拦截Object.isExtensible操作。</li>\n<li>ownKeys方法用来拦截对象自身属性的读取操作。</li>\n<li>preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。</li>\n<li>setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。</li>\n</ul>\n<p>apply方法的使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var target = function () &#123; return &apos;I am the target&apos;; &#125;;</span><br><span class=\"line\">var handler = &#123;</span><br><span class=\"line\">    apply: function () &#123;</span><br><span class=\"line\">        return &apos;I am the proxy&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var p = new Proxy(target, handler);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(p())</span><br><span class=\"line\">// &quot;I am the proxy&quot;</span><br></pre></td></tr></table></figure></p>\n<p>has方法的使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var handler = &#123;</span><br><span class=\"line\">    has (target, key) &#123;</span><br><span class=\"line\">        if (key[0] === &apos;_&apos;) &#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return key in target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var target = &#123; _prop: &apos;foo&apos;, prop: &apos;foo&apos; &#125;;</span><br><span class=\"line\">var proxy = new Proxy(target, handler);</span><br><span class=\"line\">console.log(&apos;_prop&apos; in proxy)</span><br><span class=\"line\">// false</span><br></pre></td></tr></table></figure></p>\n<p>construct方法的使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p = new Proxy(function () &#123;&#125;, &#123;</span><br><span class=\"line\">    construct: function(target, args) &#123;</span><br><span class=\"line\">        console.log(&apos;called: &apos; + args.join(&apos;, &apos;));</span><br><span class=\"line\">        return &#123; value: args[0] * 5 + 12 &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(new p(1))</span><br><span class=\"line\">console.log(new p(1).value)</span><br><span class=\"line\"></span><br><span class=\"line\">// call: 1</span><br><span class=\"line\">// &#123; value: 17 &#125;</span><br><span class=\"line\">// call: 1</span><br><span class=\"line\">// 17</span><br></pre></td></tr></table></figure></p>\n<p>所以，我理解的 Proxy 对象主要功能就是拦截对象属性的一些操作。</p>\n<h1 id=\"Reflect\"><a href=\"#Reflect\" class=\"headerlink\" title=\"Reflect\"></a>Reflect</h1><p>我理解的Reflect对象：</p>\n<ul>\n<li>是Object的高级版本，Object对对象的操作方法Reflect对象都有，并且未来操作对象的新方法只放在Reflect对象中有。</li>\n<li>发生错误不会报错而是返回false，可直接在判断中使用。</li>\n<li>让Object操作都变成函数行为，统一表现形式。某些Object操作是命令式，比如 <code>name in obj</code> 和 <code>delete obj[name]</code> ，而 <code>Reflect.has(obj, name)</code> 和 <code>Reflect.deleteProperty(obj, name)</code> 让它们变成了函数行为。</li>\n<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。Proxy对象拦截对象属性方法，进行重新定义。而Reflect对象立即执行对象属性方法。下面例子中使用set和get做演示。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myObject = &#123;</span><br><span class=\"line\">    foo: 1,</span><br><span class=\"line\">    bar: 2,</span><br><span class=\"line\">    get baz() &#123;</span><br><span class=\"line\">        return this.foo + this.bar;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Reflect.get(myObject, &apos;foo&apos;)) </span><br><span class=\"line\">console.log(Reflect.get(myObject, &apos;bar&apos;)) </span><br><span class=\"line\">console.log(Reflect.get(myObject, &apos;baz&apos;)) </span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Reflect.set(myObject, &apos;foo&apos;, 100))</span><br><span class=\"line\">console.log(myObject.foo)</span><br><span class=\"line\"></span><br><span class=\"line\">// 1</span><br><span class=\"line\">// 2</span><br><span class=\"line\">// 3</span><br><span class=\"line\">// true</span><br><span class=\"line\">// 100</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"Promise-对象\"><a href=\"#Promise-对象\" class=\"headerlink\" title=\"Promise 对象\"></a>Promise 对象</h1><p>Promise 对象登场啦~这是 ES6 语法中非常常用的对象。<br>我理解的 Promise 对象：</p>\n<ul>\n<li>Promise 对象让异步操作的写法从回调函数变为链式操作，可读性更强。</li>\n<li>Promise 对象一旦改变，就会锁死，不再改变。</li>\n</ul>\n<p><strong>基本用法</strong><br>Promise 的定义，定义一个 Promise对象，参数为resolve和reject，resolve为执行成功的方法，而reject为执行失败的方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">  // ... some code</span><br><span class=\"line\"></span><br><span class=\"line\">  if (/* 异步操作成功 */)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>基本调用方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(function(value) &#123;</span><br><span class=\"line\">  // success</span><br><span class=\"line\">&#125;, function(error) &#123;</span><br><span class=\"line\">  // failure</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><strong>Promise 函数一旦用 new 指令创建，立即执行。并且数据为不可变。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let success = true</span><br><span class=\"line\">let name = &apos;jack&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;create&apos;)</span><br><span class=\"line\">    if (success) &#123;</span><br><span class=\"line\">        resolve(name)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        reject(&apos;error promise&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">success = false</span><br><span class=\"line\">name = &apos;rose&apos;</span><br><span class=\"line\">console.log(&apos;before then&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(value =&gt; &#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">&#125;).catch(error =&gt; &#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// create</span><br><span class=\"line\">// before then</span><br><span class=\"line\">// jack</span><br></pre></td></tr></table></figure></p>\n<p>由此可见，在定义了Promise之后，我们再去修改 <code>name</code> 返回的还是定义Promise时候的值。说明了Promise对象定义即执行，并且不可变。</p>\n<p><strong>Promise 推荐使用 <code>promise.then().catch()</code>  写法。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">promise.then(value =&gt; &#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">&#125;, error =&gt; &#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// good</span><br><span class=\"line\">promise.then(value =&gt; &#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">&#125;).catch(error =&gt; &#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>then方法链式写法表达，then方法的返回值可以传递给下一个then方法。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    resolve(&apos;jack&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(value =&gt; &#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">    return &apos;violet&apos; + value</span><br><span class=\"line\">&#125;).then(value =&gt; &#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">    return &apos;welcome to &apos; + value</span><br><span class=\"line\">&#125;).then(value =&gt; &#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">    return  value + &apos; blog&apos;</span><br><span class=\"line\">&#125;).then(value =&gt; &#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// jack</span><br><span class=\"line\">// violetjack</span><br><span class=\"line\">// welcome to violetjack</span><br><span class=\"line\">// welcome to violetjack blog</span><br></pre></td></tr></table></figure></p>\n<p><strong>catch方法用于捕获Promise对象的异常行为（可能是 reject 函数返回的错误，也可能是<code>throw new Error(&#39;error&#39;)</code>）。</strong><br><strong>Promise.all() 方法将多个Promise实例包装成一个Promise实例。如下示例，如果p1、p2、p3都执行成功，则执行then方法，返回的参数为三个实例的参数数组；如果有任意一个Promise实例报错，则在catch方法中返回该实例的错误信息。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    resolve(&apos;jack&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">const p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    // resolve(&apos;rose&apos;)</span><br><span class=\"line\">    reject(&apos;rose error&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">const p3 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    resolve(&apos;james&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([p1, p2, p3]).then(values =&gt; &#123;</span><br><span class=\"line\">    console.log(values)</span><br><span class=\"line\">&#125;).catch(error =&gt; &#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// [&quot;jack&quot;, &quot;rose&quot;, &quot;james&quot;]</span><br><span class=\"line\">// rose error</span><br></pre></td></tr></table></figure></p>\n<p><strong>Promise.race() 方法用法与 all 方法一致，唯一不同点就是多个 Promise实例中只作用域最快有反映的Promise实例，并且返回该实例的正确或错误信息。如果多个Promise同时触发，按顺序返回第一个Promise实例。</strong><br><strong>Promise.resolve() 和 Promise.reject()</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.resolve(&apos;foo&apos;)</span><br><span class=\"line\">// 等价于</span><br><span class=\"line\">new Promise(resolve =&gt; resolve(&apos;foo&apos;))</span><br><span class=\"line\"></span><br><span class=\"line\">const p = Promise.reject(&apos;出错了&apos;);</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">const p = new Promise((resolve, reject) =&gt; reject(&apos;出错了&apos;))</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Iterator-和-for…of-循环\"><a href=\"#Iterator-和-for…of-循环\" class=\"headerlink\" title=\"Iterator 和 for…of 循环\"></a>Iterator 和 for…of 循环</h1><p><strong>默认Iterator接口部署在数据对象的 <code>Symbol.iterator</code> 属性中，<code>Symbol.iterator</code> 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。只要数据对象有了 <code>Symbol.iterator</code> 属性就可以进行遍历。如下对象添加了 <code>Symbol.iterator</code>  属性后实现了遍历操作。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    data: [ &apos;hello&apos;, &apos;world&apos; ],</span><br><span class=\"line\">    [Symbol.iterator]() &#123;</span><br><span class=\"line\">        const self = this;</span><br><span class=\"line\">        let index = 0;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            next() &#123;</span><br><span class=\"line\">                if (index &lt; self.data.length) &#123;</span><br><span class=\"line\">                    return &#123;</span><br><span class=\"line\">                        value: self.data[index++],</span><br><span class=\"line\">                        done: false</span><br><span class=\"line\">                    &#125;;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    return &#123; value: undefined, done: true &#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log([...obj])</span><br><span class=\"line\"></span><br><span class=\"line\">// [&quot;hello&quot;, &quot;world&quot;]</span><br></pre></td></tr></table></figure></p>\n<p><strong>Iterator 接口主要供for…of消费。</strong><br><strong><code>for...in</code> 循环读取键名，<code>for...of</code> 循环读取键值。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">for(let v of arr) &#123;</span><br><span class=\"line\">    console.log(v); // red green blue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for(let k in arr)&#123;</span><br><span class=\"line\">    console.log(k) // 0 1 2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Generator-函数的语法\"><a href=\"#Generator-函数的语法\" class=\"headerlink\" title=\"Generator 函数的语法\"></a>Generator 函数的语法</h1><p><strong>一种异步解决方案。函数执行返回一个对象，而函数中的数据只有在对象使用 next() 方法才会返回下一个用 <code>yield</code> 或者 <code>return</code> 定义的数据，否则对象状态就凝固在那里。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* helloGenerator() &#123;</span><br><span class=\"line\">    yield &apos;hello&apos;</span><br><span class=\"line\">    yield &apos;world&apos;</span><br><span class=\"line\">    return &apos;generator&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var h = helloGenerator()</span><br><span class=\"line\">console.log(h.next())</span><br><span class=\"line\">console.log(h.next())</span><br><span class=\"line\">console.log(h.next())</span><br><span class=\"line\">console.log(h.next())</span><br><span class=\"line\"></span><br><span class=\"line\">// &#123; value: &apos;hello&apos;, done: false&#125;</span><br><span class=\"line\">// &#123; value: &apos;world&apos;, done: false&#125;</span><br><span class=\"line\">// &#123; value: &apos;generator&apos;, done: true&#125;</span><br><span class=\"line\">// &#123; value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>next() 方法传值—— <code>next()</code> 方法返回的是 <code>yield</code> 表达式的计算结果。如果 <code>next(value)</code> 方法中传入value参数，则参数将替换上一个 <code>yield</code> 数据。如下示例中，<code>12</code> 替换了<code>(yield (x + 1))</code>，<code>13</code> 替换了<code>yield (y / 3)</code>，最后得到结果为42。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* foo(x) &#123;</span><br><span class=\"line\">  var y = 2 * (yield (x + 1));</span><br><span class=\"line\">  // value  = 5 + 1</span><br><span class=\"line\">  var z = yield (y / 3);</span><br><span class=\"line\">  // y = 2 * 12 value = 24 / 3</span><br><span class=\"line\">  return (x + y + z);</span><br><span class=\"line\">  // z = 13 y = 24 z = 13 value = 5 + 24 + 13</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var a = foo(5);</span><br><span class=\"line\">a.next() // Object&#123;value:6, done:false&#125;</span><br><span class=\"line\">// 如果不传递数据，则y=NaN</span><br><span class=\"line\">a.next() // Object&#123;value:NaN, done:false&#125;</span><br><span class=\"line\">a.next() // Object&#123;value:NaN, done:true&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var b = foo(5);</span><br><span class=\"line\"></span><br><span class=\"line\">b.next() // &#123; value:6, done:false &#125;</span><br><span class=\"line\">b.next(12) // &#123; value:8, done:false &#125;</span><br><span class=\"line\">b.next(13) // &#123; value:42, done:true &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>throw方法用于捕捉错误，return方法类似于 Genterator 函数的 <code>return xxx</code> 返回某个值，随后再使用next方法返回的都是 <code>undefined</code></strong><br><strong>对于 next、throw、return，引用书上的解释更清晰点。</strong></p>\n<blockquote>\n<p><code>next()</code> 是将 <code>yield</code> 表达式替换成一个值。<br><code>throw()</code> 是将 <code>yield</code> 表达式替换成一个 <code>throw</code> 语句。<br><code>return()</code> 是将 <code>yield</code> 表达式替换成一个 <code>return</code> 语句。</p>\n</blockquote>\n<p><code>yield*</code> <strong>用于将其他 Generator 函数合并到当前函数中，用法如下：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* bar() &#123;</span><br><span class=\"line\">    yield &apos;a&apos;</span><br><span class=\"line\">    yield &apos;b&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function* foo() &#123;</span><br><span class=\"line\">    yield &apos;x&apos;</span><br><span class=\"line\">    yield* bar()</span><br><span class=\"line\">    yield &apos;y&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">for (let v of foo())&#123;</span><br><span class=\"line\">    console.log(v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// x</span><br><span class=\"line\">// a</span><br><span class=\"line\">// b</span><br><span class=\"line\">// y</span><br></pre></td></tr></table></figure></p>\n<p><strong>Generator 函数不能直接用 new 指令实例化对象，需要包装为普通函数再 new</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* gen() &#123;</span><br><span class=\"line\">  this.a = 1;</span><br><span class=\"line\">  yield this.b = 2;</span><br><span class=\"line\">  yield this.c = 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function F() &#123;</span><br><span class=\"line\">  return gen.call(gen.prototype);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var f = new F();</span><br><span class=\"line\"></span><br><span class=\"line\">f.next();  // Object &#123;value: 2, done: false&#125;</span><br><span class=\"line\">f.next();  // Object &#123;value: 3, done: false&#125;</span><br><span class=\"line\">f.next();  // Object &#123;value: undefined, done: true&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f.a // 1</span><br><span class=\"line\">f.b // 2</span><br><span class=\"line\">f.c // 3</span><br></pre></td></tr></table></figure></p>\n<p><strong>自动执行所有Generator函数的方法：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function run(fn) &#123;</span><br><span class=\"line\">  var gen = fn();</span><br><span class=\"line\"></span><br><span class=\"line\">  function next(err, data) &#123;</span><br><span class=\"line\">    var result = gen.next(data);</span><br><span class=\"line\">    if (result.done) return;</span><br><span class=\"line\">    result.value(next);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function* g() &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">run(g);</span><br></pre></td></tr></table></figure></p>\n<p><strong>以上自动执行器还可以使用 <code>co</code> 模块来实现。</strong></p>\n<h1 id=\"async-函数\"><a href=\"#async-函数\" class=\"headerlink\" title=\"async 函数\"></a>async 函数</h1><p>async函数用于处理异步操作，它是对Generator函数的改进。它相比于Generator有以下几个优点：</p>\n<ul>\n<li>内置执行器：相比于Generator 要自定义或者用 co 模块来实现自动执行器效果，async函数自带自动执行器。</li>\n<li>更好的语义：async 和 await，比起 * 和 yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li>\n<li>更广的适用性：co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li>\n<li>返回Promise：async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</li>\n</ul>\n<p>我个人对async的感觉是写法方便、代码理解简单、代码写法也符合逻辑、操作异步行为方便。<br>下面写了 Generator 函数和 async 函数实现异步的代码的对比。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const readFile = function (fileName) &#123;</span><br><span class=\"line\">    return new Promise(function (resolve, reject) &#123;</span><br><span class=\"line\">        setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            console.log(`reading $&#123;fileName&#125;`)</span><br><span class=\"line\">            resolve(fileName)</span><br><span class=\"line\">        &#125;, 1000)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Generator 写法</span><br><span class=\"line\">const gen = function* () &#123;</span><br><span class=\"line\">    const f1 = yield readFile(&apos;/etc/fstab&apos;);</span><br><span class=\"line\">    const f2 = yield readFile(&apos;/etc/shells&apos;);</span><br><span class=\"line\">    console.log(f1.toString());</span><br><span class=\"line\">    console.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var g = gen()</span><br><span class=\"line\">g.next().value.then(value =&gt; &#123;</span><br><span class=\"line\">    g.next(value).value.then(value =&gt; &#123;</span><br><span class=\"line\">        g.next(value)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// async 写法</span><br><span class=\"line\">async function gan() &#123;</span><br><span class=\"line\">    const f1 = await readFile(&apos;/etc/fstab&apos;);</span><br><span class=\"line\">    const f2 = await readFile(&apos;/etc/shells&apos;);</span><br><span class=\"line\">    console.log(f1.toString());</span><br><span class=\"line\">    console.log(f2.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">gan()</span><br></pre></td></tr></table></figure></p>\n<p>两种函数的实现结果是一样的。<br>但从上面的例子中可以看出，Generator 函数需要不断调用next方法，并且将上一个next方法的结果传递给当前next方法当做参数。而async函数直接调用函数本身就会自动往下执行。Generator多了一步执行的过程。<br>另外，async await的语义很清晰，就算没学过ES6的大致都能看懂是什么意思啦~</p>\n<h1 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h1><p>class其实就是一个函数实例化的语法糖~具体功能也类似Java这类有Class的语言~<br>所以，下面两种写法的结果是相等的。<br><strong>传统写法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Point(x, y) &#123;</span><br><span class=\"line\">    this.x = x;</span><br><span class=\"line\">    this.y = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point.prototype.toString = function () &#123;</span><br><span class=\"line\">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var p = new Point(1, 2);</span><br><span class=\"line\">console.log(p)</span><br></pre></td></tr></table></figure></p>\n<p><strong>ES6 Class写法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">    constructor(x, y) &#123;</span><br><span class=\"line\">        this.x = x;</span><br><span class=\"line\">        this.y = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    toString() &#123;</span><br><span class=\"line\">        return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var p = new Point(1, 2);</span><br><span class=\"line\">console.log(p)</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1987062-3f972d9e15d96308.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"结果\"><br>对象结果如上图所示，构造函数中this对象的属性在实例中，而Class里面的函数再实例对象的 <code>__proto__</code> 中。<br><strong>使用 <code>new target</code> 在构造函数中判断对象是否为 <code>new</code> 指令创建的。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 另一种写法</span><br><span class=\"line\">function Person(name) &#123;</span><br><span class=\"line\">  if (new.target === Person) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    throw new Error(&apos;必须使用 new 命令生成实例&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var person = new Person(&apos;张三&apos;); // 正确</span><br><span class=\"line\">var notAPerson = Person.call(person, &apos;张三&apos;);  // 报错</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"修饰器\"><a href=\"#修饰器\" class=\"headerlink\" title=\"修饰器\"></a>修饰器</h1><p>类似于Java的修饰器 <code>@Override</code> ， 现有一个提案，将修饰器加入到 ECMAScript 中。</p>\n<h1 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h1><p>在 ES6 中添加了模块化功能，很常见用法也很简单。<br><strong>模块加载</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; stat, exists, readFile &#125; from &apos;fs&apos;; // 多个模块加载</span><br><span class=\"line\">import &#123; lastName as surname &#125; from &apos;./profile.js&apos;; // 模块加载重命名</span><br><span class=\"line\">import * as circle from &apos;./circle&apos;; // 整理加载</span><br></pre></td></tr></table></figure></p>\n<p><strong>模块输出</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 输出变量</span><br><span class=\"line\">export let a = 100</span><br><span class=\"line\">// 输出方法</span><br><span class=\"line\">export function hello() &#123;</span><br><span class=\"line\">    console.log(&apos;hello world&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 输出多个变量</span><br><span class=\"line\">const b = 200</span><br><span class=\"line\">const c = 300</span><br><span class=\"line\">const d = 400</span><br><span class=\"line\">export &#123;b, c, d&#125;</span><br><span class=\"line\">// 输出变量重命名</span><br><span class=\"line\">export &#123;b as value&#125;</span><br><span class=\"line\">// 输出默认值</span><br><span class=\"line\">export default function () &#123;</span><br><span class=\"line\">    console.log(&apos;hello default&apos;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong><code>CommonJS</code> 语法中模块输出和加载的写法</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123; stat, exists, readFile &#125; = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  counter: counter,</span><br><span class=\"line\">  incCounter: incCounter,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"ArrayBuffer\"><a href=\"#ArrayBuffer\" class=\"headerlink\" title=\"ArrayBuffer\"></a>ArrayBuffer</h1><p>ArrayBuffer对象、TypedArray视图和DataView视图是 JavaScript 操作二进制数据的一个接口。</p>\n<blockquote>\n<p><strong>二进制数组由三类对象组成。</strong><br>（1）ArrayBuffer对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。<br>（2）TypedArray视图：共包括 9 种类型的视图，比如Uint8Array（无符号 8 位整数）数组视图, Int16Array（16 位整数）数组视图, Float32Array（32 位浮点数）数组视图等等。<br>（3）DataView视图：可以自定义复合格式的视图，比如第一个字节是 Uint8（无符号 8 位整数）、第二、三个字节是 Int16（16 位整数）、第四个字节开始是 Float32（32 位浮点数）等等，此外还可以自定义字节序。<br>简单说，ArrayBuffer对象代表原始的二进制数据，TypedArray 视图用来读写简单类型的二进制数据，DataView视图用来读写复杂类型的二进制数据。</p>\n</blockquote>\n<p>这方面知识点不太常用，了解下，等到用的时候查查就是了。</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><ul>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/style\" target=\"_blank\" rel=\"noopener\">编程风格</a> —— 主要参考了 <a href=\"https://github.com/airbnb/javascript\" target=\"_blank\" rel=\"noopener\">Airbnb</a> 公司的 JavaScript 风格规范。</li>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/spec\" target=\"_blank\" rel=\"noopener\">读懂 ECMAScript 规格</a> —— 对于规格的学习建议，阮一峰老师的建议如下：<blockquote>\n<p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。<br>一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>好啦~终于把下半部分写完了。有点虎头蛇尾，一开始写的东西很具体，到后来内容有点少。主要是因为前面部分我觉得是比较麻烦和常用的。写这篇博客主要是系统复习下ES6语法，简略地提一下各个语法的用法、注意点。大致知道了有些什么，以后遇到问题知道如何查资料如何解决就好了。<br>感觉自己写博客速度忒慢了，写ES6笔记断断续续花了我十个小时……<br>最后呢，还是那句话——<strong>由自己整理写出博客的知识点才是真正牢牢掌握的知识点！</strong>至此，我对ES6语法的理解加深了很多。看到此文的你可以去试试用写博客的方式来复习知识点哦~<br>希望我写的东西能帮助到一些朋友。</p>\n<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><p>VioletJack，内驱工程师~专注于Vue前端相关的知识点整理、源码学习、内容分享。欢迎喜欢我文章的朋友关注我哦，我会努力产出优质内容~让我们始终相信：code change world!</p>\n"},{"title":"Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）","date":"2016-12-25T16:00:00.000Z","_content":"\n> 想学习Vue的SPA应用，路由这一块是必不可少的。相信很多和我一样刚接触前端的朋友对于路由这玩意是很困惑的。所以在我学习并成功使用了 `vue-router` 后，将我的个人经验分享出来，希望可以让同样对路由不知所措的同学有所帮助。\n\n# 注意：\n* **本文demo的项目结构用的是最新的[命令行工具](https://github.com/vuejs/vue-cli)创建的webpack项目模板**；\n* 本文知识点是基于Vue2.0和vue-route 2的，更多内容请参考[Vue.js官网](http://cn.vuejs.org/)和[vue-router 2官方文档](http://router.vuejs.org/zh-cn/)：\n\n# 一、路由的安装：\n## npm安装\n可以使用npm直接安装插件\n```\nnpm install vue-router --save\n```\n执行命令完成vue-router的安装，并在package.json中添加了vue-router的依赖。当我们在其他电脑上安装项目时只需要执行 `npm install` 即可完成安装。\n\n**package.json**\n```\n  \"dependencies\": {\n    ...\n    \"vue-router\": \"^2.1.1\"\n    ...\n  },\n```\n如果是要安装在开发环境下，则使用以下命令行：\n```\nnpm install vue-router --save-dev\n```\n**package.json**\n```\n  \"devDependencies\": {\n    ...\n    \"vue-router\": \"^2.1.1\",\n    ...\n  },\n```\n# 二、SPA中路由的简单实现（附demo）\n下面让我们来配置路由并实现我们的第一次页面跳转。\n[官方提供的demo](http://router.vuejs.org/zh-cn/essentials/getting-started.html)很简单，复制到HTML中也的确能跑，但是问题是不知道如何在SPA应用中使用，这坑了我不少时间。在看了不少他人的项目后，完成了SPA路由的简单实现demo（基于vue-cli的webpack模板）。\n**main.js**\n```\nimport Vue from 'vue'\nimport App from './App'\nimport VueRouter from 'vue-router'\nimport Page01 from './components/page01'\nimport Page02 from './components/page02'\n\nVue.use(VueRouter)//全局安装路由功能\n//定义路径\nconst routes = [\n  { path: '/', component: Page01 },\n  { path: '/02', component: Page02 },\n]\n//创建路由对象\nconst router = new VueRouter({\n  routes\n})\n\nnew Vue({\n  el: '#app',\n  template: '<App/>',\n  components: { App },\n  router\n})\n```\n**App.vue**\n```\n<template>\n  <div id=\"app\">\n    <router-link to=\"/\">01</router-link>\n    <router-link to=\"/02\">02</router-link>\n    <br/>\n    <router-view></router-view>\n  </div>\n</template>\n```\n**page01.vue**\n```\n<template>\n  <div>\n    <h1>page02</h1>\n  </div>\n</template>\n\n```\n**page02.vue**\n```\n<template>\n  <div>\n    <h1>page02</h1>\n  </div>\n</template>\n\n```\n实现步骤：\n1. `npm`安装`vue-router`\n2. `Vue.use(VueRouter)`全局安装路由功能\n3. 定义路径数组`routes`并创建路由对象`router`\n4. 将`router`对象传到Vue对象中\n5. 在根组件中使用`<router-link>`定义跳转路径\n6. 在根组件中使用`<router-view>`来渲染组件\n7. 创建子组件\n\n# 三、路由的跳转\n## router-link\n`router-link`标签用于页面的跳转，简单用法我们刚才提到过了。\n```\n<router-link to=\"/page01\">page01</router-link>\n```\n点击这个`router-link`标签`router-view`就会渲染路径为`/page01`的页面。\n**注意：**`router-link`默认是一个`<a>`标签的形式，如果需要显示不同的样子，可以在`router-link`标签中写入不同标签元素，如下显示为`button`按钮。\n```\n<router-link to=\"/04\">\n    <button>to04</button>\n</router-link>\n```\n## router.push\n下面我们通过JS代码控制路由的界面渲染，官方文档写法如下：\n```\n// 字符串\nrouter.push('home')\n// 对象\nrouter.push({ path: 'home' })\n// 命名的路由\nrouter.push({ name: 'user', params: { userId: 123 }})\n// 带查询参数，变成 /register?plan=private\nrouter.push({ path: 'register', query: { plan: 'private' }})\n```\n那么问题来了，如果是全局注册的路由`Vue.use(VueRouter)`，应该怎么写呢？\n```\n// 字符串\nthis.$router.push('home')\n// 对象\nthis.$router.push({ path: 'home' })\n// 命名的路由\nthis.$router.push({ name: 'user', params: { userId: 123 }})\n// 带查询参数，变成 /register?plan=private\nthis.$router.push({ path: 'register', query: { plan: 'private' }})\n```\n\n> 为什么能这么写呢，猜测是将router对象传递给Vue对象后，复制router对象为Vue.$router上了。还未在源码中求证，如有错误请指出，谢谢~\n\npush方法其实和`<router-link :to=\"...\">`的写法是等同的。\n**注意：**push方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。\n## router.replace\npush方法会向 history 栈添加一个新的记录，而replace方法是替换当前的页面，不会向 history 栈添加一个新的记录。用法如下\n**template**\n```\n<router-link to=\"/05\" replace>05</router-link>\n```\n**script**\n```\nthis.$router.replace({ path: '/05' })\n```\n## router.go\ngo方法用于控制history记录的前进和后退\n```\n// 在浏览器记录中前进一步，等同于 history.forward()\nthis.$router.go(1)\n// 后退一步记录，等同于 history.back()\nthis.$router.go(-1)\n// 前进 3 步记录router.go(3)\n// 如果 history 记录不够用，那就默默地失败呗\nthis.$router.go(-100)\nthis.$router.go(100)\n```\n其实很好理解：**go方法就是浏览器上的前进后退按钮，方法中传递的数字参数就是前进和后退的次数**\n# 四、路由的传参方式\n在路由跳转的过程中会传递一个object，我们可以通过`watch`方法查看路由信息对象。\n```\nwatch: {\n  '$route' (to, from) {\n      console.log(to);\n      console.log(from);\n  },\n},\n```\n**console中看到的路由信息对象**\n```\n{\n    ...\n    params: { id: '123' },\n    query: { name: 'jack' },\n    ...\n}\n```\n这两个参数会在页面跳转后写在路径中，路径相当于`/page/123?name=jack`\n## 1. params\nparams传递的数据可用于匹配动态路由字段。如params的数据为 `params: { abc: 'hello', txt: 'world' }` 而动态路由路径为 `path: '/05/:txt` 那么最终的路径就会是 `/05/world`。**所以，动态路由其实就是一种params的传递方式。**\n\n**注意：由于动态路由也是传递params的，所以在 `this.$router.push()` 方法中 path不能和params一起使用，否则params将无效！需要用name来指定页面。之后动态路由会从params中找到动态路由同名的数据。**\n\n### 传递数据\n在路由配置文件中定义参数\n```\n export default [\n    ...\n    { name: 'Page05', path: '/05/:txt', component: Page05 },\n]\n```\n下面有两种传递params的方式\n#### 1. 通过path传递\n路径后面的`/:txt`就是我们要传递的参数。\n```\nthis.$router.push({ path: '/05/441'})\n```\n此时路由跳转的路径\n```\nhttp://localhost:8080/#/05/441\n```\n此时我们看到查看路由信息对象：\n```\n{\n    ...\n    params: {\n        txt: '441'\n    }\n    ...\n}\n```\n#### 2. 通过params传递\n```\nthis.$router.replace({ \n    name: 'Page05', \n    params: { abc: 'hello', txt: 'world' }, \n    query: { name: 'query', type: 'object' }\n})\n```\n通过name获取页面，传递params和query。\n得到的URL为\n```\nhttp://localhost:8080/#/05/world?name=query&type=object\n```\n而获取到的参数为\n```\n{\n    ...\n    params: {\n        abc: \"hello\",\n        txt: \"world\"\n    }\n    ...\n}\n```\n### 获取数据\n**template**\n```\n<h2> {{ $route.params.txt }} </h2>\n```\n**script**\n```\nconsole.log(this.$route.params.txt)\n```\n## 2. query\nquery传递数据的方式就是URL常见的查询参数，如`/foo?user=1&name=2&age=3`。很好理解，下面就简单写一下用法以及结果\n### 传递数据\n**template**\n```\n<router-link :to=\"{ path: '/05', query: { name: 'query', type: 'object' }}\" replace>05</router-link>\n```\n**script**\n```\nthis.$router.replace({ path: '/05', query: { name: 'query', type: 'object' }})\n```\n**路径结果**\n```\nhttp://localhost:8080/#/05?name=query&type=object\n```\n**路由信息对象**\n```\n{\n    ...\n    query: {\n        name: \"query\",\n        type: \"object\"\n    }\n    ...\n}\n```\n### 获取数据\n获取数据和params是一样的。\n**template**\n```\n<h2> {{ $route.query.name }} </h2>\n```\n**script**\n```\nconsole.log(this.$route.query.type)\n```\n\n# Vue.js学习系列\n鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。\n\n[Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）](http://www.jianshu.com/p/8013d8d37bd0)\n[Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）](http://www.jianshu.com/p/d6f7e11f18af)\n[Vue.js学习系列三 —— axios和网络传输相关知识的学习实践](http://www.jianshu.com/p/8e5fb763c3d7)\n[Vue.js学习系列四 —— Webpack打包工具的使用](http://www.jianshu.com/p/aef34acd111f)\n[Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint](http://www.jianshu.com/p/efb6fbed6fac)\n[Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记](http://www.jianshu.com/p/073d25a3bba0)\n[Vue.js学习系列七 —— Vue服务器渲染Nuxt学习](https://www.jianshu.com/p/ba7466d7101a)\n[Vue.js学习系列八 —— Vue源码学习之State学习](https://www.jianshu.com/p/15028f91226e)\n\n# Vue.js学习系列项目地址\n本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。\n[https://github.com/violetjack/VueStudyDemos](https://github.com/violetjack/VueStudyDemos)\n\n# 关于作者\nVioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。\n欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。\n\n新浪微博： http://weibo.com/u/2640909603\n掘金：https://gold.xitu.io/user/571d953d39b0570068145cd1\nCSDN: http://blog.csdn.net/violetjack0808\n简书： http://www.jianshu.com/users/54ae4af3a98d/latest_articles\nGithub： https://github.com/violetjack","source":"_posts/Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）.md","raw":"---\ntitle: Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）\ndate: 2016-12-26\n---\n\n> 想学习Vue的SPA应用，路由这一块是必不可少的。相信很多和我一样刚接触前端的朋友对于路由这玩意是很困惑的。所以在我学习并成功使用了 `vue-router` 后，将我的个人经验分享出来，希望可以让同样对路由不知所措的同学有所帮助。\n\n# 注意：\n* **本文demo的项目结构用的是最新的[命令行工具](https://github.com/vuejs/vue-cli)创建的webpack项目模板**；\n* 本文知识点是基于Vue2.0和vue-route 2的，更多内容请参考[Vue.js官网](http://cn.vuejs.org/)和[vue-router 2官方文档](http://router.vuejs.org/zh-cn/)：\n\n# 一、路由的安装：\n## npm安装\n可以使用npm直接安装插件\n```\nnpm install vue-router --save\n```\n执行命令完成vue-router的安装，并在package.json中添加了vue-router的依赖。当我们在其他电脑上安装项目时只需要执行 `npm install` 即可完成安装。\n\n**package.json**\n```\n  \"dependencies\": {\n    ...\n    \"vue-router\": \"^2.1.1\"\n    ...\n  },\n```\n如果是要安装在开发环境下，则使用以下命令行：\n```\nnpm install vue-router --save-dev\n```\n**package.json**\n```\n  \"devDependencies\": {\n    ...\n    \"vue-router\": \"^2.1.1\",\n    ...\n  },\n```\n# 二、SPA中路由的简单实现（附demo）\n下面让我们来配置路由并实现我们的第一次页面跳转。\n[官方提供的demo](http://router.vuejs.org/zh-cn/essentials/getting-started.html)很简单，复制到HTML中也的确能跑，但是问题是不知道如何在SPA应用中使用，这坑了我不少时间。在看了不少他人的项目后，完成了SPA路由的简单实现demo（基于vue-cli的webpack模板）。\n**main.js**\n```\nimport Vue from 'vue'\nimport App from './App'\nimport VueRouter from 'vue-router'\nimport Page01 from './components/page01'\nimport Page02 from './components/page02'\n\nVue.use(VueRouter)//全局安装路由功能\n//定义路径\nconst routes = [\n  { path: '/', component: Page01 },\n  { path: '/02', component: Page02 },\n]\n//创建路由对象\nconst router = new VueRouter({\n  routes\n})\n\nnew Vue({\n  el: '#app',\n  template: '<App/>',\n  components: { App },\n  router\n})\n```\n**App.vue**\n```\n<template>\n  <div id=\"app\">\n    <router-link to=\"/\">01</router-link>\n    <router-link to=\"/02\">02</router-link>\n    <br/>\n    <router-view></router-view>\n  </div>\n</template>\n```\n**page01.vue**\n```\n<template>\n  <div>\n    <h1>page02</h1>\n  </div>\n</template>\n\n```\n**page02.vue**\n```\n<template>\n  <div>\n    <h1>page02</h1>\n  </div>\n</template>\n\n```\n实现步骤：\n1. `npm`安装`vue-router`\n2. `Vue.use(VueRouter)`全局安装路由功能\n3. 定义路径数组`routes`并创建路由对象`router`\n4. 将`router`对象传到Vue对象中\n5. 在根组件中使用`<router-link>`定义跳转路径\n6. 在根组件中使用`<router-view>`来渲染组件\n7. 创建子组件\n\n# 三、路由的跳转\n## router-link\n`router-link`标签用于页面的跳转，简单用法我们刚才提到过了。\n```\n<router-link to=\"/page01\">page01</router-link>\n```\n点击这个`router-link`标签`router-view`就会渲染路径为`/page01`的页面。\n**注意：**`router-link`默认是一个`<a>`标签的形式，如果需要显示不同的样子，可以在`router-link`标签中写入不同标签元素，如下显示为`button`按钮。\n```\n<router-link to=\"/04\">\n    <button>to04</button>\n</router-link>\n```\n## router.push\n下面我们通过JS代码控制路由的界面渲染，官方文档写法如下：\n```\n// 字符串\nrouter.push('home')\n// 对象\nrouter.push({ path: 'home' })\n// 命名的路由\nrouter.push({ name: 'user', params: { userId: 123 }})\n// 带查询参数，变成 /register?plan=private\nrouter.push({ path: 'register', query: { plan: 'private' }})\n```\n那么问题来了，如果是全局注册的路由`Vue.use(VueRouter)`，应该怎么写呢？\n```\n// 字符串\nthis.$router.push('home')\n// 对象\nthis.$router.push({ path: 'home' })\n// 命名的路由\nthis.$router.push({ name: 'user', params: { userId: 123 }})\n// 带查询参数，变成 /register?plan=private\nthis.$router.push({ path: 'register', query: { plan: 'private' }})\n```\n\n> 为什么能这么写呢，猜测是将router对象传递给Vue对象后，复制router对象为Vue.$router上了。还未在源码中求证，如有错误请指出，谢谢~\n\npush方法其实和`<router-link :to=\"...\">`的写法是等同的。\n**注意：**push方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。\n## router.replace\npush方法会向 history 栈添加一个新的记录，而replace方法是替换当前的页面，不会向 history 栈添加一个新的记录。用法如下\n**template**\n```\n<router-link to=\"/05\" replace>05</router-link>\n```\n**script**\n```\nthis.$router.replace({ path: '/05' })\n```\n## router.go\ngo方法用于控制history记录的前进和后退\n```\n// 在浏览器记录中前进一步，等同于 history.forward()\nthis.$router.go(1)\n// 后退一步记录，等同于 history.back()\nthis.$router.go(-1)\n// 前进 3 步记录router.go(3)\n// 如果 history 记录不够用，那就默默地失败呗\nthis.$router.go(-100)\nthis.$router.go(100)\n```\n其实很好理解：**go方法就是浏览器上的前进后退按钮，方法中传递的数字参数就是前进和后退的次数**\n# 四、路由的传参方式\n在路由跳转的过程中会传递一个object，我们可以通过`watch`方法查看路由信息对象。\n```\nwatch: {\n  '$route' (to, from) {\n      console.log(to);\n      console.log(from);\n  },\n},\n```\n**console中看到的路由信息对象**\n```\n{\n    ...\n    params: { id: '123' },\n    query: { name: 'jack' },\n    ...\n}\n```\n这两个参数会在页面跳转后写在路径中，路径相当于`/page/123?name=jack`\n## 1. params\nparams传递的数据可用于匹配动态路由字段。如params的数据为 `params: { abc: 'hello', txt: 'world' }` 而动态路由路径为 `path: '/05/:txt` 那么最终的路径就会是 `/05/world`。**所以，动态路由其实就是一种params的传递方式。**\n\n**注意：由于动态路由也是传递params的，所以在 `this.$router.push()` 方法中 path不能和params一起使用，否则params将无效！需要用name来指定页面。之后动态路由会从params中找到动态路由同名的数据。**\n\n### 传递数据\n在路由配置文件中定义参数\n```\n export default [\n    ...\n    { name: 'Page05', path: '/05/:txt', component: Page05 },\n]\n```\n下面有两种传递params的方式\n#### 1. 通过path传递\n路径后面的`/:txt`就是我们要传递的参数。\n```\nthis.$router.push({ path: '/05/441'})\n```\n此时路由跳转的路径\n```\nhttp://localhost:8080/#/05/441\n```\n此时我们看到查看路由信息对象：\n```\n{\n    ...\n    params: {\n        txt: '441'\n    }\n    ...\n}\n```\n#### 2. 通过params传递\n```\nthis.$router.replace({ \n    name: 'Page05', \n    params: { abc: 'hello', txt: 'world' }, \n    query: { name: 'query', type: 'object' }\n})\n```\n通过name获取页面，传递params和query。\n得到的URL为\n```\nhttp://localhost:8080/#/05/world?name=query&type=object\n```\n而获取到的参数为\n```\n{\n    ...\n    params: {\n        abc: \"hello\",\n        txt: \"world\"\n    }\n    ...\n}\n```\n### 获取数据\n**template**\n```\n<h2> {{ $route.params.txt }} </h2>\n```\n**script**\n```\nconsole.log(this.$route.params.txt)\n```\n## 2. query\nquery传递数据的方式就是URL常见的查询参数，如`/foo?user=1&name=2&age=3`。很好理解，下面就简单写一下用法以及结果\n### 传递数据\n**template**\n```\n<router-link :to=\"{ path: '/05', query: { name: 'query', type: 'object' }}\" replace>05</router-link>\n```\n**script**\n```\nthis.$router.replace({ path: '/05', query: { name: 'query', type: 'object' }})\n```\n**路径结果**\n```\nhttp://localhost:8080/#/05?name=query&type=object\n```\n**路由信息对象**\n```\n{\n    ...\n    query: {\n        name: \"query\",\n        type: \"object\"\n    }\n    ...\n}\n```\n### 获取数据\n获取数据和params是一样的。\n**template**\n```\n<h2> {{ $route.query.name }} </h2>\n```\n**script**\n```\nconsole.log(this.$route.query.type)\n```\n\n# Vue.js学习系列\n鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。\n\n[Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）](http://www.jianshu.com/p/8013d8d37bd0)\n[Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）](http://www.jianshu.com/p/d6f7e11f18af)\n[Vue.js学习系列三 —— axios和网络传输相关知识的学习实践](http://www.jianshu.com/p/8e5fb763c3d7)\n[Vue.js学习系列四 —— Webpack打包工具的使用](http://www.jianshu.com/p/aef34acd111f)\n[Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint](http://www.jianshu.com/p/efb6fbed6fac)\n[Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记](http://www.jianshu.com/p/073d25a3bba0)\n[Vue.js学习系列七 —— Vue服务器渲染Nuxt学习](https://www.jianshu.com/p/ba7466d7101a)\n[Vue.js学习系列八 —— Vue源码学习之State学习](https://www.jianshu.com/p/15028f91226e)\n\n# Vue.js学习系列项目地址\n本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。\n[https://github.com/violetjack/VueStudyDemos](https://github.com/violetjack/VueStudyDemos)\n\n# 关于作者\nVioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。\n欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。\n\n新浪微博： http://weibo.com/u/2640909603\n掘金：https://gold.xitu.io/user/571d953d39b0570068145cd1\nCSDN: http://blog.csdn.net/violetjack0808\n简书： http://www.jianshu.com/users/54ae4af3a98d/latest_articles\nGithub： https://github.com/violetjack","slug":"Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）","published":1,"updated":"2018-02-07T02:31:21.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjddwxbm30003i8btbcm40ktx","content":"<blockquote>\n<p>想学习Vue的SPA应用，路由这一块是必不可少的。相信很多和我一样刚接触前端的朋友对于路由这玩意是很困惑的。所以在我学习并成功使用了 <code>vue-router</code> 后，将我的个人经验分享出来，希望可以让同样对路由不知所措的同学有所帮助。</p>\n</blockquote>\n<h1 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h1><ul>\n<li><strong>本文demo的项目结构用的是最新的<a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"noopener\">命令行工具</a>创建的webpack项目模板</strong>；</li>\n<li>本文知识点是基于Vue2.0和vue-route 2的，更多内容请参考<a href=\"http://cn.vuejs.org/\" target=\"_blank\" rel=\"noopener\">Vue.js官网</a>和<a href=\"http://router.vuejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">vue-router 2官方文档</a>：</li>\n</ul>\n<h1 id=\"一、路由的安装：\"><a href=\"#一、路由的安装：\" class=\"headerlink\" title=\"一、路由的安装：\"></a>一、路由的安装：</h1><h2 id=\"npm安装\"><a href=\"#npm安装\" class=\"headerlink\" title=\"npm安装\"></a>npm安装</h2><p>可以使用npm直接安装插件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vue-router --save</span><br></pre></td></tr></table></figure></p>\n<p>执行命令完成vue-router的安装，并在package.json中添加了vue-router的依赖。当我们在其他电脑上安装项目时只需要执行 <code>npm install</code> 即可完成安装。</p>\n<p><strong>package.json</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;dependencies&quot;: &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &quot;vue-router&quot;: &quot;^2.1.1&quot;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>如果是要安装在开发环境下，则使用以下命令行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vue-router --save-dev</span><br></pre></td></tr></table></figure></p>\n<p><strong>package.json</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &quot;vue-router&quot;: &quot;^2.1.1&quot;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"二、SPA中路由的简单实现（附demo）\"><a href=\"#二、SPA中路由的简单实现（附demo）\" class=\"headerlink\" title=\"二、SPA中路由的简单实现（附demo）\"></a>二、SPA中路由的简单实现（附demo）</h1><p>下面让我们来配置路由并实现我们的第一次页面跳转。<br><a href=\"http://router.vuejs.org/zh-cn/essentials/getting-started.html\" target=\"_blank\" rel=\"noopener\">官方提供的demo</a>很简单，复制到HTML中也的确能跑，但是问题是不知道如何在SPA应用中使用，这坑了我不少时间。在看了不少他人的项目后，完成了SPA路由的简单实现demo（基于vue-cli的webpack模板）。<br><strong>main.js</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\">import App from &apos;./App&apos;</span><br><span class=\"line\">import VueRouter from &apos;vue-router&apos;</span><br><span class=\"line\">import Page01 from &apos;./components/page01&apos;</span><br><span class=\"line\">import Page02 from &apos;./components/page02&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(VueRouter)//全局安装路由功能</span><br><span class=\"line\">//定义路径</span><br><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123; path: &apos;/&apos;, component: Page01 &#125;,</span><br><span class=\"line\">  &#123; path: &apos;/02&apos;, component: Page02 &#125;,</span><br><span class=\"line\">]</span><br><span class=\"line\">//创建路由对象</span><br><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  routes</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#app&apos;,</span><br><span class=\"line\">  template: &apos;&lt;App/&gt;&apos;,</span><br><span class=\"line\">  components: &#123; App &#125;,</span><br><span class=\"line\">  router</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>App.vue</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;router-link to=&quot;/&quot;&gt;01&lt;/router-link&gt;</span><br><span class=\"line\">    &lt;router-link to=&quot;/02&quot;&gt;02&lt;/router-link&gt;</span><br><span class=\"line\">    &lt;br/&gt;</span><br><span class=\"line\">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>page01.vue</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;h1&gt;page02&lt;/h1&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>page02.vue</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;h1&gt;page02&lt;/h1&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>\n<p>实现步骤：</p>\n<ol>\n<li><code>npm</code>安装<code>vue-router</code></li>\n<li><code>Vue.use(VueRouter)</code>全局安装路由功能</li>\n<li>定义路径数组<code>routes</code>并创建路由对象<code>router</code></li>\n<li>将<code>router</code>对象传到Vue对象中</li>\n<li>在根组件中使用<code>&lt;router-link&gt;</code>定义跳转路径</li>\n<li>在根组件中使用<code>&lt;router-view&gt;</code>来渲染组件</li>\n<li>创建子组件</li>\n</ol>\n<h1 id=\"三、路由的跳转\"><a href=\"#三、路由的跳转\" class=\"headerlink\" title=\"三、路由的跳转\"></a>三、路由的跳转</h1><h2 id=\"router-link\"><a href=\"#router-link\" class=\"headerlink\" title=\"router-link\"></a>router-link</h2><p><code>router-link</code>标签用于页面的跳转，简单用法我们刚才提到过了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link to=&quot;/page01&quot;&gt;page01&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p>\n<p>点击这个<code>router-link</code>标签<code>router-view</code>就会渲染路径为<code>/page01</code>的页面。<br><strong>注意：</strong><code>router-link</code>默认是一个<code>&lt;a&gt;</code>标签的形式，如果需要显示不同的样子，可以在<code>router-link</code>标签中写入不同标签元素，如下显示为<code>button</code>按钮。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link to=&quot;/04&quot;&gt;</span><br><span class=\"line\">    &lt;button&gt;to04&lt;/button&gt;</span><br><span class=\"line\">&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"router-push\"><a href=\"#router-push\" class=\"headerlink\" title=\"router.push\"></a>router.push</h2><p>下面我们通过JS代码控制路由的界面渲染，官方文档写法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 字符串</span><br><span class=\"line\">router.push(&apos;home&apos;)</span><br><span class=\"line\">// 对象</span><br><span class=\"line\">router.push(&#123; path: &apos;home&apos; &#125;)</span><br><span class=\"line\">// 命名的路由</span><br><span class=\"line\">router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;)</span><br><span class=\"line\">// 带查询参数，变成 /register?plan=private</span><br><span class=\"line\">router.push(&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>那么问题来了，如果是全局注册的路由<code>Vue.use(VueRouter)</code>，应该怎么写呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 字符串</span><br><span class=\"line\">this.$router.push(&apos;home&apos;)</span><br><span class=\"line\">// 对象</span><br><span class=\"line\">this.$router.push(&#123; path: &apos;home&apos; &#125;)</span><br><span class=\"line\">// 命名的路由</span><br><span class=\"line\">this.$router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;)</span><br><span class=\"line\">// 带查询参数，变成 /register?plan=private</span><br><span class=\"line\">this.$router.push(&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;)</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>为什么能这么写呢，猜测是将router对象传递给Vue对象后，复制router对象为Vue.$router上了。还未在源码中求证，如有错误请指出，谢谢~</p>\n</blockquote>\n<p>push方法其实和<code>&lt;router-link :to=&quot;...&quot;&gt;</code>的写法是等同的。<br><strong>注意：</strong>push方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。</p>\n<h2 id=\"router-replace\"><a href=\"#router-replace\" class=\"headerlink\" title=\"router.replace\"></a>router.replace</h2><p>push方法会向 history 栈添加一个新的记录，而replace方法是替换当前的页面，不会向 history 栈添加一个新的记录。用法如下<br><strong>template</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link to=&quot;/05&quot; replace&gt;05&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>script</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$router.replace(&#123; path: &apos;/05&apos; &#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"router-go\"><a href=\"#router-go\" class=\"headerlink\" title=\"router.go\"></a>router.go</h2><p>go方法用于控制history记录的前进和后退<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在浏览器记录中前进一步，等同于 history.forward()</span><br><span class=\"line\">this.$router.go(1)</span><br><span class=\"line\">// 后退一步记录，等同于 history.back()</span><br><span class=\"line\">this.$router.go(-1)</span><br><span class=\"line\">// 前进 3 步记录router.go(3)</span><br><span class=\"line\">// 如果 history 记录不够用，那就默默地失败呗</span><br><span class=\"line\">this.$router.go(-100)</span><br><span class=\"line\">this.$router.go(100)</span><br></pre></td></tr></table></figure></p>\n<p>其实很好理解：<strong>go方法就是浏览器上的前进后退按钮，方法中传递的数字参数就是前进和后退的次数</strong></p>\n<h1 id=\"四、路由的传参方式\"><a href=\"#四、路由的传参方式\" class=\"headerlink\" title=\"四、路由的传参方式\"></a>四、路由的传参方式</h1><p>在路由跳转的过程中会传递一个object，我们可以通过<code>watch</code>方法查看路由信息对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch: &#123;</span><br><span class=\"line\">  &apos;$route&apos; (to, from) &#123;</span><br><span class=\"line\">      console.log(to);</span><br><span class=\"line\">      console.log(from);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p><strong>console中看到的路由信息对象</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    params: &#123; id: &apos;123&apos; &#125;,</span><br><span class=\"line\">    query: &#123; name: &apos;jack&apos; &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这两个参数会在页面跳转后写在路径中，路径相当于<code>/page/123?name=jack</code></p>\n<h2 id=\"1-params\"><a href=\"#1-params\" class=\"headerlink\" title=\"1. params\"></a>1. params</h2><p>params传递的数据可用于匹配动态路由字段。如params的数据为 <code>params: { abc: &#39;hello&#39;, txt: &#39;world&#39; }</code> 而动态路由路径为 <code>path: &#39;/05/:txt</code> 那么最终的路径就会是 <code>/05/world</code>。<strong>所以，动态路由其实就是一种params的传递方式。</strong></p>\n<p><strong>注意：由于动态路由也是传递params的，所以在 <code>this.$router.push()</code> 方法中 path不能和params一起使用，否则params将无效！需要用name来指定页面。之后动态路由会从params中找到动态路由同名的数据。</strong></p>\n<h3 id=\"传递数据\"><a href=\"#传递数据\" class=\"headerlink\" title=\"传递数据\"></a>传递数据</h3><p>在路由配置文件中定义参数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> export default [</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &#123; name: &apos;Page05&apos;, path: &apos;/05/:txt&apos;, component: Page05 &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>下面有两种传递params的方式</p>\n<h4 id=\"1-通过path传递\"><a href=\"#1-通过path传递\" class=\"headerlink\" title=\"1. 通过path传递\"></a>1. 通过path传递</h4><p>路径后面的<code>/:txt</code>就是我们要传递的参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$router.push(&#123; path: &apos;/05/441&apos;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>此时路由跳转的路径<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080/#/05/441</span><br></pre></td></tr></table></figure></p>\n<p>此时我们看到查看路由信息对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">        txt: &apos;441&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-通过params传递\"><a href=\"#2-通过params传递\" class=\"headerlink\" title=\"2. 通过params传递\"></a>2. 通过params传递</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$router.replace(&#123; </span><br><span class=\"line\">    name: &apos;Page05&apos;, </span><br><span class=\"line\">    params: &#123; abc: &apos;hello&apos;, txt: &apos;world&apos; &#125;, </span><br><span class=\"line\">    query: &#123; name: &apos;query&apos;, type: &apos;object&apos; &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>通过name获取页面，传递params和query。<br>得到的URL为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080/#/05/world?name=query&amp;type=object</span><br></pre></td></tr></table></figure></p>\n<p>而获取到的参数为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">        abc: &quot;hello&quot;,</span><br><span class=\"line\">        txt: &quot;world&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"获取数据\"><a href=\"#获取数据\" class=\"headerlink\" title=\"获取数据\"></a>获取数据</h3><p><strong>template</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2&gt; &#123;&#123; $route.params.txt &#125;&#125; &lt;/h2&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>script</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(this.$route.params.txt)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-query\"><a href=\"#2-query\" class=\"headerlink\" title=\"2. query\"></a>2. query</h2><p>query传递数据的方式就是URL常见的查询参数，如<code>/foo?user=1&amp;name=2&amp;age=3</code>。很好理解，下面就简单写一下用法以及结果</p>\n<h3 id=\"传递数据-1\"><a href=\"#传递数据-1\" class=\"headerlink\" title=\"传递数据\"></a>传递数据</h3><p><strong>template</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link :to=&quot;&#123; path: &apos;/05&apos;, query: &#123; name: &apos;query&apos;, type: &apos;object&apos; &#125;&#125;&quot; replace&gt;05&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>script</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$router.replace(&#123; path: &apos;/05&apos;, query: &#123; name: &apos;query&apos;, type: &apos;object&apos; &#125;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>路径结果</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080/#/05?name=query&amp;type=object</span><br></pre></td></tr></table></figure></p>\n<p><strong>路由信息对象</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    query: &#123;</span><br><span class=\"line\">        name: &quot;query&quot;,</span><br><span class=\"line\">        type: &quot;object&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"获取数据-1\"><a href=\"#获取数据-1\" class=\"headerlink\" title=\"获取数据\"></a>获取数据</h3><p>获取数据和params是一样的。<br><strong>template</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2&gt; &#123;&#123; $route.query.name &#125;&#125; &lt;/h2&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>script</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(this.$route.query.type)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Vue-js学习系列\"><a href=\"#Vue-js学习系列\" class=\"headerlink\" title=\"Vue.js学习系列\"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>\n<p><a href=\"http://www.jianshu.com/p/8013d8d37bd0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/d6f7e11f18af\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/8e5fb763c3d7\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href=\"http://www.jianshu.com/p/aef34acd111f\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href=\"http://www.jianshu.com/p/efb6fbed6fac\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href=\"http://www.jianshu.com/p/073d25a3bba0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href=\"https://www.jianshu.com/p/ba7466d7101a\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href=\"https://www.jianshu.com/p/15028f91226e\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>\n<h1 id=\"Vue-js学习系列项目地址\"><a href=\"#Vue-js学习系列项目地址\" class=\"headerlink\" title=\"Vue.js学习系列项目地址\"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack/VueStudyDemos</a></p>\n<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>\n<p>新浪微博： <a href=\"http://weibo.com/u/2640909603\" target=\"_blank\" rel=\"noopener\">http://weibo.com/u/2640909603</a><br>掘金：<a href=\"https://gold.xitu.io/user/571d953d39b0570068145cd1\" target=\"_blank\" rel=\"noopener\">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href=\"http://blog.csdn.net/violetjack0808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/violetjack0808</a><br>简书： <a href=\"http://www.jianshu.com/users/54ae4af3a98d/latest_articles\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href=\"https://github.com/violetjack\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>想学习Vue的SPA应用，路由这一块是必不可少的。相信很多和我一样刚接触前端的朋友对于路由这玩意是很困惑的。所以在我学习并成功使用了 <code>vue-router</code> 后，将我的个人经验分享出来，希望可以让同样对路由不知所措的同学有所帮助。</p>\n</blockquote>\n<h1 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h1><ul>\n<li><strong>本文demo的项目结构用的是最新的<a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"noopener\">命令行工具</a>创建的webpack项目模板</strong>；</li>\n<li>本文知识点是基于Vue2.0和vue-route 2的，更多内容请参考<a href=\"http://cn.vuejs.org/\" target=\"_blank\" rel=\"noopener\">Vue.js官网</a>和<a href=\"http://router.vuejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">vue-router 2官方文档</a>：</li>\n</ul>\n<h1 id=\"一、路由的安装：\"><a href=\"#一、路由的安装：\" class=\"headerlink\" title=\"一、路由的安装：\"></a>一、路由的安装：</h1><h2 id=\"npm安装\"><a href=\"#npm安装\" class=\"headerlink\" title=\"npm安装\"></a>npm安装</h2><p>可以使用npm直接安装插件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vue-router --save</span><br></pre></td></tr></table></figure></p>\n<p>执行命令完成vue-router的安装，并在package.json中添加了vue-router的依赖。当我们在其他电脑上安装项目时只需要执行 <code>npm install</code> 即可完成安装。</p>\n<p><strong>package.json</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;dependencies&quot;: &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &quot;vue-router&quot;: &quot;^2.1.1&quot;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>如果是要安装在开发环境下，则使用以下命令行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vue-router --save-dev</span><br></pre></td></tr></table></figure></p>\n<p><strong>package.json</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &quot;vue-router&quot;: &quot;^2.1.1&quot;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"二、SPA中路由的简单实现（附demo）\"><a href=\"#二、SPA中路由的简单实现（附demo）\" class=\"headerlink\" title=\"二、SPA中路由的简单实现（附demo）\"></a>二、SPA中路由的简单实现（附demo）</h1><p>下面让我们来配置路由并实现我们的第一次页面跳转。<br><a href=\"http://router.vuejs.org/zh-cn/essentials/getting-started.html\" target=\"_blank\" rel=\"noopener\">官方提供的demo</a>很简单，复制到HTML中也的确能跑，但是问题是不知道如何在SPA应用中使用，这坑了我不少时间。在看了不少他人的项目后，完成了SPA路由的简单实现demo（基于vue-cli的webpack模板）。<br><strong>main.js</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\">import App from &apos;./App&apos;</span><br><span class=\"line\">import VueRouter from &apos;vue-router&apos;</span><br><span class=\"line\">import Page01 from &apos;./components/page01&apos;</span><br><span class=\"line\">import Page02 from &apos;./components/page02&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(VueRouter)//全局安装路由功能</span><br><span class=\"line\">//定义路径</span><br><span class=\"line\">const routes = [</span><br><span class=\"line\">  &#123; path: &apos;/&apos;, component: Page01 &#125;,</span><br><span class=\"line\">  &#123; path: &apos;/02&apos;, component: Page02 &#125;,</span><br><span class=\"line\">]</span><br><span class=\"line\">//创建路由对象</span><br><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  routes</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#app&apos;,</span><br><span class=\"line\">  template: &apos;&lt;App/&gt;&apos;,</span><br><span class=\"line\">  components: &#123; App &#125;,</span><br><span class=\"line\">  router</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>App.vue</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;router-link to=&quot;/&quot;&gt;01&lt;/router-link&gt;</span><br><span class=\"line\">    &lt;router-link to=&quot;/02&quot;&gt;02&lt;/router-link&gt;</span><br><span class=\"line\">    &lt;br/&gt;</span><br><span class=\"line\">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>page01.vue</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;h1&gt;page02&lt;/h1&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>page02.vue</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;h1&gt;page02&lt;/h1&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>\n<p>实现步骤：</p>\n<ol>\n<li><code>npm</code>安装<code>vue-router</code></li>\n<li><code>Vue.use(VueRouter)</code>全局安装路由功能</li>\n<li>定义路径数组<code>routes</code>并创建路由对象<code>router</code></li>\n<li>将<code>router</code>对象传到Vue对象中</li>\n<li>在根组件中使用<code>&lt;router-link&gt;</code>定义跳转路径</li>\n<li>在根组件中使用<code>&lt;router-view&gt;</code>来渲染组件</li>\n<li>创建子组件</li>\n</ol>\n<h1 id=\"三、路由的跳转\"><a href=\"#三、路由的跳转\" class=\"headerlink\" title=\"三、路由的跳转\"></a>三、路由的跳转</h1><h2 id=\"router-link\"><a href=\"#router-link\" class=\"headerlink\" title=\"router-link\"></a>router-link</h2><p><code>router-link</code>标签用于页面的跳转，简单用法我们刚才提到过了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link to=&quot;/page01&quot;&gt;page01&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p>\n<p>点击这个<code>router-link</code>标签<code>router-view</code>就会渲染路径为<code>/page01</code>的页面。<br><strong>注意：</strong><code>router-link</code>默认是一个<code>&lt;a&gt;</code>标签的形式，如果需要显示不同的样子，可以在<code>router-link</code>标签中写入不同标签元素，如下显示为<code>button</code>按钮。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link to=&quot;/04&quot;&gt;</span><br><span class=\"line\">    &lt;button&gt;to04&lt;/button&gt;</span><br><span class=\"line\">&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"router-push\"><a href=\"#router-push\" class=\"headerlink\" title=\"router.push\"></a>router.push</h2><p>下面我们通过JS代码控制路由的界面渲染，官方文档写法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 字符串</span><br><span class=\"line\">router.push(&apos;home&apos;)</span><br><span class=\"line\">// 对象</span><br><span class=\"line\">router.push(&#123; path: &apos;home&apos; &#125;)</span><br><span class=\"line\">// 命名的路由</span><br><span class=\"line\">router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;)</span><br><span class=\"line\">// 带查询参数，变成 /register?plan=private</span><br><span class=\"line\">router.push(&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>那么问题来了，如果是全局注册的路由<code>Vue.use(VueRouter)</code>，应该怎么写呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 字符串</span><br><span class=\"line\">this.$router.push(&apos;home&apos;)</span><br><span class=\"line\">// 对象</span><br><span class=\"line\">this.$router.push(&#123; path: &apos;home&apos; &#125;)</span><br><span class=\"line\">// 命名的路由</span><br><span class=\"line\">this.$router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;)</span><br><span class=\"line\">// 带查询参数，变成 /register?plan=private</span><br><span class=\"line\">this.$router.push(&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;)</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>为什么能这么写呢，猜测是将router对象传递给Vue对象后，复制router对象为Vue.$router上了。还未在源码中求证，如有错误请指出，谢谢~</p>\n</blockquote>\n<p>push方法其实和<code>&lt;router-link :to=&quot;...&quot;&gt;</code>的写法是等同的。<br><strong>注意：</strong>push方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。</p>\n<h2 id=\"router-replace\"><a href=\"#router-replace\" class=\"headerlink\" title=\"router.replace\"></a>router.replace</h2><p>push方法会向 history 栈添加一个新的记录，而replace方法是替换当前的页面，不会向 history 栈添加一个新的记录。用法如下<br><strong>template</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link to=&quot;/05&quot; replace&gt;05&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>script</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$router.replace(&#123; path: &apos;/05&apos; &#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"router-go\"><a href=\"#router-go\" class=\"headerlink\" title=\"router.go\"></a>router.go</h2><p>go方法用于控制history记录的前进和后退<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在浏览器记录中前进一步，等同于 history.forward()</span><br><span class=\"line\">this.$router.go(1)</span><br><span class=\"line\">// 后退一步记录，等同于 history.back()</span><br><span class=\"line\">this.$router.go(-1)</span><br><span class=\"line\">// 前进 3 步记录router.go(3)</span><br><span class=\"line\">// 如果 history 记录不够用，那就默默地失败呗</span><br><span class=\"line\">this.$router.go(-100)</span><br><span class=\"line\">this.$router.go(100)</span><br></pre></td></tr></table></figure></p>\n<p>其实很好理解：<strong>go方法就是浏览器上的前进后退按钮，方法中传递的数字参数就是前进和后退的次数</strong></p>\n<h1 id=\"四、路由的传参方式\"><a href=\"#四、路由的传参方式\" class=\"headerlink\" title=\"四、路由的传参方式\"></a>四、路由的传参方式</h1><p>在路由跳转的过程中会传递一个object，我们可以通过<code>watch</code>方法查看路由信息对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch: &#123;</span><br><span class=\"line\">  &apos;$route&apos; (to, from) &#123;</span><br><span class=\"line\">      console.log(to);</span><br><span class=\"line\">      console.log(from);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p><strong>console中看到的路由信息对象</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    params: &#123; id: &apos;123&apos; &#125;,</span><br><span class=\"line\">    query: &#123; name: &apos;jack&apos; &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这两个参数会在页面跳转后写在路径中，路径相当于<code>/page/123?name=jack</code></p>\n<h2 id=\"1-params\"><a href=\"#1-params\" class=\"headerlink\" title=\"1. params\"></a>1. params</h2><p>params传递的数据可用于匹配动态路由字段。如params的数据为 <code>params: { abc: &#39;hello&#39;, txt: &#39;world&#39; }</code> 而动态路由路径为 <code>path: &#39;/05/:txt</code> 那么最终的路径就会是 <code>/05/world</code>。<strong>所以，动态路由其实就是一种params的传递方式。</strong></p>\n<p><strong>注意：由于动态路由也是传递params的，所以在 <code>this.$router.push()</code> 方法中 path不能和params一起使用，否则params将无效！需要用name来指定页面。之后动态路由会从params中找到动态路由同名的数据。</strong></p>\n<h3 id=\"传递数据\"><a href=\"#传递数据\" class=\"headerlink\" title=\"传递数据\"></a>传递数据</h3><p>在路由配置文件中定义参数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> export default [</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    &#123; name: &apos;Page05&apos;, path: &apos;/05/:txt&apos;, component: Page05 &#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>下面有两种传递params的方式</p>\n<h4 id=\"1-通过path传递\"><a href=\"#1-通过path传递\" class=\"headerlink\" title=\"1. 通过path传递\"></a>1. 通过path传递</h4><p>路径后面的<code>/:txt</code>就是我们要传递的参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$router.push(&#123; path: &apos;/05/441&apos;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>此时路由跳转的路径<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080/#/05/441</span><br></pre></td></tr></table></figure></p>\n<p>此时我们看到查看路由信息对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">        txt: &apos;441&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-通过params传递\"><a href=\"#2-通过params传递\" class=\"headerlink\" title=\"2. 通过params传递\"></a>2. 通过params传递</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$router.replace(&#123; </span><br><span class=\"line\">    name: &apos;Page05&apos;, </span><br><span class=\"line\">    params: &#123; abc: &apos;hello&apos;, txt: &apos;world&apos; &#125;, </span><br><span class=\"line\">    query: &#123; name: &apos;query&apos;, type: &apos;object&apos; &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>通过name获取页面，传递params和query。<br>得到的URL为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080/#/05/world?name=query&amp;type=object</span><br></pre></td></tr></table></figure></p>\n<p>而获取到的参数为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">        abc: &quot;hello&quot;,</span><br><span class=\"line\">        txt: &quot;world&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"获取数据\"><a href=\"#获取数据\" class=\"headerlink\" title=\"获取数据\"></a>获取数据</h3><p><strong>template</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2&gt; &#123;&#123; $route.params.txt &#125;&#125; &lt;/h2&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>script</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(this.$route.params.txt)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-query\"><a href=\"#2-query\" class=\"headerlink\" title=\"2. query\"></a>2. query</h2><p>query传递数据的方式就是URL常见的查询参数，如<code>/foo?user=1&amp;name=2&amp;age=3</code>。很好理解，下面就简单写一下用法以及结果</p>\n<h3 id=\"传递数据-1\"><a href=\"#传递数据-1\" class=\"headerlink\" title=\"传递数据\"></a>传递数据</h3><p><strong>template</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-link :to=&quot;&#123; path: &apos;/05&apos;, query: &#123; name: &apos;query&apos;, type: &apos;object&apos; &#125;&#125;&quot; replace&gt;05&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>script</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$router.replace(&#123; path: &apos;/05&apos;, query: &#123; name: &apos;query&apos;, type: &apos;object&apos; &#125;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>路径结果</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080/#/05?name=query&amp;type=object</span><br></pre></td></tr></table></figure></p>\n<p><strong>路由信息对象</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    query: &#123;</span><br><span class=\"line\">        name: &quot;query&quot;,</span><br><span class=\"line\">        type: &quot;object&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"获取数据-1\"><a href=\"#获取数据-1\" class=\"headerlink\" title=\"获取数据\"></a>获取数据</h3><p>获取数据和params是一样的。<br><strong>template</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h2&gt; &#123;&#123; $route.query.name &#125;&#125; &lt;/h2&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>script</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(this.$route.query.type)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Vue-js学习系列\"><a href=\"#Vue-js学习系列\" class=\"headerlink\" title=\"Vue.js学习系列\"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>\n<p><a href=\"http://www.jianshu.com/p/8013d8d37bd0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/d6f7e11f18af\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/8e5fb763c3d7\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href=\"http://www.jianshu.com/p/aef34acd111f\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href=\"http://www.jianshu.com/p/efb6fbed6fac\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href=\"http://www.jianshu.com/p/073d25a3bba0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href=\"https://www.jianshu.com/p/ba7466d7101a\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href=\"https://www.jianshu.com/p/15028f91226e\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>\n<h1 id=\"Vue-js学习系列项目地址\"><a href=\"#Vue-js学习系列项目地址\" class=\"headerlink\" title=\"Vue.js学习系列项目地址\"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack/VueStudyDemos</a></p>\n<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>\n<p>新浪微博： <a href=\"http://weibo.com/u/2640909603\" target=\"_blank\" rel=\"noopener\">http://weibo.com/u/2640909603</a><br>掘金：<a href=\"https://gold.xitu.io/user/571d953d39b0570068145cd1\" target=\"_blank\" rel=\"noopener\">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href=\"http://blog.csdn.net/violetjack0808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/violetjack0808</a><br>简书： <a href=\"http://www.jianshu.com/users/54ae4af3a98d/latest_articles\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href=\"https://github.com/violetjack\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack</a></p>\n"},{"title":"Vue.js学习系列七 —— Vue服务器渲染Nuxt学习","date":"2018-01-25T16:00:00.000Z","_content":"\n> 我又回来啦~这次我们来学习Vue的服务器渲染SSR。\n\n关于SSR的文章网上很多，一开始看得我云里雾里。然后去[Vue.js 服务器渲染指南](https://ssr.vuejs.org/zh/)和[nuxt官网](https://zh.nuxtjs.org/guide)看了看，发现文章大多都是搬运官网的内容，真正讲的清晰明了的很少。所以想写篇文章学习下SSR，希望能够帮助大家快速理解Vue SSR。\n\n# 什么是SSR？\nSSR，即服务器渲染，就是在服务器端将对Vue页面进行渲染生成html文件，将html页面传给浏览器。\n优点：\n* SEO 不同于SPA的HTML只有一个无实际内容的HTML和一个app.js，SSR生成的HTML是有内容的，这让搜索引擎能够索引到页面内容。\n* 更快内容到达时间 传统的SPA应用是将bundle.js从服务器获取，然后在客户端解析并挂载到dom。而SSR直接将HTML字符串传递给浏览器。大大加快了首屏加载时间。\n\n可以从下面两张图来看，第一张图是SSR生成的HTML页面，第二种是传统SPA生成的HTML页面。\n![SSR](http://upload-images.jianshu.io/upload_images/1987062-744de5a6489440da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![SPA](http://upload-images.jianshu.io/upload_images/1987062-1b940fb15ba7fbd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# Nuxt.js\n我看了官方 SSR 的介绍，也看了 Nuxt.js 的文档。本质上来说 SSR 是node后端的操作行为，作为只想好好写前端代码的我，不想太折腾。而 Nuxt.js 非常完美地整合了 SSR 的功能。让我们可以开箱即用~官方也推荐使用 Nuxt.js 来搭建 SSR 项目。\n\n## 好处\n我觉得  Nuxt.js  相比自己写 SSR 有几点好处。\n* 无需配置Webpack：我一开始还在找Webpack配置呢，看了文档知道nuxt都帮我们封装好了。如需修改Webpack配置只需修改nuxt.config.js 文件。\n* 无需node知识：只要你会写vue前端，你就可以写出SSR。无需知道SSR和node、express的配置方法（不过现在的前端多少都会点node知识~）。\n* 整合了vue全家桶，直接可用。方便程度不亚于 `vue-cli`：安装Nuxt——写组件——编译并启动服务———看效果。就这么简单。\n* 配置简单，文档友好：认真看下 Nuxt.js 文档就会发现涵盖的内容并不多，而功能很全，非常适合入手。\n\n## 安装\n安装方法[在此](https://zh.nuxtjs.org/guide/installation)。很简单，生成模板，然后npm安装依赖，最后再运行。\n简单搬运下步骤吧。\n```\n// vue-cli 创建nuxt模板项目\n$ vue init nuxt-community/starter-template <project-name>\n// 安装依赖项\n$ cd <project-name>\n$ npm install\n// 编译并启动服务\n$ npm run dev\n// 打开 http://localhost:3000\n```\n**安装遇到的问题：**\n由于 Nuxt.js 中使用了 `async...await` 语法，而低版本的 node 不支持这个语法，所以必须升级 node 到 **7.0** 版本之上~\n然后建议不要使用cnpm，我用cnpm安装运行老报错，感觉有坑。\n\n## 目录结构\nNuxt.js 花了很大的篇幅讲它的目录结构，其实了解了目录结构就了解了 Nuxt.js 的大概。Nuxt.js 帮我们配置好了所有东西，我们只需要按照它的要求在相应目录下创建文件写代码即可。\n\n* assets 需要编译的资源文件，如 JavaScript、SASS、LESS 等。\n* static 不需要编译的静态资源文件，如图片资源。\n* components 顾名思义，存放 `*.vue` 组件的地方。常规 vue 组件写法。\n* layouts 布局目录，设置布局的地方，其中 `<nuxt/>` 标签是我们写的页面内容。可用作添加导航栏、底部栏等截面。\n* middleware 中间件目录，所谓中间件，就是在页面与页面跳转中执行的函数方法。如页面跳转时验证用户信息操作。\n* pages 页面目录。重点来了~这就是我们存放展示页面的地方。该目录下的文件会转换成相应的路由路径供浏览器访问。另外呢，该目录下的 `*.vue` 页面文件中  Nuxt.js 提供了一些特殊的方法用于处理服务器渲染中的事件。具体关于路由和特殊方法列举在下面了。\n  * [pages 路由](https://zh.nuxtjs.org/guide/routing)\n  * [页面组件](https://zh.nuxtjs.org/guide/views#页面)的简单介绍，具体特殊配置项的用法请查阅[API](https://zh.nuxtjs.org/api)。\n* plugins 插件目录，像 mint-ui 这种第三方插件就放在这里啦~具体用法[看这里](https://zh.nuxtjs.org/guide/plugins)。\n* store vuex 状态管理器目录，如果该目录是空的， Nuxt.js 将不启用 vuex。当我们在该文件夹下创建 index.js 文件后即可使用 vuex 状态管理器。用法[在此](https://zh.nuxtjs.org/guide/vuex-store)！\n* nuxt.config.js 该文件是 Nuxt.js 的唯一配置项，之前提过 Nuxt.js 将 Webpack 等一众配置都封装好了，所以如果需要特殊配置，只需要修改该文件来覆盖默认配置即可。具体配置参数请查阅[API](https://zh.nuxtjs.org/api)。\n* package.json 不解释……\n\n# Demo演示\n好消息，[VueStudyDemos](https://github.com/violetjack/VueStudyDemos)又更新啦！欢迎Star~[本文Demo](https://github.com/violetjack/VueStudyDemos/tree/master/NuxtDemo)已收入到VueStudyDemos中。\n下面我们来简单实现下各文件夹所提到的功能。\n\n## 资源加载\n我在 assets 文件夹下添加了 font-awesome 字体库，在 static 文件夹中放了张 Vue 的 logo 图片。然后对资源进行调用。\n```\n<i class=\"fa fa-address-book\" aria-hidden=\"true\"></i>\n<img src=\"~/static/logo.png\" />\n```\n这里需要将 font-awesome 的 css 变为全局 css，避免每个用到的页面中都 import 字体库的css。所以我们在 nuxt.config.js 中添加如下配置。\n```\nmodule.exports = {\n  ...\n  css: [\n    '~/assets/font-awesome/css/font-awesome.min.css'\n  ],\n  ...\n}\n\n```\n## 组件定义\n组件存放在 components 文件夹下，这个我们讲目录的时候提到过。组件的用法和常用 vue 组件用法一致。\n定义组件 Avatar，然后在 Page 页面中使用。\n```\n<template>\n  <avatar/>\n</template>\n<script>\nimport avatar from '~/components/Avatar'\nexport default {\n    ...\n    components: {\n        avatar\n    }\n};\n</script>\n```\n## 布局\n在 layouts 目录中，default 是默认布局。我们可以修改默认布局也可以新建布局来使用。\n在布局文件中 `</nuxt>` 标签是我们要服务器渲染的区域。\n下面我们来创建个布局玩玩。\n```\n// layouts/page.vue\n<template>\n<div>\n    <mt-header fixed title=\"标题2\"></mt-header>\n    <nuxt/>\n</div>\n</template>\n```\n然后我们来使用布局，在 pages 页面中配置 layout 选项（如果不配置默认就是 `default`）。\n```\nexport default {\n    ...\n    layout: 'page'  // 默认是 'default'\n};\n```\n## 中间件\n所谓中间件，就是在两个页面跳转之间执行的行为。比如我定义一个中间件 add.js\n```\nexport default function ({ store }) {\n    store.commit('increment')\n}\n```\n然后在 nuxt.config.js 中进行配置：\n```\nmodule.exports = {\n  ...\n  router: {\n    middleware: 'add'\n  },\n  ...\n}\n\n```\n这样，在每次页面跳转的时候都会执行一次中间件方法了。当然，也可以单独定义某个页面的中间件，具体看官网啦~\n\n## 页面\n页面，就是在pages目录下的 `*.vue` 文件，Nuxt.js 将目录结构配置为 vue-router 路由系统，所以我们可以直接通过文件名来访问到相应页面（先不提特殊路由）。\n比如 `pages/app.vue` 文件就可以通过 `http://localhost:3000/app` 来进行访问。\n注意：页面组件写法与常用 Vue 组件写法相同，但 Nuxt.js 还提供了一些特殊配置项来配置服务器渲染过程中的行为。具体有啥配置请看[页面文档](https://zh.nuxtjs.org/guide/views#页面)。\n\n## 路由\n路由就是使 pages 目录能够直接访问的原因。Nuxt.js 非常巧妙地使用目录结构和文件名称将 vue-router 的各种用法都涵盖进去了。如动态路由、嵌套路由等。具体可参考[文档](https://zh.nuxtjs.org/guide/routing)。也可以看看demo的 [pages](https://github.com/violetjack/VueStudyDemos/tree/master/NuxtDemo/pages) 目录。\n\n## 插件\n对于前端项目，插件的使用当然是必不可少的。官网上对这方面讲的很清楚。我贴一下 demo 中的用法。这里用的是 mint-ui 库。\n```\n// plugins/mint-ui.js\nimport Vue from 'vue'\nimport MintUI from 'mint-ui'\nimport 'mint-ui/lib/style.css'\n\nVue.use(MintUI)\n```\n```\n// nuxt.config.js\nmodule.exports = {\n  build: {\n    vendor: ['mint-ui']\n  },\n  plugins: [\n    '~plugins/mint-ui'\n  ]\n}\n```\n这样就可以使用第三方库 mint-ui 啦！\n```\n<template>\n  <div>\n    <mt-navbar v-model=\"selected\">\n        <mt-tab-item id=\"1\">选项一</mt-tab-item>\n        <mt-tab-item id=\"2\">选项二</mt-tab-item>\n        <mt-tab-item id=\"3\">选项三</mt-tab-item>\n    </mt-navbar>\n\n    <!-- tab-container -->\n    <mt-tab-container v-model=\"selected\">\n        <mt-tab-container-item id=\"1\">\n            <mt-cell v-for=\"n in 10\" :key=\"n\" :title=\"'内容 ' + n\" />\n        </mt-tab-container-item>\n        <mt-tab-container-item id=\"2\">\n            <mt-cell v-for=\"n in 4\" :key=\"n\" :title=\"'测试 ' + n\" />\n        </mt-tab-container-item>\n        <mt-tab-container-item id=\"3\">\n            <mt-cell v-for=\"n in 6\" :key=\"n\" :title=\"'选项 ' + n\" />\n        </mt-tab-container-item>\n    </mt-tab-container>\n  </div>\n</template>\n```\n## vuex\n对于 vuex，用法有两种：[普通方式](https://zh.nuxtjs.org/guide/vuex-store#普通方式)和[模块方式](https://zh.nuxtjs.org/guide/vuex-store#模块方式)，用法和我们常用的 vuex 一样。我的demo中是直接复制官网的代码。\n需要注意的是，vuex 的数据会存在[context对象](https://zh.nuxtjs.org/api/#上下文对象)中，我们可以通过context对象获取状态数据。\n# 发布\n发布有两种方式服务器应用渲染部署和静态部署，发布方式[看这里](https://zh.nuxtjs.org/guide/commands#发布部署)\n\n# 最后\n去看 Nuxt.js 的 [API](https://zh.nuxtjs.org/api)，会发现 Nuxt.js 真的是高度封装。对于 Nuxt.js 生成的模板项目，只有一些必要配置是需要我们去完成的。Nuxt.js 可以说是一个非常友好而强大的 SSR 框架了。\n\n# Vue.js学习系列\n鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。\n\n[Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）](http://www.jianshu.com/p/8013d8d37bd0)\n[Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）](http://www.jianshu.com/p/d6f7e11f18af)\n[Vue.js学习系列三 —— axios和网络传输相关知识的学习实践](http://www.jianshu.com/p/8e5fb763c3d7)\n[Vue.js学习系列四 —— Webpack打包工具的使用](http://www.jianshu.com/p/aef34acd111f)\n[Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint](http://www.jianshu.com/p/efb6fbed6fac)\n[Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记](http://www.jianshu.com/p/073d25a3bba0)\n[Vue.js学习系列七 —— Vue服务器渲染Nuxt学习](https://www.jianshu.com/p/ba7466d7101a)\n[Vue.js学习系列八 —— Vue源码学习之State学习](https://www.jianshu.com/p/15028f91226e)\n\n# Vue.js学习系列项目地址\n本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。\n[https://github.com/violetjack/VueStudyDemos](https://github.com/violetjack/VueStudyDemos)\n\n# 关于作者\nVioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。\n欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。\n\n新浪微博： http://weibo.com/u/2640909603\n掘金：https://gold.xitu.io/user/571d953d39b0570068145cd1\nCSDN: http://blog.csdn.net/violetjack0808\n简书： http://www.jianshu.com/users/54ae4af3a98d/latest_articles\nGithub： https://github.com/violetjack","source":"_posts/Vue.js学习系列七 —— Vue服务器渲染Nuxt学习.md","raw":"---\ntitle: Vue.js学习系列七 —— Vue服务器渲染Nuxt学习\ndate: 2018-01-26\n---\n\n> 我又回来啦~这次我们来学习Vue的服务器渲染SSR。\n\n关于SSR的文章网上很多，一开始看得我云里雾里。然后去[Vue.js 服务器渲染指南](https://ssr.vuejs.org/zh/)和[nuxt官网](https://zh.nuxtjs.org/guide)看了看，发现文章大多都是搬运官网的内容，真正讲的清晰明了的很少。所以想写篇文章学习下SSR，希望能够帮助大家快速理解Vue SSR。\n\n# 什么是SSR？\nSSR，即服务器渲染，就是在服务器端将对Vue页面进行渲染生成html文件，将html页面传给浏览器。\n优点：\n* SEO 不同于SPA的HTML只有一个无实际内容的HTML和一个app.js，SSR生成的HTML是有内容的，这让搜索引擎能够索引到页面内容。\n* 更快内容到达时间 传统的SPA应用是将bundle.js从服务器获取，然后在客户端解析并挂载到dom。而SSR直接将HTML字符串传递给浏览器。大大加快了首屏加载时间。\n\n可以从下面两张图来看，第一张图是SSR生成的HTML页面，第二种是传统SPA生成的HTML页面。\n![SSR](http://upload-images.jianshu.io/upload_images/1987062-744de5a6489440da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![SPA](http://upload-images.jianshu.io/upload_images/1987062-1b940fb15ba7fbd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# Nuxt.js\n我看了官方 SSR 的介绍，也看了 Nuxt.js 的文档。本质上来说 SSR 是node后端的操作行为，作为只想好好写前端代码的我，不想太折腾。而 Nuxt.js 非常完美地整合了 SSR 的功能。让我们可以开箱即用~官方也推荐使用 Nuxt.js 来搭建 SSR 项目。\n\n## 好处\n我觉得  Nuxt.js  相比自己写 SSR 有几点好处。\n* 无需配置Webpack：我一开始还在找Webpack配置呢，看了文档知道nuxt都帮我们封装好了。如需修改Webpack配置只需修改nuxt.config.js 文件。\n* 无需node知识：只要你会写vue前端，你就可以写出SSR。无需知道SSR和node、express的配置方法（不过现在的前端多少都会点node知识~）。\n* 整合了vue全家桶，直接可用。方便程度不亚于 `vue-cli`：安装Nuxt——写组件——编译并启动服务———看效果。就这么简单。\n* 配置简单，文档友好：认真看下 Nuxt.js 文档就会发现涵盖的内容并不多，而功能很全，非常适合入手。\n\n## 安装\n安装方法[在此](https://zh.nuxtjs.org/guide/installation)。很简单，生成模板，然后npm安装依赖，最后再运行。\n简单搬运下步骤吧。\n```\n// vue-cli 创建nuxt模板项目\n$ vue init nuxt-community/starter-template <project-name>\n// 安装依赖项\n$ cd <project-name>\n$ npm install\n// 编译并启动服务\n$ npm run dev\n// 打开 http://localhost:3000\n```\n**安装遇到的问题：**\n由于 Nuxt.js 中使用了 `async...await` 语法，而低版本的 node 不支持这个语法，所以必须升级 node 到 **7.0** 版本之上~\n然后建议不要使用cnpm，我用cnpm安装运行老报错，感觉有坑。\n\n## 目录结构\nNuxt.js 花了很大的篇幅讲它的目录结构，其实了解了目录结构就了解了 Nuxt.js 的大概。Nuxt.js 帮我们配置好了所有东西，我们只需要按照它的要求在相应目录下创建文件写代码即可。\n\n* assets 需要编译的资源文件，如 JavaScript、SASS、LESS 等。\n* static 不需要编译的静态资源文件，如图片资源。\n* components 顾名思义，存放 `*.vue` 组件的地方。常规 vue 组件写法。\n* layouts 布局目录，设置布局的地方，其中 `<nuxt/>` 标签是我们写的页面内容。可用作添加导航栏、底部栏等截面。\n* middleware 中间件目录，所谓中间件，就是在页面与页面跳转中执行的函数方法。如页面跳转时验证用户信息操作。\n* pages 页面目录。重点来了~这就是我们存放展示页面的地方。该目录下的文件会转换成相应的路由路径供浏览器访问。另外呢，该目录下的 `*.vue` 页面文件中  Nuxt.js 提供了一些特殊的方法用于处理服务器渲染中的事件。具体关于路由和特殊方法列举在下面了。\n  * [pages 路由](https://zh.nuxtjs.org/guide/routing)\n  * [页面组件](https://zh.nuxtjs.org/guide/views#页面)的简单介绍，具体特殊配置项的用法请查阅[API](https://zh.nuxtjs.org/api)。\n* plugins 插件目录，像 mint-ui 这种第三方插件就放在这里啦~具体用法[看这里](https://zh.nuxtjs.org/guide/plugins)。\n* store vuex 状态管理器目录，如果该目录是空的， Nuxt.js 将不启用 vuex。当我们在该文件夹下创建 index.js 文件后即可使用 vuex 状态管理器。用法[在此](https://zh.nuxtjs.org/guide/vuex-store)！\n* nuxt.config.js 该文件是 Nuxt.js 的唯一配置项，之前提过 Nuxt.js 将 Webpack 等一众配置都封装好了，所以如果需要特殊配置，只需要修改该文件来覆盖默认配置即可。具体配置参数请查阅[API](https://zh.nuxtjs.org/api)。\n* package.json 不解释……\n\n# Demo演示\n好消息，[VueStudyDemos](https://github.com/violetjack/VueStudyDemos)又更新啦！欢迎Star~[本文Demo](https://github.com/violetjack/VueStudyDemos/tree/master/NuxtDemo)已收入到VueStudyDemos中。\n下面我们来简单实现下各文件夹所提到的功能。\n\n## 资源加载\n我在 assets 文件夹下添加了 font-awesome 字体库，在 static 文件夹中放了张 Vue 的 logo 图片。然后对资源进行调用。\n```\n<i class=\"fa fa-address-book\" aria-hidden=\"true\"></i>\n<img src=\"~/static/logo.png\" />\n```\n这里需要将 font-awesome 的 css 变为全局 css，避免每个用到的页面中都 import 字体库的css。所以我们在 nuxt.config.js 中添加如下配置。\n```\nmodule.exports = {\n  ...\n  css: [\n    '~/assets/font-awesome/css/font-awesome.min.css'\n  ],\n  ...\n}\n\n```\n## 组件定义\n组件存放在 components 文件夹下，这个我们讲目录的时候提到过。组件的用法和常用 vue 组件用法一致。\n定义组件 Avatar，然后在 Page 页面中使用。\n```\n<template>\n  <avatar/>\n</template>\n<script>\nimport avatar from '~/components/Avatar'\nexport default {\n    ...\n    components: {\n        avatar\n    }\n};\n</script>\n```\n## 布局\n在 layouts 目录中，default 是默认布局。我们可以修改默认布局也可以新建布局来使用。\n在布局文件中 `</nuxt>` 标签是我们要服务器渲染的区域。\n下面我们来创建个布局玩玩。\n```\n// layouts/page.vue\n<template>\n<div>\n    <mt-header fixed title=\"标题2\"></mt-header>\n    <nuxt/>\n</div>\n</template>\n```\n然后我们来使用布局，在 pages 页面中配置 layout 选项（如果不配置默认就是 `default`）。\n```\nexport default {\n    ...\n    layout: 'page'  // 默认是 'default'\n};\n```\n## 中间件\n所谓中间件，就是在两个页面跳转之间执行的行为。比如我定义一个中间件 add.js\n```\nexport default function ({ store }) {\n    store.commit('increment')\n}\n```\n然后在 nuxt.config.js 中进行配置：\n```\nmodule.exports = {\n  ...\n  router: {\n    middleware: 'add'\n  },\n  ...\n}\n\n```\n这样，在每次页面跳转的时候都会执行一次中间件方法了。当然，也可以单独定义某个页面的中间件，具体看官网啦~\n\n## 页面\n页面，就是在pages目录下的 `*.vue` 文件，Nuxt.js 将目录结构配置为 vue-router 路由系统，所以我们可以直接通过文件名来访问到相应页面（先不提特殊路由）。\n比如 `pages/app.vue` 文件就可以通过 `http://localhost:3000/app` 来进行访问。\n注意：页面组件写法与常用 Vue 组件写法相同，但 Nuxt.js 还提供了一些特殊配置项来配置服务器渲染过程中的行为。具体有啥配置请看[页面文档](https://zh.nuxtjs.org/guide/views#页面)。\n\n## 路由\n路由就是使 pages 目录能够直接访问的原因。Nuxt.js 非常巧妙地使用目录结构和文件名称将 vue-router 的各种用法都涵盖进去了。如动态路由、嵌套路由等。具体可参考[文档](https://zh.nuxtjs.org/guide/routing)。也可以看看demo的 [pages](https://github.com/violetjack/VueStudyDemos/tree/master/NuxtDemo/pages) 目录。\n\n## 插件\n对于前端项目，插件的使用当然是必不可少的。官网上对这方面讲的很清楚。我贴一下 demo 中的用法。这里用的是 mint-ui 库。\n```\n// plugins/mint-ui.js\nimport Vue from 'vue'\nimport MintUI from 'mint-ui'\nimport 'mint-ui/lib/style.css'\n\nVue.use(MintUI)\n```\n```\n// nuxt.config.js\nmodule.exports = {\n  build: {\n    vendor: ['mint-ui']\n  },\n  plugins: [\n    '~plugins/mint-ui'\n  ]\n}\n```\n这样就可以使用第三方库 mint-ui 啦！\n```\n<template>\n  <div>\n    <mt-navbar v-model=\"selected\">\n        <mt-tab-item id=\"1\">选项一</mt-tab-item>\n        <mt-tab-item id=\"2\">选项二</mt-tab-item>\n        <mt-tab-item id=\"3\">选项三</mt-tab-item>\n    </mt-navbar>\n\n    <!-- tab-container -->\n    <mt-tab-container v-model=\"selected\">\n        <mt-tab-container-item id=\"1\">\n            <mt-cell v-for=\"n in 10\" :key=\"n\" :title=\"'内容 ' + n\" />\n        </mt-tab-container-item>\n        <mt-tab-container-item id=\"2\">\n            <mt-cell v-for=\"n in 4\" :key=\"n\" :title=\"'测试 ' + n\" />\n        </mt-tab-container-item>\n        <mt-tab-container-item id=\"3\">\n            <mt-cell v-for=\"n in 6\" :key=\"n\" :title=\"'选项 ' + n\" />\n        </mt-tab-container-item>\n    </mt-tab-container>\n  </div>\n</template>\n```\n## vuex\n对于 vuex，用法有两种：[普通方式](https://zh.nuxtjs.org/guide/vuex-store#普通方式)和[模块方式](https://zh.nuxtjs.org/guide/vuex-store#模块方式)，用法和我们常用的 vuex 一样。我的demo中是直接复制官网的代码。\n需要注意的是，vuex 的数据会存在[context对象](https://zh.nuxtjs.org/api/#上下文对象)中，我们可以通过context对象获取状态数据。\n# 发布\n发布有两种方式服务器应用渲染部署和静态部署，发布方式[看这里](https://zh.nuxtjs.org/guide/commands#发布部署)\n\n# 最后\n去看 Nuxt.js 的 [API](https://zh.nuxtjs.org/api)，会发现 Nuxt.js 真的是高度封装。对于 Nuxt.js 生成的模板项目，只有一些必要配置是需要我们去完成的。Nuxt.js 可以说是一个非常友好而强大的 SSR 框架了。\n\n# Vue.js学习系列\n鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。\n\n[Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）](http://www.jianshu.com/p/8013d8d37bd0)\n[Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）](http://www.jianshu.com/p/d6f7e11f18af)\n[Vue.js学习系列三 —— axios和网络传输相关知识的学习实践](http://www.jianshu.com/p/8e5fb763c3d7)\n[Vue.js学习系列四 —— Webpack打包工具的使用](http://www.jianshu.com/p/aef34acd111f)\n[Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint](http://www.jianshu.com/p/efb6fbed6fac)\n[Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记](http://www.jianshu.com/p/073d25a3bba0)\n[Vue.js学习系列七 —— Vue服务器渲染Nuxt学习](https://www.jianshu.com/p/ba7466d7101a)\n[Vue.js学习系列八 —— Vue源码学习之State学习](https://www.jianshu.com/p/15028f91226e)\n\n# Vue.js学习系列项目地址\n本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。\n[https://github.com/violetjack/VueStudyDemos](https://github.com/violetjack/VueStudyDemos)\n\n# 关于作者\nVioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。\n欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。\n\n新浪微博： http://weibo.com/u/2640909603\n掘金：https://gold.xitu.io/user/571d953d39b0570068145cd1\nCSDN: http://blog.csdn.net/violetjack0808\n简书： http://www.jianshu.com/users/54ae4af3a98d/latest_articles\nGithub： https://github.com/violetjack","slug":"Vue.js学习系列七 —— Vue服务器渲染Nuxt学习","published":1,"updated":"2018-02-07T02:26:51.136Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjddwxbm40004i8bt7qnnfxxw","content":"<blockquote>\n<p>我又回来啦~这次我们来学习Vue的服务器渲染SSR。</p>\n</blockquote>\n<p>关于SSR的文章网上很多，一开始看得我云里雾里。然后去<a href=\"https://ssr.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">Vue.js 服务器渲染指南</a>和<a href=\"https://zh.nuxtjs.org/guide\" target=\"_blank\" rel=\"noopener\">nuxt官网</a>看了看，发现文章大多都是搬运官网的内容，真正讲的清晰明了的很少。所以想写篇文章学习下SSR，希望能够帮助大家快速理解Vue SSR。</p>\n<h1 id=\"什么是SSR？\"><a href=\"#什么是SSR？\" class=\"headerlink\" title=\"什么是SSR？\"></a>什么是SSR？</h1><p>SSR，即服务器渲染，就是在服务器端将对Vue页面进行渲染生成html文件，将html页面传给浏览器。<br>优点：</p>\n<ul>\n<li>SEO 不同于SPA的HTML只有一个无实际内容的HTML和一个app.js，SSR生成的HTML是有内容的，这让搜索引擎能够索引到页面内容。</li>\n<li>更快内容到达时间 传统的SPA应用是将bundle.js从服务器获取，然后在客户端解析并挂载到dom。而SSR直接将HTML字符串传递给浏览器。大大加快了首屏加载时间。</li>\n</ul>\n<p>可以从下面两张图来看，第一张图是SSR生成的HTML页面，第二种是传统SPA生成的HTML页面。<br><img src=\"http://upload-images.jianshu.io/upload_images/1987062-744de5a6489440da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"SSR\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1987062-1b940fb15ba7fbd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"SPA\"></p>\n<h1 id=\"Nuxt-js\"><a href=\"#Nuxt-js\" class=\"headerlink\" title=\"Nuxt.js\"></a>Nuxt.js</h1><p>我看了官方 SSR 的介绍，也看了 Nuxt.js 的文档。本质上来说 SSR 是node后端的操作行为，作为只想好好写前端代码的我，不想太折腾。而 Nuxt.js 非常完美地整合了 SSR 的功能。让我们可以开箱即用~官方也推荐使用 Nuxt.js 来搭建 SSR 项目。</p>\n<h2 id=\"好处\"><a href=\"#好处\" class=\"headerlink\" title=\"好处\"></a>好处</h2><p>我觉得  Nuxt.js  相比自己写 SSR 有几点好处。</p>\n<ul>\n<li>无需配置Webpack：我一开始还在找Webpack配置呢，看了文档知道nuxt都帮我们封装好了。如需修改Webpack配置只需修改nuxt.config.js 文件。</li>\n<li>无需node知识：只要你会写vue前端，你就可以写出SSR。无需知道SSR和node、express的配置方法（不过现在的前端多少都会点node知识~）。</li>\n<li>整合了vue全家桶，直接可用。方便程度不亚于 <code>vue-cli</code>：安装Nuxt——写组件——编译并启动服务———看效果。就这么简单。</li>\n<li>配置简单，文档友好：认真看下 Nuxt.js 文档就会发现涵盖的内容并不多，而功能很全，非常适合入手。</li>\n</ul>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>安装方法<a href=\"https://zh.nuxtjs.org/guide/installation\" target=\"_blank\" rel=\"noopener\">在此</a>。很简单，生成模板，然后npm安装依赖，最后再运行。<br>简单搬运下步骤吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// vue-cli 创建nuxt模板项目</span><br><span class=\"line\">$ vue init nuxt-community/starter-template &lt;project-name&gt;</span><br><span class=\"line\">// 安装依赖项</span><br><span class=\"line\">$ cd &lt;project-name&gt;</span><br><span class=\"line\">$ npm install</span><br><span class=\"line\">// 编译并启动服务</span><br><span class=\"line\">$ npm run dev</span><br><span class=\"line\">// 打开 http://localhost:3000</span><br></pre></td></tr></table></figure></p>\n<p><strong>安装遇到的问题：</strong><br>由于 Nuxt.js 中使用了 <code>async...await</code> 语法，而低版本的 node 不支持这个语法，所以必须升级 node 到 <strong>7.0</strong> 版本之上~<br>然后建议不要使用cnpm，我用cnpm安装运行老报错，感觉有坑。</p>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><p>Nuxt.js 花了很大的篇幅讲它的目录结构，其实了解了目录结构就了解了 Nuxt.js 的大概。Nuxt.js 帮我们配置好了所有东西，我们只需要按照它的要求在相应目录下创建文件写代码即可。</p>\n<ul>\n<li>assets 需要编译的资源文件，如 JavaScript、SASS、LESS 等。</li>\n<li>static 不需要编译的静态资源文件，如图片资源。</li>\n<li>components 顾名思义，存放 <code>*.vue</code> 组件的地方。常规 vue 组件写法。</li>\n<li>layouts 布局目录，设置布局的地方，其中 <code>&lt;nuxt/&gt;</code> 标签是我们写的页面内容。可用作添加导航栏、底部栏等截面。</li>\n<li>middleware 中间件目录，所谓中间件，就是在页面与页面跳转中执行的函数方法。如页面跳转时验证用户信息操作。</li>\n<li>pages 页面目录。重点来了~这就是我们存放展示页面的地方。该目录下的文件会转换成相应的路由路径供浏览器访问。另外呢，该目录下的 <code>*.vue</code> 页面文件中  Nuxt.js 提供了一些特殊的方法用于处理服务器渲染中的事件。具体关于路由和特殊方法列举在下面了。<ul>\n<li><a href=\"https://zh.nuxtjs.org/guide/routing\" target=\"_blank\" rel=\"noopener\">pages 路由</a></li>\n<li><a href=\"https://zh.nuxtjs.org/guide/views#页面\" target=\"_blank\" rel=\"noopener\">页面组件</a>的简单介绍，具体特殊配置项的用法请查阅<a href=\"https://zh.nuxtjs.org/api\" target=\"_blank\" rel=\"noopener\">API</a>。</li>\n</ul>\n</li>\n<li>plugins 插件目录，像 mint-ui 这种第三方插件就放在这里啦~具体用法<a href=\"https://zh.nuxtjs.org/guide/plugins\" target=\"_blank\" rel=\"noopener\">看这里</a>。</li>\n<li>store vuex 状态管理器目录，如果该目录是空的， Nuxt.js 将不启用 vuex。当我们在该文件夹下创建 index.js 文件后即可使用 vuex 状态管理器。用法<a href=\"https://zh.nuxtjs.org/guide/vuex-store\" target=\"_blank\" rel=\"noopener\">在此</a>！</li>\n<li>nuxt.config.js 该文件是 Nuxt.js 的唯一配置项，之前提过 Nuxt.js 将 Webpack 等一众配置都封装好了，所以如果需要特殊配置，只需要修改该文件来覆盖默认配置即可。具体配置参数请查阅<a href=\"https://zh.nuxtjs.org/api\" target=\"_blank\" rel=\"noopener\">API</a>。</li>\n<li>package.json 不解释……</li>\n</ul>\n<h1 id=\"Demo演示\"><a href=\"#Demo演示\" class=\"headerlink\" title=\"Demo演示\"></a>Demo演示</h1><p>好消息，<a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">VueStudyDemos</a>又更新啦！欢迎Star~<a href=\"https://github.com/violetjack/VueStudyDemos/tree/master/NuxtDemo\" target=\"_blank\" rel=\"noopener\">本文Demo</a>已收入到VueStudyDemos中。<br>下面我们来简单实现下各文件夹所提到的功能。</p>\n<h2 id=\"资源加载\"><a href=\"#资源加载\" class=\"headerlink\" title=\"资源加载\"></a>资源加载</h2><p>我在 assets 文件夹下添加了 font-awesome 字体库，在 static 文件夹中放了张 Vue 的 logo 图片。然后对资源进行调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;i class=&quot;fa fa-address-book&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;</span><br><span class=\"line\">&lt;img src=&quot;~/static/logo.png&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这里需要将 font-awesome 的 css 变为全局 css，避免每个用到的页面中都 import 字体库的css。所以我们在 nuxt.config.js 中添加如下配置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  css: [</span><br><span class=\"line\">    &apos;~/assets/font-awesome/css/font-awesome.min.css&apos;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"组件定义\"><a href=\"#组件定义\" class=\"headerlink\" title=\"组件定义\"></a>组件定义</h2><p>组件存放在 components 文件夹下，这个我们讲目录的时候提到过。组件的用法和常用 vue 组件用法一致。<br>定义组件 Avatar，然后在 Page 页面中使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;avatar/&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import avatar from &apos;~/components/Avatar&apos;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    components: &#123;</span><br><span class=\"line\">        avatar</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h2><p>在 layouts 目录中，default 是默认布局。我们可以修改默认布局也可以新建布局来使用。<br>在布局文件中 <code>&lt;/nuxt&gt;</code> 标签是我们要服务器渲染的区域。<br>下面我们来创建个布局玩玩。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// layouts/page.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &lt;mt-header fixed title=&quot;标题2&quot;&gt;&lt;/mt-header&gt;</span><br><span class=\"line\">    &lt;nuxt/&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们来使用布局，在 pages 页面中配置 layout 选项（如果不配置默认就是 <code>default</code>）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    layout: &apos;page&apos;  // 默认是 &apos;default&apos;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h2><p>所谓中间件，就是在两个页面跳转之间执行的行为。比如我定义一个中间件 add.js<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default function (&#123; store &#125;) &#123;</span><br><span class=\"line\">    store.commit(&apos;increment&apos;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后在 nuxt.config.js 中进行配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  router: &#123;</span><br><span class=\"line\">    middleware: &apos;add&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，在每次页面跳转的时候都会执行一次中间件方法了。当然，也可以单独定义某个页面的中间件，具体看官网啦~</p>\n<h2 id=\"页面\"><a href=\"#页面\" class=\"headerlink\" title=\"页面\"></a>页面</h2><p>页面，就是在pages目录下的 <code>*.vue</code> 文件，Nuxt.js 将目录结构配置为 vue-router 路由系统，所以我们可以直接通过文件名来访问到相应页面（先不提特殊路由）。<br>比如 <code>pages/app.vue</code> 文件就可以通过 <code>http://localhost:3000/app</code> 来进行访问。<br>注意：页面组件写法与常用 Vue 组件写法相同，但 Nuxt.js 还提供了一些特殊配置项来配置服务器渲染过程中的行为。具体有啥配置请看<a href=\"https://zh.nuxtjs.org/guide/views#页面\" target=\"_blank\" rel=\"noopener\">页面文档</a>。</p>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><p>路由就是使 pages 目录能够直接访问的原因。Nuxt.js 非常巧妙地使用目录结构和文件名称将 vue-router 的各种用法都涵盖进去了。如动态路由、嵌套路由等。具体可参考<a href=\"https://zh.nuxtjs.org/guide/routing\" target=\"_blank\" rel=\"noopener\">文档</a>。也可以看看demo的 <a href=\"https://github.com/violetjack/VueStudyDemos/tree/master/NuxtDemo/pages\" target=\"_blank\" rel=\"noopener\">pages</a> 目录。</p>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><p>对于前端项目，插件的使用当然是必不可少的。官网上对这方面讲的很清楚。我贴一下 demo 中的用法。这里用的是 mint-ui 库。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// plugins/mint-ui.js</span><br><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\">import MintUI from &apos;mint-ui&apos;</span><br><span class=\"line\">import &apos;mint-ui/lib/style.css&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(MintUI)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// nuxt.config.js</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  build: &#123;</span><br><span class=\"line\">    vendor: [&apos;mint-ui&apos;]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    &apos;~plugins/mint-ui&apos;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就可以使用第三方库 mint-ui 啦！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;mt-navbar v-model=&quot;selected&quot;&gt;</span><br><span class=\"line\">        &lt;mt-tab-item id=&quot;1&quot;&gt;选项一&lt;/mt-tab-item&gt;</span><br><span class=\"line\">        &lt;mt-tab-item id=&quot;2&quot;&gt;选项二&lt;/mt-tab-item&gt;</span><br><span class=\"line\">        &lt;mt-tab-item id=&quot;3&quot;&gt;选项三&lt;/mt-tab-item&gt;</span><br><span class=\"line\">    &lt;/mt-navbar&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- tab-container --&gt;</span><br><span class=\"line\">    &lt;mt-tab-container v-model=&quot;selected&quot;&gt;</span><br><span class=\"line\">        &lt;mt-tab-container-item id=&quot;1&quot;&gt;</span><br><span class=\"line\">            &lt;mt-cell v-for=&quot;n in 10&quot; :key=&quot;n&quot; :title=&quot;&apos;内容 &apos; + n&quot; /&gt;</span><br><span class=\"line\">        &lt;/mt-tab-container-item&gt;</span><br><span class=\"line\">        &lt;mt-tab-container-item id=&quot;2&quot;&gt;</span><br><span class=\"line\">            &lt;mt-cell v-for=&quot;n in 4&quot; :key=&quot;n&quot; :title=&quot;&apos;测试 &apos; + n&quot; /&gt;</span><br><span class=\"line\">        &lt;/mt-tab-container-item&gt;</span><br><span class=\"line\">        &lt;mt-tab-container-item id=&quot;3&quot;&gt;</span><br><span class=\"line\">            &lt;mt-cell v-for=&quot;n in 6&quot; :key=&quot;n&quot; :title=&quot;&apos;选项 &apos; + n&quot; /&gt;</span><br><span class=\"line\">        &lt;/mt-tab-container-item&gt;</span><br><span class=\"line\">    &lt;/mt-tab-container&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"vuex\"><a href=\"#vuex\" class=\"headerlink\" title=\"vuex\"></a>vuex</h2><p>对于 vuex，用法有两种：<a href=\"https://zh.nuxtjs.org/guide/vuex-store#普通方式\" target=\"_blank\" rel=\"noopener\">普通方式</a>和<a href=\"https://zh.nuxtjs.org/guide/vuex-store#模块方式\" target=\"_blank\" rel=\"noopener\">模块方式</a>，用法和我们常用的 vuex 一样。我的demo中是直接复制官网的代码。<br>需要注意的是，vuex 的数据会存在<a href=\"https://zh.nuxtjs.org/api/#上下文对象\" target=\"_blank\" rel=\"noopener\">context对象</a>中，我们可以通过context对象获取状态数据。</p>\n<h1 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h1><p>发布有两种方式服务器应用渲染部署和静态部署，发布方式<a href=\"https://zh.nuxtjs.org/guide/commands#发布部署\" target=\"_blank\" rel=\"noopener\">看这里</a></p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>去看 Nuxt.js 的 <a href=\"https://zh.nuxtjs.org/api\" target=\"_blank\" rel=\"noopener\">API</a>，会发现 Nuxt.js 真的是高度封装。对于 Nuxt.js 生成的模板项目，只有一些必要配置是需要我们去完成的。Nuxt.js 可以说是一个非常友好而强大的 SSR 框架了。</p>\n<h1 id=\"Vue-js学习系列\"><a href=\"#Vue-js学习系列\" class=\"headerlink\" title=\"Vue.js学习系列\"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>\n<p><a href=\"http://www.jianshu.com/p/8013d8d37bd0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/d6f7e11f18af\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/8e5fb763c3d7\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href=\"http://www.jianshu.com/p/aef34acd111f\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href=\"http://www.jianshu.com/p/efb6fbed6fac\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href=\"http://www.jianshu.com/p/073d25a3bba0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href=\"https://www.jianshu.com/p/ba7466d7101a\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href=\"https://www.jianshu.com/p/15028f91226e\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>\n<h1 id=\"Vue-js学习系列项目地址\"><a href=\"#Vue-js学习系列项目地址\" class=\"headerlink\" title=\"Vue.js学习系列项目地址\"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack/VueStudyDemos</a></p>\n<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>\n<p>新浪微博： <a href=\"http://weibo.com/u/2640909603\" target=\"_blank\" rel=\"noopener\">http://weibo.com/u/2640909603</a><br>掘金：<a href=\"https://gold.xitu.io/user/571d953d39b0570068145cd1\" target=\"_blank\" rel=\"noopener\">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href=\"http://blog.csdn.net/violetjack0808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/violetjack0808</a><br>简书： <a href=\"http://www.jianshu.com/users/54ae4af3a98d/latest_articles\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href=\"https://github.com/violetjack\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>我又回来啦~这次我们来学习Vue的服务器渲染SSR。</p>\n</blockquote>\n<p>关于SSR的文章网上很多，一开始看得我云里雾里。然后去<a href=\"https://ssr.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">Vue.js 服务器渲染指南</a>和<a href=\"https://zh.nuxtjs.org/guide\" target=\"_blank\" rel=\"noopener\">nuxt官网</a>看了看，发现文章大多都是搬运官网的内容，真正讲的清晰明了的很少。所以想写篇文章学习下SSR，希望能够帮助大家快速理解Vue SSR。</p>\n<h1 id=\"什么是SSR？\"><a href=\"#什么是SSR？\" class=\"headerlink\" title=\"什么是SSR？\"></a>什么是SSR？</h1><p>SSR，即服务器渲染，就是在服务器端将对Vue页面进行渲染生成html文件，将html页面传给浏览器。<br>优点：</p>\n<ul>\n<li>SEO 不同于SPA的HTML只有一个无实际内容的HTML和一个app.js，SSR生成的HTML是有内容的，这让搜索引擎能够索引到页面内容。</li>\n<li>更快内容到达时间 传统的SPA应用是将bundle.js从服务器获取，然后在客户端解析并挂载到dom。而SSR直接将HTML字符串传递给浏览器。大大加快了首屏加载时间。</li>\n</ul>\n<p>可以从下面两张图来看，第一张图是SSR生成的HTML页面，第二种是传统SPA生成的HTML页面。<br><img src=\"http://upload-images.jianshu.io/upload_images/1987062-744de5a6489440da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"SSR\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1987062-1b940fb15ba7fbd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"SPA\"></p>\n<h1 id=\"Nuxt-js\"><a href=\"#Nuxt-js\" class=\"headerlink\" title=\"Nuxt.js\"></a>Nuxt.js</h1><p>我看了官方 SSR 的介绍，也看了 Nuxt.js 的文档。本质上来说 SSR 是node后端的操作行为，作为只想好好写前端代码的我，不想太折腾。而 Nuxt.js 非常完美地整合了 SSR 的功能。让我们可以开箱即用~官方也推荐使用 Nuxt.js 来搭建 SSR 项目。</p>\n<h2 id=\"好处\"><a href=\"#好处\" class=\"headerlink\" title=\"好处\"></a>好处</h2><p>我觉得  Nuxt.js  相比自己写 SSR 有几点好处。</p>\n<ul>\n<li>无需配置Webpack：我一开始还在找Webpack配置呢，看了文档知道nuxt都帮我们封装好了。如需修改Webpack配置只需修改nuxt.config.js 文件。</li>\n<li>无需node知识：只要你会写vue前端，你就可以写出SSR。无需知道SSR和node、express的配置方法（不过现在的前端多少都会点node知识~）。</li>\n<li>整合了vue全家桶，直接可用。方便程度不亚于 <code>vue-cli</code>：安装Nuxt——写组件——编译并启动服务———看效果。就这么简单。</li>\n<li>配置简单，文档友好：认真看下 Nuxt.js 文档就会发现涵盖的内容并不多，而功能很全，非常适合入手。</li>\n</ul>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>安装方法<a href=\"https://zh.nuxtjs.org/guide/installation\" target=\"_blank\" rel=\"noopener\">在此</a>。很简单，生成模板，然后npm安装依赖，最后再运行。<br>简单搬运下步骤吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// vue-cli 创建nuxt模板项目</span><br><span class=\"line\">$ vue init nuxt-community/starter-template &lt;project-name&gt;</span><br><span class=\"line\">// 安装依赖项</span><br><span class=\"line\">$ cd &lt;project-name&gt;</span><br><span class=\"line\">$ npm install</span><br><span class=\"line\">// 编译并启动服务</span><br><span class=\"line\">$ npm run dev</span><br><span class=\"line\">// 打开 http://localhost:3000</span><br></pre></td></tr></table></figure></p>\n<p><strong>安装遇到的问题：</strong><br>由于 Nuxt.js 中使用了 <code>async...await</code> 语法，而低版本的 node 不支持这个语法，所以必须升级 node 到 <strong>7.0</strong> 版本之上~<br>然后建议不要使用cnpm，我用cnpm安装运行老报错，感觉有坑。</p>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><p>Nuxt.js 花了很大的篇幅讲它的目录结构，其实了解了目录结构就了解了 Nuxt.js 的大概。Nuxt.js 帮我们配置好了所有东西，我们只需要按照它的要求在相应目录下创建文件写代码即可。</p>\n<ul>\n<li>assets 需要编译的资源文件，如 JavaScript、SASS、LESS 等。</li>\n<li>static 不需要编译的静态资源文件，如图片资源。</li>\n<li>components 顾名思义，存放 <code>*.vue</code> 组件的地方。常规 vue 组件写法。</li>\n<li>layouts 布局目录，设置布局的地方，其中 <code>&lt;nuxt/&gt;</code> 标签是我们写的页面内容。可用作添加导航栏、底部栏等截面。</li>\n<li>middleware 中间件目录，所谓中间件，就是在页面与页面跳转中执行的函数方法。如页面跳转时验证用户信息操作。</li>\n<li>pages 页面目录。重点来了~这就是我们存放展示页面的地方。该目录下的文件会转换成相应的路由路径供浏览器访问。另外呢，该目录下的 <code>*.vue</code> 页面文件中  Nuxt.js 提供了一些特殊的方法用于处理服务器渲染中的事件。具体关于路由和特殊方法列举在下面了。<ul>\n<li><a href=\"https://zh.nuxtjs.org/guide/routing\" target=\"_blank\" rel=\"noopener\">pages 路由</a></li>\n<li><a href=\"https://zh.nuxtjs.org/guide/views#页面\" target=\"_blank\" rel=\"noopener\">页面组件</a>的简单介绍，具体特殊配置项的用法请查阅<a href=\"https://zh.nuxtjs.org/api\" target=\"_blank\" rel=\"noopener\">API</a>。</li>\n</ul>\n</li>\n<li>plugins 插件目录，像 mint-ui 这种第三方插件就放在这里啦~具体用法<a href=\"https://zh.nuxtjs.org/guide/plugins\" target=\"_blank\" rel=\"noopener\">看这里</a>。</li>\n<li>store vuex 状态管理器目录，如果该目录是空的， Nuxt.js 将不启用 vuex。当我们在该文件夹下创建 index.js 文件后即可使用 vuex 状态管理器。用法<a href=\"https://zh.nuxtjs.org/guide/vuex-store\" target=\"_blank\" rel=\"noopener\">在此</a>！</li>\n<li>nuxt.config.js 该文件是 Nuxt.js 的唯一配置项，之前提过 Nuxt.js 将 Webpack 等一众配置都封装好了，所以如果需要特殊配置，只需要修改该文件来覆盖默认配置即可。具体配置参数请查阅<a href=\"https://zh.nuxtjs.org/api\" target=\"_blank\" rel=\"noopener\">API</a>。</li>\n<li>package.json 不解释……</li>\n</ul>\n<h1 id=\"Demo演示\"><a href=\"#Demo演示\" class=\"headerlink\" title=\"Demo演示\"></a>Demo演示</h1><p>好消息，<a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">VueStudyDemos</a>又更新啦！欢迎Star~<a href=\"https://github.com/violetjack/VueStudyDemos/tree/master/NuxtDemo\" target=\"_blank\" rel=\"noopener\">本文Demo</a>已收入到VueStudyDemos中。<br>下面我们来简单实现下各文件夹所提到的功能。</p>\n<h2 id=\"资源加载\"><a href=\"#资源加载\" class=\"headerlink\" title=\"资源加载\"></a>资源加载</h2><p>我在 assets 文件夹下添加了 font-awesome 字体库，在 static 文件夹中放了张 Vue 的 logo 图片。然后对资源进行调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;i class=&quot;fa fa-address-book&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;</span><br><span class=\"line\">&lt;img src=&quot;~/static/logo.png&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这里需要将 font-awesome 的 css 变为全局 css，避免每个用到的页面中都 import 字体库的css。所以我们在 nuxt.config.js 中添加如下配置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  css: [</span><br><span class=\"line\">    &apos;~/assets/font-awesome/css/font-awesome.min.css&apos;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"组件定义\"><a href=\"#组件定义\" class=\"headerlink\" title=\"组件定义\"></a>组件定义</h2><p>组件存放在 components 文件夹下，这个我们讲目录的时候提到过。组件的用法和常用 vue 组件用法一致。<br>定义组件 Avatar，然后在 Page 页面中使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;avatar/&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import avatar from &apos;~/components/Avatar&apos;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    components: &#123;</span><br><span class=\"line\">        avatar</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h2><p>在 layouts 目录中，default 是默认布局。我们可以修改默认布局也可以新建布局来使用。<br>在布局文件中 <code>&lt;/nuxt&gt;</code> 标签是我们要服务器渲染的区域。<br>下面我们来创建个布局玩玩。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// layouts/page.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &lt;mt-header fixed title=&quot;标题2&quot;&gt;&lt;/mt-header&gt;</span><br><span class=\"line\">    &lt;nuxt/&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们来使用布局，在 pages 页面中配置 layout 选项（如果不配置默认就是 <code>default</code>）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    layout: &apos;page&apos;  // 默认是 &apos;default&apos;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h2><p>所谓中间件，就是在两个页面跳转之间执行的行为。比如我定义一个中间件 add.js<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default function (&#123; store &#125;) &#123;</span><br><span class=\"line\">    store.commit(&apos;increment&apos;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后在 nuxt.config.js 中进行配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  router: &#123;</span><br><span class=\"line\">    middleware: &apos;add&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，在每次页面跳转的时候都会执行一次中间件方法了。当然，也可以单独定义某个页面的中间件，具体看官网啦~</p>\n<h2 id=\"页面\"><a href=\"#页面\" class=\"headerlink\" title=\"页面\"></a>页面</h2><p>页面，就是在pages目录下的 <code>*.vue</code> 文件，Nuxt.js 将目录结构配置为 vue-router 路由系统，所以我们可以直接通过文件名来访问到相应页面（先不提特殊路由）。<br>比如 <code>pages/app.vue</code> 文件就可以通过 <code>http://localhost:3000/app</code> 来进行访问。<br>注意：页面组件写法与常用 Vue 组件写法相同，但 Nuxt.js 还提供了一些特殊配置项来配置服务器渲染过程中的行为。具体有啥配置请看<a href=\"https://zh.nuxtjs.org/guide/views#页面\" target=\"_blank\" rel=\"noopener\">页面文档</a>。</p>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><p>路由就是使 pages 目录能够直接访问的原因。Nuxt.js 非常巧妙地使用目录结构和文件名称将 vue-router 的各种用法都涵盖进去了。如动态路由、嵌套路由等。具体可参考<a href=\"https://zh.nuxtjs.org/guide/routing\" target=\"_blank\" rel=\"noopener\">文档</a>。也可以看看demo的 <a href=\"https://github.com/violetjack/VueStudyDemos/tree/master/NuxtDemo/pages\" target=\"_blank\" rel=\"noopener\">pages</a> 目录。</p>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><p>对于前端项目，插件的使用当然是必不可少的。官网上对这方面讲的很清楚。我贴一下 demo 中的用法。这里用的是 mint-ui 库。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// plugins/mint-ui.js</span><br><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\">import MintUI from &apos;mint-ui&apos;</span><br><span class=\"line\">import &apos;mint-ui/lib/style.css&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(MintUI)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// nuxt.config.js</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  build: &#123;</span><br><span class=\"line\">    vendor: [&apos;mint-ui&apos;]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    &apos;~plugins/mint-ui&apos;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就可以使用第三方库 mint-ui 啦！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;mt-navbar v-model=&quot;selected&quot;&gt;</span><br><span class=\"line\">        &lt;mt-tab-item id=&quot;1&quot;&gt;选项一&lt;/mt-tab-item&gt;</span><br><span class=\"line\">        &lt;mt-tab-item id=&quot;2&quot;&gt;选项二&lt;/mt-tab-item&gt;</span><br><span class=\"line\">        &lt;mt-tab-item id=&quot;3&quot;&gt;选项三&lt;/mt-tab-item&gt;</span><br><span class=\"line\">    &lt;/mt-navbar&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- tab-container --&gt;</span><br><span class=\"line\">    &lt;mt-tab-container v-model=&quot;selected&quot;&gt;</span><br><span class=\"line\">        &lt;mt-tab-container-item id=&quot;1&quot;&gt;</span><br><span class=\"line\">            &lt;mt-cell v-for=&quot;n in 10&quot; :key=&quot;n&quot; :title=&quot;&apos;内容 &apos; + n&quot; /&gt;</span><br><span class=\"line\">        &lt;/mt-tab-container-item&gt;</span><br><span class=\"line\">        &lt;mt-tab-container-item id=&quot;2&quot;&gt;</span><br><span class=\"line\">            &lt;mt-cell v-for=&quot;n in 4&quot; :key=&quot;n&quot; :title=&quot;&apos;测试 &apos; + n&quot; /&gt;</span><br><span class=\"line\">        &lt;/mt-tab-container-item&gt;</span><br><span class=\"line\">        &lt;mt-tab-container-item id=&quot;3&quot;&gt;</span><br><span class=\"line\">            &lt;mt-cell v-for=&quot;n in 6&quot; :key=&quot;n&quot; :title=&quot;&apos;选项 &apos; + n&quot; /&gt;</span><br><span class=\"line\">        &lt;/mt-tab-container-item&gt;</span><br><span class=\"line\">    &lt;/mt-tab-container&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"vuex\"><a href=\"#vuex\" class=\"headerlink\" title=\"vuex\"></a>vuex</h2><p>对于 vuex，用法有两种：<a href=\"https://zh.nuxtjs.org/guide/vuex-store#普通方式\" target=\"_blank\" rel=\"noopener\">普通方式</a>和<a href=\"https://zh.nuxtjs.org/guide/vuex-store#模块方式\" target=\"_blank\" rel=\"noopener\">模块方式</a>，用法和我们常用的 vuex 一样。我的demo中是直接复制官网的代码。<br>需要注意的是，vuex 的数据会存在<a href=\"https://zh.nuxtjs.org/api/#上下文对象\" target=\"_blank\" rel=\"noopener\">context对象</a>中，我们可以通过context对象获取状态数据。</p>\n<h1 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h1><p>发布有两种方式服务器应用渲染部署和静态部署，发布方式<a href=\"https://zh.nuxtjs.org/guide/commands#发布部署\" target=\"_blank\" rel=\"noopener\">看这里</a></p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>去看 Nuxt.js 的 <a href=\"https://zh.nuxtjs.org/api\" target=\"_blank\" rel=\"noopener\">API</a>，会发现 Nuxt.js 真的是高度封装。对于 Nuxt.js 生成的模板项目，只有一些必要配置是需要我们去完成的。Nuxt.js 可以说是一个非常友好而强大的 SSR 框架了。</p>\n<h1 id=\"Vue-js学习系列\"><a href=\"#Vue-js学习系列\" class=\"headerlink\" title=\"Vue.js学习系列\"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>\n<p><a href=\"http://www.jianshu.com/p/8013d8d37bd0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/d6f7e11f18af\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/8e5fb763c3d7\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href=\"http://www.jianshu.com/p/aef34acd111f\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href=\"http://www.jianshu.com/p/efb6fbed6fac\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href=\"http://www.jianshu.com/p/073d25a3bba0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href=\"https://www.jianshu.com/p/ba7466d7101a\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href=\"https://www.jianshu.com/p/15028f91226e\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>\n<h1 id=\"Vue-js学习系列项目地址\"><a href=\"#Vue-js学习系列项目地址\" class=\"headerlink\" title=\"Vue.js学习系列项目地址\"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack/VueStudyDemos</a></p>\n<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>\n<p>新浪微博： <a href=\"http://weibo.com/u/2640909603\" target=\"_blank\" rel=\"noopener\">http://weibo.com/u/2640909603</a><br>掘金：<a href=\"https://gold.xitu.io/user/571d953d39b0570068145cd1\" target=\"_blank\" rel=\"noopener\">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href=\"http://blog.csdn.net/violetjack0808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/violetjack0808</a><br>简书： <a href=\"http://www.jianshu.com/users/54ae4af3a98d/latest_articles\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href=\"https://github.com/violetjack\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack</a></p>\n"},{"title":"Vue.js学习系列三 —— axios和网络传输相关知识的学习实践","date":"2017-01-08T16:00:00.000Z","_content":"\n> 在学习了之前的路由vue-router和状态管理vuex之后，就应该是网络交互了。就学习尤大推荐的axios了。刚好本人对网络请求这块除了会get、put、post和delete这四个方法之外知之甚少，刚好补全上。\n\n**注意：**Vue官方推荐的网络通信库不再是vue-resource了，推荐使用[axios](https://github.com/mzabriskie/axios)。\n![尤大的公告](http://upload-images.jianshu.io/upload_images/1987062-b3255d564903d3d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# axios安装\nnpm:\n```\n$ npm install axios\n```\nbower:\n```\n$ bower install axios\n```\nUsing cdn:\n```\n<script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>\n```\n# 基本使用方法\n`GET`请求\n```\n// Make a request for a user with a given ID\naxios.get('/user?ID=12345')\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n// Optionally the request above could also be done as\naxios.get('/user', {\n    params: {\n      ID: 12345\n    }\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n```\n`POST`请求\n```\n axios.post('/user', {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n```\n同时执行多个请求\n```\nfunction getUserAccount() {\n  return axios.get('/user/12345');\n}\n\nfunction getUserPermissions() {\n  return axios.get('/user/12345/permissions');\n}\n\naxios.all([getUserAccount(), getUserPermissions()])\n  .then(axios.spread(function (acct, perms) {\n    // Both requests are now complete\n  }));\n```\n其实和其他的ajax库一样，基本用法都是差不多的。大家一看就知道怎么用。\n# axios API\n可以直接通过`config`来完成请求\naxios(config)\n```\naxios({\n  method: 'post',\n  url: '/user/12345',\n  data: {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  }\n});\n```\naxios(url, [config])\n```\n// Send a GET request (default method)\naxios('/user/12345');\n```\n## 请求方法别名\n下面是axios支持的所有请求方法别名，便于各种请求。\n注：`[...]`中的数据表示可以为空。`url`是ajax请求地址；`data`是提交的数据对象；`config`是配置对象，所有ajax配置都可以在`config`中实现。\n* axios.request(config)\n* axios.get(url[, config])\n* axios.delete(url[, config])\n* axios.head(url[, config])\n* axios.post(url[, data[, config]])\n* axios.put(url[, data[, config]])\n* axios.patch(url[, data[, config]])\n\n## 并发性\n下列接口用于处理并发请求(同时处理多个多个request)\n* axios.all(iterable)\n* axios.spread(callback)\n\n## axios实例\n可以用自定义的config创建一个axios实例\naxios.create([config])\n```\nvar instance = axios.create({\n  baseURL: 'https://some-domain.com/api/',\n  timeout: 1000,\n  headers: {'X-Custom-Header': 'foobar'}\n});\n```\n## 实例方法\n下面是实例的所有可用方法，方法中的`config`会与axios实例中的config合并。（实例可以将一些通用的config先配置好）\n* axios#request(config)\n* axios#get(url, [config])\n* axios#delete(url, [config])\n* axios#head(url, [config])\n* axios#post(url[, data[, config]])\n* axios#put(url[, data[, config]])\n* axios#patch(url[, data[, config]])\n\n## Config\n重点来了，来看看Config。\n下面列出了config的所有配置项，其中之后`url`是必填的。当`method`没有指定方法，默认为`GET`。\n```\n{\n  // `url` is the server URL that will be used for the request\n  // 用来向服务器发送请求的url\n  url: '/user',\n\n  // `method` is the request method to be used when making the request\n // 请求方法\n  method: 'get', // default\n\n  // `baseURL` will be prepended to `url` unless `url` is absolute.\n  // It can be convenient to set `baseURL` for an instance of axios to pass relative URLs\n  // to methods of that instance.\n  // 假如`url`不是绝对路径，那么向服务器发送请求的URL将是`baseURL + url`\n  baseURL: 'https://some-domain.com/api/',\n\n  // `transformRequest` allows changes to the request data before it is sent to the server\n  // This is only applicable for request methods 'PUT', 'POST', and 'PATCH'\n  // The last function in the array must return a string, an ArrayBuffer, or a Stream\n  transformRequest: [function (data) {\n    // Do whatever you want to transform the data\n\n    return data;\n  }],\n\n  // `transformResponse` allows changes to the response data to be made before\n  // it is passed to then/catch\n  transformResponse: [function (data) {\n    // Do whatever you want to transform the data\n\n    return data;\n  }],\n\n  // `headers` are custom headers to be sent\n  headers: {'X-Requested-With': 'XMLHttpRequest'},\n\n  // `params` are the URL parameters to be sent with the request\n  // Must be a plain object or a URLSearchParams object\n  params: {\n    ID: 12345\n  },\n\n  // `paramsSerializer` is an optional function in charge of serializing `params`\n  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)\n  paramsSerializer: function(params) {\n    return Qs.stringify(params, {arrayFormat: 'brackets'})\n  },\n\n  // `data` is the data to be sent as the request body\n  // Only applicable for request methods 'PUT', 'POST', and 'PATCH'\n  // When no `transformRequest` is set, must be of one of the following types:\n  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams\n  // - Browser only: FormData, File, Blob\n  // - Node only: Stream\n  data: {\n    firstName: 'Fred'\n  },\n\n  // `timeout` specifies the number of milliseconds before the request times out.\n  // If the request takes longer than `timeout`, the request will be aborted.\n  timeout: 1000,\n\n  // `withCredentials` indicates whether or not cross-site Access-Control requests\n  // should be made using credentials\n  withCredentials: false, // default\n\n  // `adapter` allows custom handling of requests which makes testing easier.\n  // Return a promise and supply a valid response (see [response docs](#response-api)).\n  adapter: function (config) {\n    /* ... */\n  },\n\n  // `auth` indicates that HTTP Basic auth should be used, and supplies credentials.\n  // This will set an `Authorization` header, overwriting any existing\n  // `Authorization` custom headers you have set using `headers`.\n  auth: {\n    username: 'janedoe',\n    password: 's00pers3cret'\n  },\n\n  // `responseType` indicates the type of data that the server will respond with\n  // options are 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'\n  responseType: 'json', // default\n\n  // `xsrfCookieName` is the name of the cookie to use as a value for xsrf token\n  xsrfCookieName: 'XSRF-TOKEN', // default\n\n  // `xsrfHeaderName` is the name of the http header that carries the xsrf token value\n  xsrfHeaderName: 'X-XSRF-TOKEN', // default\n\n  // `onUploadProgress` allows handling of progress events for uploads\n  onUploadProgress: function (progressEvent) {\n    // Do whatever you want with the native progress event\n  },\n\n  // `onDownloadProgress` allows handling of progress events for downloads\n  onDownloadProgress: function (progressEvent) {\n    // Do whatever you want with the native progress event\n  },\n\n  // `maxContentLength` defines the max size of the http response content allowed\n  maxContentLength: 2000,\n\n  // `validateStatus` defines whether to resolve or reject the promise for a given\n  // HTTP response status code. If `validateStatus` returns `true` (or is set to `null`\n  // or `undefined`), the promise will be resolved; otherwise, the promise will be\n  // rejected.\n  validateStatus: function (status) {\n    return status >= 200 && status < 300; // default\n  },\n\n  // `maxRedirects` defines the maximum number of redirects to follow in node.js.\n  // If set to 0, no redirects will be followed.\n  maxRedirects: 5, // default\n\n  // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http\n  // and https requests, respectively, in node.js. This allows to configure options like\n  // `keepAlive` that are not enabled by default.\n  httpAgent: new http.Agent({ keepAlive: true }),\n  httpsAgent: new https.Agent({ keepAlive: true }),\n\n  // 'proxy' defines the hostname and port of the proxy server\n  // `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and supplies credentials.\n  // This will set an `Proxy-Authorization` header, overwriting any existing `Proxy-Authorization` custom headers you have set using `headers`.\n  proxy: {\n    host: '127.0.0.1',\n    port: 9000,\n    auth: : {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n\n  // `cancelToken` specifies a cancel token that can be used to cancel the request\n  // (see Cancellation section below for details)\n  cancelToken: new CancelToken(function (cancel) {\n  })\n}\n```\n## 分析Config\n配置参数很多，我们一个一个来了解它们\n* **url** —— 用来向服务器发送请求的url\n* **method** —— 请求方法，默认是`GET`方法\n* **baseURL** —— 基础URL路径，假如`url`不是绝对路径，如`https://some-domain.com/api/v1/login?name=jack`,那么向服务器发送请求的URL将会是`baseURL + url`。\n* **transformRequest** —— `transformRequest`方法允许在请求发送到服务器之前修改该请求，此方法只适用于`PUT`、`POST`和`PATCH`方法中。而且，此方法最后必须返回一个string、ArrayBuffer或者Stream。\n* **transformResponse** —— `transformResponse`方法允许在数据传递到then/catch之前修改`response`数据。此方法最后也要返回数据。\n* **headers** —— 发送自定义Headers头文件，头文件中包含了http请求的各种信息。\n* **params** —— `params`是发送请求的查询参数对象，对象中的数据会被拼接成`url?param1=value1&param2=value2`。\n* **paramsSerializer** —— `params`参数序列化器。\n* **data** —— `data`是在发送`POST`、`PUT`或者`PATCH`请求的数据对象。\n* **timeout** —— 请求超时设置，单位为毫秒\n* **withCredentials** —— 表明是否有跨域请求需要用到证书\n* **adapter** —— `adapter`允许用户处理更易于测试的请求。返回一个Promise和一个有效的response\n* **auth** —— `auth`表明提供凭证用于完成http的身份验证。这将会在headers中设置一个`Authorization`授权信息。自定义`Authorization`授权要设置在`headers`中。\n* **responseType** —— 表示服务器将返回响应的数据类型，有`arraybuffer`、`blob`、`document`、`json`、`text`、`stream`这6个类型，默认是`json`类似数据。\n* **xsrfCookieName** —— 用作 xsrf token 值的 cookie 名称\n* **xsrfHeaderName** —— 带有 xsrf token 值 http head 名称\n* **onUploadProgress** ——  允许在上传过程中的做一些操作\n* **onDownloadProgress** —— 允许在下载过程中的做一些操作\n* **maxContentLength** —— 定义了接收到的response响应数据的最大长度。\n* **validateStatus** —— `validateStatus`定义了根据HTTP响应状态码决定是否接收或拒绝获取到的promise。如果 `validateStatus` 返回 `true` (或设置为 `null` 或 `undefined` ),promise将被接收;否则,promise将被拒绝。\n* **maxRedirects** —— `maxRedirects`定义了在node.js中redirect的最大值，如果设置为0，则没有redirect。\n* **httpAgent** —— 定义在使用http请求时的代理\n* **httpsAgent** —— 定义在使用https请求时的代理\n* **proxy** —— `proxy`定义代理服务器的主机名和端口，`auth`\n* **cancelToken** —— `cancelToken`定义一个 `cancel token` 用于取消请求\n\n## Response\n当我们ajax获取数据成功后会返回一个response对象，它包含了以下内容：\n```\n{\n  // `data` is the response that was provided by the server\n  data: {},\n\n  // `status` is the HTTP status code from the server response\n  status: 200,\n\n  // `statusText` is the HTTP status message from the server response\n  statusText: 'OK',\n\n  // `headers` the headers that the server responded with\n  headers: {},\n\n  // `config` is the config that was provided to `axios` for the request\n  config: {}\n}\n```\nresponse是通过promise的`then`方法来获取,具体使用方法如下：\n```\naxios.get('/user/12345')\n  .then(function(response) {\n    console.log(response.data);\n    console.log(response.status);\n    console.log(response.statusText);\n    console.log(response.headers);\n    console.log(response.config);\n  });\n```\n相对的，我们有时也会出现ajax报错，此时就会到我们的`catch`中去捕获异常`error`对象。\n\n# 为何放弃vue-resource\n尤大的原话：\n> 最近团队讨论了一下，Ajax 本身跟 Vue 并没有什么需要特别整合的地方，使用 fetch polyfill 或是 axios、superagent 等等都可以起到同等的效果，vue-resource 提供的价值和其维护成本相比并不划算，所以决定在不久以后取消对 vue-resource 的官方推荐。已有的用户可以继续使用，但以后不再把 vue-resource 作为官方的 ajax 方案。\n知乎链接：https://www.zhihu.com/question/52418455/answer/130535375\n\n# Vue.js学习系列\n鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。\n\n[Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）](http://www.jianshu.com/p/8013d8d37bd0)\n[Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）](http://www.jianshu.com/p/d6f7e11f18af)\n[Vue.js学习系列三 —— axios和网络传输相关知识的学习实践](http://www.jianshu.com/p/8e5fb763c3d7)\n[Vue.js学习系列四 —— Webpack打包工具的使用](http://www.jianshu.com/p/aef34acd111f)\n[Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint](http://www.jianshu.com/p/efb6fbed6fac)\n[Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记](http://www.jianshu.com/p/073d25a3bba0)\n[Vue.js学习系列七 —— Vue服务器渲染Nuxt学习](https://www.jianshu.com/p/ba7466d7101a)\n[Vue.js学习系列八 —— Vue源码学习之State学习](https://www.jianshu.com/p/15028f91226e)\n\n# Vue.js学习系列项目地址\n本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。\n[https://github.com/violetjack/VueStudyDemos](https://github.com/violetjack/VueStudyDemos)\n\n# 关于作者\nVioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。\n欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。\n\n新浪微博： http://weibo.com/u/2640909603\n掘金：https://gold.xitu.io/user/571d953d39b0570068145cd1\nCSDN: http://blog.csdn.net/violetjack0808\n简书： http://www.jianshu.com/users/54ae4af3a98d/latest_articles\nGithub： https://github.com/violetjack","source":"_posts/Vue.js学习系列三 —— axios和网络传输相关知识的学习实践.md","raw":"---\ntitle: Vue.js学习系列三 —— axios和网络传输相关知识的学习实践\ndate: 2017-01-09\n---\n\n> 在学习了之前的路由vue-router和状态管理vuex之后，就应该是网络交互了。就学习尤大推荐的axios了。刚好本人对网络请求这块除了会get、put、post和delete这四个方法之外知之甚少，刚好补全上。\n\n**注意：**Vue官方推荐的网络通信库不再是vue-resource了，推荐使用[axios](https://github.com/mzabriskie/axios)。\n![尤大的公告](http://upload-images.jianshu.io/upload_images/1987062-b3255d564903d3d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# axios安装\nnpm:\n```\n$ npm install axios\n```\nbower:\n```\n$ bower install axios\n```\nUsing cdn:\n```\n<script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>\n```\n# 基本使用方法\n`GET`请求\n```\n// Make a request for a user with a given ID\naxios.get('/user?ID=12345')\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n// Optionally the request above could also be done as\naxios.get('/user', {\n    params: {\n      ID: 12345\n    }\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n```\n`POST`请求\n```\n axios.post('/user', {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n```\n同时执行多个请求\n```\nfunction getUserAccount() {\n  return axios.get('/user/12345');\n}\n\nfunction getUserPermissions() {\n  return axios.get('/user/12345/permissions');\n}\n\naxios.all([getUserAccount(), getUserPermissions()])\n  .then(axios.spread(function (acct, perms) {\n    // Both requests are now complete\n  }));\n```\n其实和其他的ajax库一样，基本用法都是差不多的。大家一看就知道怎么用。\n# axios API\n可以直接通过`config`来完成请求\naxios(config)\n```\naxios({\n  method: 'post',\n  url: '/user/12345',\n  data: {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  }\n});\n```\naxios(url, [config])\n```\n// Send a GET request (default method)\naxios('/user/12345');\n```\n## 请求方法别名\n下面是axios支持的所有请求方法别名，便于各种请求。\n注：`[...]`中的数据表示可以为空。`url`是ajax请求地址；`data`是提交的数据对象；`config`是配置对象，所有ajax配置都可以在`config`中实现。\n* axios.request(config)\n* axios.get(url[, config])\n* axios.delete(url[, config])\n* axios.head(url[, config])\n* axios.post(url[, data[, config]])\n* axios.put(url[, data[, config]])\n* axios.patch(url[, data[, config]])\n\n## 并发性\n下列接口用于处理并发请求(同时处理多个多个request)\n* axios.all(iterable)\n* axios.spread(callback)\n\n## axios实例\n可以用自定义的config创建一个axios实例\naxios.create([config])\n```\nvar instance = axios.create({\n  baseURL: 'https://some-domain.com/api/',\n  timeout: 1000,\n  headers: {'X-Custom-Header': 'foobar'}\n});\n```\n## 实例方法\n下面是实例的所有可用方法，方法中的`config`会与axios实例中的config合并。（实例可以将一些通用的config先配置好）\n* axios#request(config)\n* axios#get(url, [config])\n* axios#delete(url, [config])\n* axios#head(url, [config])\n* axios#post(url[, data[, config]])\n* axios#put(url[, data[, config]])\n* axios#patch(url[, data[, config]])\n\n## Config\n重点来了，来看看Config。\n下面列出了config的所有配置项，其中之后`url`是必填的。当`method`没有指定方法，默认为`GET`。\n```\n{\n  // `url` is the server URL that will be used for the request\n  // 用来向服务器发送请求的url\n  url: '/user',\n\n  // `method` is the request method to be used when making the request\n // 请求方法\n  method: 'get', // default\n\n  // `baseURL` will be prepended to `url` unless `url` is absolute.\n  // It can be convenient to set `baseURL` for an instance of axios to pass relative URLs\n  // to methods of that instance.\n  // 假如`url`不是绝对路径，那么向服务器发送请求的URL将是`baseURL + url`\n  baseURL: 'https://some-domain.com/api/',\n\n  // `transformRequest` allows changes to the request data before it is sent to the server\n  // This is only applicable for request methods 'PUT', 'POST', and 'PATCH'\n  // The last function in the array must return a string, an ArrayBuffer, or a Stream\n  transformRequest: [function (data) {\n    // Do whatever you want to transform the data\n\n    return data;\n  }],\n\n  // `transformResponse` allows changes to the response data to be made before\n  // it is passed to then/catch\n  transformResponse: [function (data) {\n    // Do whatever you want to transform the data\n\n    return data;\n  }],\n\n  // `headers` are custom headers to be sent\n  headers: {'X-Requested-With': 'XMLHttpRequest'},\n\n  // `params` are the URL parameters to be sent with the request\n  // Must be a plain object or a URLSearchParams object\n  params: {\n    ID: 12345\n  },\n\n  // `paramsSerializer` is an optional function in charge of serializing `params`\n  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)\n  paramsSerializer: function(params) {\n    return Qs.stringify(params, {arrayFormat: 'brackets'})\n  },\n\n  // `data` is the data to be sent as the request body\n  // Only applicable for request methods 'PUT', 'POST', and 'PATCH'\n  // When no `transformRequest` is set, must be of one of the following types:\n  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams\n  // - Browser only: FormData, File, Blob\n  // - Node only: Stream\n  data: {\n    firstName: 'Fred'\n  },\n\n  // `timeout` specifies the number of milliseconds before the request times out.\n  // If the request takes longer than `timeout`, the request will be aborted.\n  timeout: 1000,\n\n  // `withCredentials` indicates whether or not cross-site Access-Control requests\n  // should be made using credentials\n  withCredentials: false, // default\n\n  // `adapter` allows custom handling of requests which makes testing easier.\n  // Return a promise and supply a valid response (see [response docs](#response-api)).\n  adapter: function (config) {\n    /* ... */\n  },\n\n  // `auth` indicates that HTTP Basic auth should be used, and supplies credentials.\n  // This will set an `Authorization` header, overwriting any existing\n  // `Authorization` custom headers you have set using `headers`.\n  auth: {\n    username: 'janedoe',\n    password: 's00pers3cret'\n  },\n\n  // `responseType` indicates the type of data that the server will respond with\n  // options are 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'\n  responseType: 'json', // default\n\n  // `xsrfCookieName` is the name of the cookie to use as a value for xsrf token\n  xsrfCookieName: 'XSRF-TOKEN', // default\n\n  // `xsrfHeaderName` is the name of the http header that carries the xsrf token value\n  xsrfHeaderName: 'X-XSRF-TOKEN', // default\n\n  // `onUploadProgress` allows handling of progress events for uploads\n  onUploadProgress: function (progressEvent) {\n    // Do whatever you want with the native progress event\n  },\n\n  // `onDownloadProgress` allows handling of progress events for downloads\n  onDownloadProgress: function (progressEvent) {\n    // Do whatever you want with the native progress event\n  },\n\n  // `maxContentLength` defines the max size of the http response content allowed\n  maxContentLength: 2000,\n\n  // `validateStatus` defines whether to resolve or reject the promise for a given\n  // HTTP response status code. If `validateStatus` returns `true` (or is set to `null`\n  // or `undefined`), the promise will be resolved; otherwise, the promise will be\n  // rejected.\n  validateStatus: function (status) {\n    return status >= 200 && status < 300; // default\n  },\n\n  // `maxRedirects` defines the maximum number of redirects to follow in node.js.\n  // If set to 0, no redirects will be followed.\n  maxRedirects: 5, // default\n\n  // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http\n  // and https requests, respectively, in node.js. This allows to configure options like\n  // `keepAlive` that are not enabled by default.\n  httpAgent: new http.Agent({ keepAlive: true }),\n  httpsAgent: new https.Agent({ keepAlive: true }),\n\n  // 'proxy' defines the hostname and port of the proxy server\n  // `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and supplies credentials.\n  // This will set an `Proxy-Authorization` header, overwriting any existing `Proxy-Authorization` custom headers you have set using `headers`.\n  proxy: {\n    host: '127.0.0.1',\n    port: 9000,\n    auth: : {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n\n  // `cancelToken` specifies a cancel token that can be used to cancel the request\n  // (see Cancellation section below for details)\n  cancelToken: new CancelToken(function (cancel) {\n  })\n}\n```\n## 分析Config\n配置参数很多，我们一个一个来了解它们\n* **url** —— 用来向服务器发送请求的url\n* **method** —— 请求方法，默认是`GET`方法\n* **baseURL** —— 基础URL路径，假如`url`不是绝对路径，如`https://some-domain.com/api/v1/login?name=jack`,那么向服务器发送请求的URL将会是`baseURL + url`。\n* **transformRequest** —— `transformRequest`方法允许在请求发送到服务器之前修改该请求，此方法只适用于`PUT`、`POST`和`PATCH`方法中。而且，此方法最后必须返回一个string、ArrayBuffer或者Stream。\n* **transformResponse** —— `transformResponse`方法允许在数据传递到then/catch之前修改`response`数据。此方法最后也要返回数据。\n* **headers** —— 发送自定义Headers头文件，头文件中包含了http请求的各种信息。\n* **params** —— `params`是发送请求的查询参数对象，对象中的数据会被拼接成`url?param1=value1&param2=value2`。\n* **paramsSerializer** —— `params`参数序列化器。\n* **data** —— `data`是在发送`POST`、`PUT`或者`PATCH`请求的数据对象。\n* **timeout** —— 请求超时设置，单位为毫秒\n* **withCredentials** —— 表明是否有跨域请求需要用到证书\n* **adapter** —— `adapter`允许用户处理更易于测试的请求。返回一个Promise和一个有效的response\n* **auth** —— `auth`表明提供凭证用于完成http的身份验证。这将会在headers中设置一个`Authorization`授权信息。自定义`Authorization`授权要设置在`headers`中。\n* **responseType** —— 表示服务器将返回响应的数据类型，有`arraybuffer`、`blob`、`document`、`json`、`text`、`stream`这6个类型，默认是`json`类似数据。\n* **xsrfCookieName** —— 用作 xsrf token 值的 cookie 名称\n* **xsrfHeaderName** —— 带有 xsrf token 值 http head 名称\n* **onUploadProgress** ——  允许在上传过程中的做一些操作\n* **onDownloadProgress** —— 允许在下载过程中的做一些操作\n* **maxContentLength** —— 定义了接收到的response响应数据的最大长度。\n* **validateStatus** —— `validateStatus`定义了根据HTTP响应状态码决定是否接收或拒绝获取到的promise。如果 `validateStatus` 返回 `true` (或设置为 `null` 或 `undefined` ),promise将被接收;否则,promise将被拒绝。\n* **maxRedirects** —— `maxRedirects`定义了在node.js中redirect的最大值，如果设置为0，则没有redirect。\n* **httpAgent** —— 定义在使用http请求时的代理\n* **httpsAgent** —— 定义在使用https请求时的代理\n* **proxy** —— `proxy`定义代理服务器的主机名和端口，`auth`\n* **cancelToken** —— `cancelToken`定义一个 `cancel token` 用于取消请求\n\n## Response\n当我们ajax获取数据成功后会返回一个response对象，它包含了以下内容：\n```\n{\n  // `data` is the response that was provided by the server\n  data: {},\n\n  // `status` is the HTTP status code from the server response\n  status: 200,\n\n  // `statusText` is the HTTP status message from the server response\n  statusText: 'OK',\n\n  // `headers` the headers that the server responded with\n  headers: {},\n\n  // `config` is the config that was provided to `axios` for the request\n  config: {}\n}\n```\nresponse是通过promise的`then`方法来获取,具体使用方法如下：\n```\naxios.get('/user/12345')\n  .then(function(response) {\n    console.log(response.data);\n    console.log(response.status);\n    console.log(response.statusText);\n    console.log(response.headers);\n    console.log(response.config);\n  });\n```\n相对的，我们有时也会出现ajax报错，此时就会到我们的`catch`中去捕获异常`error`对象。\n\n# 为何放弃vue-resource\n尤大的原话：\n> 最近团队讨论了一下，Ajax 本身跟 Vue 并没有什么需要特别整合的地方，使用 fetch polyfill 或是 axios、superagent 等等都可以起到同等的效果，vue-resource 提供的价值和其维护成本相比并不划算，所以决定在不久以后取消对 vue-resource 的官方推荐。已有的用户可以继续使用，但以后不再把 vue-resource 作为官方的 ajax 方案。\n知乎链接：https://www.zhihu.com/question/52418455/answer/130535375\n\n# Vue.js学习系列\n鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。\n\n[Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）](http://www.jianshu.com/p/8013d8d37bd0)\n[Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）](http://www.jianshu.com/p/d6f7e11f18af)\n[Vue.js学习系列三 —— axios和网络传输相关知识的学习实践](http://www.jianshu.com/p/8e5fb763c3d7)\n[Vue.js学习系列四 —— Webpack打包工具的使用](http://www.jianshu.com/p/aef34acd111f)\n[Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint](http://www.jianshu.com/p/efb6fbed6fac)\n[Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记](http://www.jianshu.com/p/073d25a3bba0)\n[Vue.js学习系列七 —— Vue服务器渲染Nuxt学习](https://www.jianshu.com/p/ba7466d7101a)\n[Vue.js学习系列八 —— Vue源码学习之State学习](https://www.jianshu.com/p/15028f91226e)\n\n# Vue.js学习系列项目地址\n本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。\n[https://github.com/violetjack/VueStudyDemos](https://github.com/violetjack/VueStudyDemos)\n\n# 关于作者\nVioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。\n欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。\n\n新浪微博： http://weibo.com/u/2640909603\n掘金：https://gold.xitu.io/user/571d953d39b0570068145cd1\nCSDN: http://blog.csdn.net/violetjack0808\n简书： http://www.jianshu.com/users/54ae4af3a98d/latest_articles\nGithub： https://github.com/violetjack","slug":"Vue.js学习系列三 —— axios和网络传输相关知识的学习实践","published":1,"updated":"2018-02-07T02:30:34.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjddwxbm50005i8btx1v61h0g","content":"<blockquote>\n<p>在学习了之前的路由vue-router和状态管理vuex之后，就应该是网络交互了。就学习尤大推荐的axios了。刚好本人对网络请求这块除了会get、put、post和delete这四个方法之外知之甚少，刚好补全上。</p>\n</blockquote>\n<p><strong>注意：</strong>Vue官方推荐的网络通信库不再是vue-resource了，推荐使用<a href=\"https://github.com/mzabriskie/axios\" target=\"_blank\" rel=\"noopener\">axios</a>。<br><img src=\"http://upload-images.jianshu.io/upload_images/1987062-b3255d564903d3d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"尤大的公告\"></p>\n<h1 id=\"axios安装\"><a href=\"#axios安装\" class=\"headerlink\" title=\"axios安装\"></a>axios安装</h1><p>npm:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install axios</span><br></pre></td></tr></table></figure></p>\n<p>bower:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ bower install axios</span><br></pre></td></tr></table></figure></p>\n<p>Using cdn:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"基本使用方法\"><a href=\"#基本使用方法\" class=\"headerlink\" title=\"基本使用方法\"></a>基本使用方法</h1><p><code>GET</code>请求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Make a request for a user with a given ID</span><br><span class=\"line\">axios.get(&apos;/user?ID=12345&apos;)</span><br><span class=\"line\">  .then(function (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Optionally the request above could also be done as</span><br><span class=\"line\">axios.get(&apos;/user&apos;, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">      ID: 12345</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(function (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p><code>POST</code>请求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.post(&apos;/user&apos;, &#123;</span><br><span class=\"line\">   firstName: &apos;Fred&apos;,</span><br><span class=\"line\">   lastName: &apos;Flintstone&apos;</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> .then(function (response) &#123;</span><br><span class=\"line\">   console.log(response);</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> .catch(function (error) &#123;</span><br><span class=\"line\">   console.log(error);</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>同时执行多个请求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getUserAccount() &#123;</span><br><span class=\"line\">  return axios.get(&apos;/user/12345&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getUserPermissions() &#123;</span><br><span class=\"line\">  return axios.get(&apos;/user/12345/permissions&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class=\"line\">  .then(axios.spread(function (acct, perms) &#123;</span><br><span class=\"line\">    // Both requests are now complete</span><br><span class=\"line\">  &#125;));</span><br></pre></td></tr></table></figure></p>\n<p>其实和其他的ajax库一样，基本用法都是差不多的。大家一看就知道怎么用。</p>\n<h1 id=\"axios-API\"><a href=\"#axios-API\" class=\"headerlink\" title=\"axios API\"></a>axios API</h1><p>可以直接通过<code>config</code>来完成请求<br>axios(config)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(&#123;</span><br><span class=\"line\">  method: &apos;post&apos;,</span><br><span class=\"line\">  url: &apos;/user/12345&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: &apos;Fred&apos;,</span><br><span class=\"line\">    lastName: &apos;Flintstone&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>axios(url, [config])<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Send a GET request (default method)</span><br><span class=\"line\">axios(&apos;/user/12345&apos;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"请求方法别名\"><a href=\"#请求方法别名\" class=\"headerlink\" title=\"请求方法别名\"></a>请求方法别名</h2><p>下面是axios支持的所有请求方法别名，便于各种请求。<br>注：<code>[...]</code>中的数据表示可以为空。<code>url</code>是ajax请求地址；<code>data</code>是提交的数据对象；<code>config</code>是配置对象，所有ajax配置都可以在<code>config</code>中实现。</p>\n<ul>\n<li>axios.request(config)</li>\n<li>axios.get(url[, config])</li>\n<li>axios.delete(url[, config])</li>\n<li>axios.head(url[, config])</li>\n<li>axios.post(url[, data[, config]])</li>\n<li>axios.put(url[, data[, config]])</li>\n<li>axios.patch(url[, data[, config]])</li>\n</ul>\n<h2 id=\"并发性\"><a href=\"#并发性\" class=\"headerlink\" title=\"并发性\"></a>并发性</h2><p>下列接口用于处理并发请求(同时处理多个多个request)</p>\n<ul>\n<li>axios.all(iterable)</li>\n<li>axios.spread(callback)</li>\n</ul>\n<h2 id=\"axios实例\"><a href=\"#axios实例\" class=\"headerlink\" title=\"axios实例\"></a>axios实例</h2><p>可以用自定义的config创建一个axios实例<br>axios.create([config])<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var instance = axios.create(&#123;</span><br><span class=\"line\">  baseURL: &apos;https://some-domain.com/api/&apos;,</span><br><span class=\"line\">  timeout: 1000,</span><br><span class=\"line\">  headers: &#123;&apos;X-Custom-Header&apos;: &apos;foobar&apos;&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h2><p>下面是实例的所有可用方法，方法中的<code>config</code>会与axios实例中的config合并。（实例可以将一些通用的config先配置好）</p>\n<ul>\n<li>axios#request(config)</li>\n<li>axios#get(url, [config])</li>\n<li>axios#delete(url, [config])</li>\n<li>axios#head(url, [config])</li>\n<li>axios#post(url[, data[, config]])</li>\n<li>axios#put(url[, data[, config]])</li>\n<li>axios#patch(url[, data[, config]])</li>\n</ul>\n<h2 id=\"Config\"><a href=\"#Config\" class=\"headerlink\" title=\"Config\"></a>Config</h2><p>重点来了，来看看Config。<br>下面列出了config的所有配置项，其中之后<code>url</code>是必填的。当<code>method</code>没有指定方法，默认为<code>GET</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  // `url` is the server URL that will be used for the request</span><br><span class=\"line\">  // 用来向服务器发送请求的url</span><br><span class=\"line\">  url: &apos;/user&apos;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `method` is the request method to be used when making the request</span><br><span class=\"line\"> // 请求方法</span><br><span class=\"line\">  method: &apos;get&apos;, // default</span><br><span class=\"line\"></span><br><span class=\"line\">  // `baseURL` will be prepended to `url` unless `url` is absolute.</span><br><span class=\"line\">  // It can be convenient to set `baseURL` for an instance of axios to pass relative URLs</span><br><span class=\"line\">  // to methods of that instance.</span><br><span class=\"line\">  // 假如`url`不是绝对路径，那么向服务器发送请求的URL将是`baseURL + url`</span><br><span class=\"line\">  baseURL: &apos;https://some-domain.com/api/&apos;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `transformRequest` allows changes to the request data before it is sent to the server</span><br><span class=\"line\">  // This is only applicable for request methods &apos;PUT&apos;, &apos;POST&apos;, and &apos;PATCH&apos;</span><br><span class=\"line\">  // The last function in the array must return a string, an ArrayBuffer, or a Stream</span><br><span class=\"line\">  transformRequest: [function (data) &#123;</span><br><span class=\"line\">    // Do whatever you want to transform the data</span><br><span class=\"line\"></span><br><span class=\"line\">    return data;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\"></span><br><span class=\"line\">  // `transformResponse` allows changes to the response data to be made before</span><br><span class=\"line\">  // it is passed to then/catch</span><br><span class=\"line\">  transformResponse: [function (data) &#123;</span><br><span class=\"line\">    // Do whatever you want to transform the data</span><br><span class=\"line\"></span><br><span class=\"line\">    return data;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\"></span><br><span class=\"line\">  // `headers` are custom headers to be sent</span><br><span class=\"line\">  headers: &#123;&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `params` are the URL parameters to be sent with the request</span><br><span class=\"line\">  // Must be a plain object or a URLSearchParams object</span><br><span class=\"line\">  params: &#123;</span><br><span class=\"line\">    ID: 12345</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `paramsSerializer` is an optional function in charge of serializing `params`</span><br><span class=\"line\">  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span><br><span class=\"line\">  paramsSerializer: function(params) &#123;</span><br><span class=\"line\">    return Qs.stringify(params, &#123;arrayFormat: &apos;brackets&apos;&#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `data` is the data to be sent as the request body</span><br><span class=\"line\">  // Only applicable for request methods &apos;PUT&apos;, &apos;POST&apos;, and &apos;PATCH&apos;</span><br><span class=\"line\">  // When no `transformRequest` is set, must be of one of the following types:</span><br><span class=\"line\">  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span><br><span class=\"line\">  // - Browser only: FormData, File, Blob</span><br><span class=\"line\">  // - Node only: Stream</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: &apos;Fred&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `timeout` specifies the number of milliseconds before the request times out.</span><br><span class=\"line\">  // If the request takes longer than `timeout`, the request will be aborted.</span><br><span class=\"line\">  timeout: 1000,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `withCredentials` indicates whether or not cross-site Access-Control requests</span><br><span class=\"line\">  // should be made using credentials</span><br><span class=\"line\">  withCredentials: false, // default</span><br><span class=\"line\"></span><br><span class=\"line\">  // `adapter` allows custom handling of requests which makes testing easier.</span><br><span class=\"line\">  // Return a promise and supply a valid response (see [response docs](#response-api)).</span><br><span class=\"line\">  adapter: function (config) &#123;</span><br><span class=\"line\">    /* ... */</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `auth` indicates that HTTP Basic auth should be used, and supplies credentials.</span><br><span class=\"line\">  // This will set an `Authorization` header, overwriting any existing</span><br><span class=\"line\">  // `Authorization` custom headers you have set using `headers`.</span><br><span class=\"line\">  auth: &#123;</span><br><span class=\"line\">    username: &apos;janedoe&apos;,</span><br><span class=\"line\">    password: &apos;s00pers3cret&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `responseType` indicates the type of data that the server will respond with</span><br><span class=\"line\">  // options are &apos;arraybuffer&apos;, &apos;blob&apos;, &apos;document&apos;, &apos;json&apos;, &apos;text&apos;, &apos;stream&apos;</span><br><span class=\"line\">  responseType: &apos;json&apos;, // default</span><br><span class=\"line\"></span><br><span class=\"line\">  // `xsrfCookieName` is the name of the cookie to use as a value for xsrf token</span><br><span class=\"line\">  xsrfCookieName: &apos;XSRF-TOKEN&apos;, // default</span><br><span class=\"line\"></span><br><span class=\"line\">  // `xsrfHeaderName` is the name of the http header that carries the xsrf token value</span><br><span class=\"line\">  xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // default</span><br><span class=\"line\"></span><br><span class=\"line\">  // `onUploadProgress` allows handling of progress events for uploads</span><br><span class=\"line\">  onUploadProgress: function (progressEvent) &#123;</span><br><span class=\"line\">    // Do whatever you want with the native progress event</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `onDownloadProgress` allows handling of progress events for downloads</span><br><span class=\"line\">  onDownloadProgress: function (progressEvent) &#123;</span><br><span class=\"line\">    // Do whatever you want with the native progress event</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `maxContentLength` defines the max size of the http response content allowed</span><br><span class=\"line\">  maxContentLength: 2000,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `validateStatus` defines whether to resolve or reject the promise for a given</span><br><span class=\"line\">  // HTTP response status code. If `validateStatus` returns `true` (or is set to `null`</span><br><span class=\"line\">  // or `undefined`), the promise will be resolved; otherwise, the promise will be</span><br><span class=\"line\">  // rejected.</span><br><span class=\"line\">  validateStatus: function (status) &#123;</span><br><span class=\"line\">    return status &gt;= 200 &amp;&amp; status &lt; 300; // default</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `maxRedirects` defines the maximum number of redirects to follow in node.js.</span><br><span class=\"line\">  // If set to 0, no redirects will be followed.</span><br><span class=\"line\">  maxRedirects: 5, // default</span><br><span class=\"line\"></span><br><span class=\"line\">  // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http</span><br><span class=\"line\">  // and https requests, respectively, in node.js. This allows to configure options like</span><br><span class=\"line\">  // `keepAlive` that are not enabled by default.</span><br><span class=\"line\">  httpAgent: new http.Agent(&#123; keepAlive: true &#125;),</span><br><span class=\"line\">  httpsAgent: new https.Agent(&#123; keepAlive: true &#125;),</span><br><span class=\"line\"></span><br><span class=\"line\">  // &apos;proxy&apos; defines the hostname and port of the proxy server</span><br><span class=\"line\">  // `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and supplies credentials.</span><br><span class=\"line\">  // This will set an `Proxy-Authorization` header, overwriting any existing `Proxy-Authorization` custom headers you have set using `headers`.</span><br><span class=\"line\">  proxy: &#123;</span><br><span class=\"line\">    host: &apos;127.0.0.1&apos;,</span><br><span class=\"line\">    port: 9000,</span><br><span class=\"line\">    auth: : &#123;</span><br><span class=\"line\">      username: &apos;mikeymike&apos;,</span><br><span class=\"line\">      password: &apos;rapunz3l&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `cancelToken` specifies a cancel token that can be used to cancel the request</span><br><span class=\"line\">  // (see Cancellation section below for details)</span><br><span class=\"line\">  cancelToken: new CancelToken(function (cancel) &#123;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"分析Config\"><a href=\"#分析Config\" class=\"headerlink\" title=\"分析Config\"></a>分析Config</h2><p>配置参数很多，我们一个一个来了解它们</p>\n<ul>\n<li><strong>url</strong> —— 用来向服务器发送请求的url</li>\n<li><strong>method</strong> —— 请求方法，默认是<code>GET</code>方法</li>\n<li><strong>baseURL</strong> —— 基础URL路径，假如<code>url</code>不是绝对路径，如<code>https://some-domain.com/api/v1/login?name=jack</code>,那么向服务器发送请求的URL将会是<code>baseURL + url</code>。</li>\n<li><strong>transformRequest</strong> —— <code>transformRequest</code>方法允许在请求发送到服务器之前修改该请求，此方法只适用于<code>PUT</code>、<code>POST</code>和<code>PATCH</code>方法中。而且，此方法最后必须返回一个string、ArrayBuffer或者Stream。</li>\n<li><strong>transformResponse</strong> —— <code>transformResponse</code>方法允许在数据传递到then/catch之前修改<code>response</code>数据。此方法最后也要返回数据。</li>\n<li><strong>headers</strong> —— 发送自定义Headers头文件，头文件中包含了http请求的各种信息。</li>\n<li><strong>params</strong> —— <code>params</code>是发送请求的查询参数对象，对象中的数据会被拼接成<code>url?param1=value1&amp;param2=value2</code>。</li>\n<li><strong>paramsSerializer</strong> —— <code>params</code>参数序列化器。</li>\n<li><strong>data</strong> —— <code>data</code>是在发送<code>POST</code>、<code>PUT</code>或者<code>PATCH</code>请求的数据对象。</li>\n<li><strong>timeout</strong> —— 请求超时设置，单位为毫秒</li>\n<li><strong>withCredentials</strong> —— 表明是否有跨域请求需要用到证书</li>\n<li><strong>adapter</strong> —— <code>adapter</code>允许用户处理更易于测试的请求。返回一个Promise和一个有效的response</li>\n<li><strong>auth</strong> —— <code>auth</code>表明提供凭证用于完成http的身份验证。这将会在headers中设置一个<code>Authorization</code>授权信息。自定义<code>Authorization</code>授权要设置在<code>headers</code>中。</li>\n<li><strong>responseType</strong> —— 表示服务器将返回响应的数据类型，有<code>arraybuffer</code>、<code>blob</code>、<code>document</code>、<code>json</code>、<code>text</code>、<code>stream</code>这6个类型，默认是<code>json</code>类似数据。</li>\n<li><strong>xsrfCookieName</strong> —— 用作 xsrf token 值的 cookie 名称</li>\n<li><strong>xsrfHeaderName</strong> —— 带有 xsrf token 值 http head 名称</li>\n<li><strong>onUploadProgress</strong> ——  允许在上传过程中的做一些操作</li>\n<li><strong>onDownloadProgress</strong> —— 允许在下载过程中的做一些操作</li>\n<li><strong>maxContentLength</strong> —— 定义了接收到的response响应数据的最大长度。</li>\n<li><strong>validateStatus</strong> —— <code>validateStatus</code>定义了根据HTTP响应状态码决定是否接收或拒绝获取到的promise。如果 <code>validateStatus</code> 返回 <code>true</code> (或设置为 <code>null</code> 或 <code>undefined</code> ),promise将被接收;否则,promise将被拒绝。</li>\n<li><strong>maxRedirects</strong> —— <code>maxRedirects</code>定义了在node.js中redirect的最大值，如果设置为0，则没有redirect。</li>\n<li><strong>httpAgent</strong> —— 定义在使用http请求时的代理</li>\n<li><strong>httpsAgent</strong> —— 定义在使用https请求时的代理</li>\n<li><strong>proxy</strong> —— <code>proxy</code>定义代理服务器的主机名和端口，<code>auth</code></li>\n<li><strong>cancelToken</strong> —— <code>cancelToken</code>定义一个 <code>cancel token</code> 用于取消请求</li>\n</ul>\n<h2 id=\"Response\"><a href=\"#Response\" class=\"headerlink\" title=\"Response\"></a>Response</h2><p>当我们ajax获取数据成功后会返回一个response对象，它包含了以下内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  // `data` is the response that was provided by the server</span><br><span class=\"line\">  data: &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `status` is the HTTP status code from the server response</span><br><span class=\"line\">  status: 200,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `statusText` is the HTTP status message from the server response</span><br><span class=\"line\">  statusText: &apos;OK&apos;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `headers` the headers that the server responded with</span><br><span class=\"line\">  headers: &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `config` is the config that was provided to `axios` for the request</span><br><span class=\"line\">  config: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>response是通过promise的<code>then</code>方法来获取,具体使用方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.get(&apos;/user/12345&apos;)</span><br><span class=\"line\">  .then(function(response) &#123;</span><br><span class=\"line\">    console.log(response.data);</span><br><span class=\"line\">    console.log(response.status);</span><br><span class=\"line\">    console.log(response.statusText);</span><br><span class=\"line\">    console.log(response.headers);</span><br><span class=\"line\">    console.log(response.config);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>相对的，我们有时也会出现ajax报错，此时就会到我们的<code>catch</code>中去捕获异常<code>error</code>对象。</p>\n<h1 id=\"为何放弃vue-resource\"><a href=\"#为何放弃vue-resource\" class=\"headerlink\" title=\"为何放弃vue-resource\"></a>为何放弃vue-resource</h1><p>尤大的原话：</p>\n<blockquote>\n<p>最近团队讨论了一下，Ajax 本身跟 Vue 并没有什么需要特别整合的地方，使用 fetch polyfill 或是 axios、superagent 等等都可以起到同等的效果，vue-resource 提供的价值和其维护成本相比并不划算，所以决定在不久以后取消对 vue-resource 的官方推荐。已有的用户可以继续使用，但以后不再把 vue-resource 作为官方的 ajax 方案。<br>知乎链接：<a href=\"https://www.zhihu.com/question/52418455/answer/130535375\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/52418455/answer/130535375</a></p>\n</blockquote>\n<h1 id=\"Vue-js学习系列\"><a href=\"#Vue-js学习系列\" class=\"headerlink\" title=\"Vue.js学习系列\"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>\n<p><a href=\"http://www.jianshu.com/p/8013d8d37bd0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/d6f7e11f18af\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/8e5fb763c3d7\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href=\"http://www.jianshu.com/p/aef34acd111f\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href=\"http://www.jianshu.com/p/efb6fbed6fac\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href=\"http://www.jianshu.com/p/073d25a3bba0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href=\"https://www.jianshu.com/p/ba7466d7101a\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href=\"https://www.jianshu.com/p/15028f91226e\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>\n<h1 id=\"Vue-js学习系列项目地址\"><a href=\"#Vue-js学习系列项目地址\" class=\"headerlink\" title=\"Vue.js学习系列项目地址\"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack/VueStudyDemos</a></p>\n<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>\n<p>新浪微博： <a href=\"http://weibo.com/u/2640909603\" target=\"_blank\" rel=\"noopener\">http://weibo.com/u/2640909603</a><br>掘金：<a href=\"https://gold.xitu.io/user/571d953d39b0570068145cd1\" target=\"_blank\" rel=\"noopener\">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href=\"http://blog.csdn.net/violetjack0808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/violetjack0808</a><br>简书： <a href=\"http://www.jianshu.com/users/54ae4af3a98d/latest_articles\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href=\"https://github.com/violetjack\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在学习了之前的路由vue-router和状态管理vuex之后，就应该是网络交互了。就学习尤大推荐的axios了。刚好本人对网络请求这块除了会get、put、post和delete这四个方法之外知之甚少，刚好补全上。</p>\n</blockquote>\n<p><strong>注意：</strong>Vue官方推荐的网络通信库不再是vue-resource了，推荐使用<a href=\"https://github.com/mzabriskie/axios\" target=\"_blank\" rel=\"noopener\">axios</a>。<br><img src=\"http://upload-images.jianshu.io/upload_images/1987062-b3255d564903d3d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"尤大的公告\"></p>\n<h1 id=\"axios安装\"><a href=\"#axios安装\" class=\"headerlink\" title=\"axios安装\"></a>axios安装</h1><p>npm:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install axios</span><br></pre></td></tr></table></figure></p>\n<p>bower:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ bower install axios</span><br></pre></td></tr></table></figure></p>\n<p>Using cdn:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"基本使用方法\"><a href=\"#基本使用方法\" class=\"headerlink\" title=\"基本使用方法\"></a>基本使用方法</h1><p><code>GET</code>请求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Make a request for a user with a given ID</span><br><span class=\"line\">axios.get(&apos;/user?ID=12345&apos;)</span><br><span class=\"line\">  .then(function (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Optionally the request above could also be done as</span><br><span class=\"line\">axios.get(&apos;/user&apos;, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">      ID: 12345</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(function (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p><code>POST</code>请求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.post(&apos;/user&apos;, &#123;</span><br><span class=\"line\">   firstName: &apos;Fred&apos;,</span><br><span class=\"line\">   lastName: &apos;Flintstone&apos;</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> .then(function (response) &#123;</span><br><span class=\"line\">   console.log(response);</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> .catch(function (error) &#123;</span><br><span class=\"line\">   console.log(error);</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>同时执行多个请求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getUserAccount() &#123;</span><br><span class=\"line\">  return axios.get(&apos;/user/12345&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getUserPermissions() &#123;</span><br><span class=\"line\">  return axios.get(&apos;/user/12345/permissions&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class=\"line\">  .then(axios.spread(function (acct, perms) &#123;</span><br><span class=\"line\">    // Both requests are now complete</span><br><span class=\"line\">  &#125;));</span><br></pre></td></tr></table></figure></p>\n<p>其实和其他的ajax库一样，基本用法都是差不多的。大家一看就知道怎么用。</p>\n<h1 id=\"axios-API\"><a href=\"#axios-API\" class=\"headerlink\" title=\"axios API\"></a>axios API</h1><p>可以直接通过<code>config</code>来完成请求<br>axios(config)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(&#123;</span><br><span class=\"line\">  method: &apos;post&apos;,</span><br><span class=\"line\">  url: &apos;/user/12345&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: &apos;Fred&apos;,</span><br><span class=\"line\">    lastName: &apos;Flintstone&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>axios(url, [config])<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Send a GET request (default method)</span><br><span class=\"line\">axios(&apos;/user/12345&apos;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"请求方法别名\"><a href=\"#请求方法别名\" class=\"headerlink\" title=\"请求方法别名\"></a>请求方法别名</h2><p>下面是axios支持的所有请求方法别名，便于各种请求。<br>注：<code>[...]</code>中的数据表示可以为空。<code>url</code>是ajax请求地址；<code>data</code>是提交的数据对象；<code>config</code>是配置对象，所有ajax配置都可以在<code>config</code>中实现。</p>\n<ul>\n<li>axios.request(config)</li>\n<li>axios.get(url[, config])</li>\n<li>axios.delete(url[, config])</li>\n<li>axios.head(url[, config])</li>\n<li>axios.post(url[, data[, config]])</li>\n<li>axios.put(url[, data[, config]])</li>\n<li>axios.patch(url[, data[, config]])</li>\n</ul>\n<h2 id=\"并发性\"><a href=\"#并发性\" class=\"headerlink\" title=\"并发性\"></a>并发性</h2><p>下列接口用于处理并发请求(同时处理多个多个request)</p>\n<ul>\n<li>axios.all(iterable)</li>\n<li>axios.spread(callback)</li>\n</ul>\n<h2 id=\"axios实例\"><a href=\"#axios实例\" class=\"headerlink\" title=\"axios实例\"></a>axios实例</h2><p>可以用自定义的config创建一个axios实例<br>axios.create([config])<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var instance = axios.create(&#123;</span><br><span class=\"line\">  baseURL: &apos;https://some-domain.com/api/&apos;,</span><br><span class=\"line\">  timeout: 1000,</span><br><span class=\"line\">  headers: &#123;&apos;X-Custom-Header&apos;: &apos;foobar&apos;&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h2><p>下面是实例的所有可用方法，方法中的<code>config</code>会与axios实例中的config合并。（实例可以将一些通用的config先配置好）</p>\n<ul>\n<li>axios#request(config)</li>\n<li>axios#get(url, [config])</li>\n<li>axios#delete(url, [config])</li>\n<li>axios#head(url, [config])</li>\n<li>axios#post(url[, data[, config]])</li>\n<li>axios#put(url[, data[, config]])</li>\n<li>axios#patch(url[, data[, config]])</li>\n</ul>\n<h2 id=\"Config\"><a href=\"#Config\" class=\"headerlink\" title=\"Config\"></a>Config</h2><p>重点来了，来看看Config。<br>下面列出了config的所有配置项，其中之后<code>url</code>是必填的。当<code>method</code>没有指定方法，默认为<code>GET</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  // `url` is the server URL that will be used for the request</span><br><span class=\"line\">  // 用来向服务器发送请求的url</span><br><span class=\"line\">  url: &apos;/user&apos;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `method` is the request method to be used when making the request</span><br><span class=\"line\"> // 请求方法</span><br><span class=\"line\">  method: &apos;get&apos;, // default</span><br><span class=\"line\"></span><br><span class=\"line\">  // `baseURL` will be prepended to `url` unless `url` is absolute.</span><br><span class=\"line\">  // It can be convenient to set `baseURL` for an instance of axios to pass relative URLs</span><br><span class=\"line\">  // to methods of that instance.</span><br><span class=\"line\">  // 假如`url`不是绝对路径，那么向服务器发送请求的URL将是`baseURL + url`</span><br><span class=\"line\">  baseURL: &apos;https://some-domain.com/api/&apos;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `transformRequest` allows changes to the request data before it is sent to the server</span><br><span class=\"line\">  // This is only applicable for request methods &apos;PUT&apos;, &apos;POST&apos;, and &apos;PATCH&apos;</span><br><span class=\"line\">  // The last function in the array must return a string, an ArrayBuffer, or a Stream</span><br><span class=\"line\">  transformRequest: [function (data) &#123;</span><br><span class=\"line\">    // Do whatever you want to transform the data</span><br><span class=\"line\"></span><br><span class=\"line\">    return data;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\"></span><br><span class=\"line\">  // `transformResponse` allows changes to the response data to be made before</span><br><span class=\"line\">  // it is passed to then/catch</span><br><span class=\"line\">  transformResponse: [function (data) &#123;</span><br><span class=\"line\">    // Do whatever you want to transform the data</span><br><span class=\"line\"></span><br><span class=\"line\">    return data;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\"></span><br><span class=\"line\">  // `headers` are custom headers to be sent</span><br><span class=\"line\">  headers: &#123;&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `params` are the URL parameters to be sent with the request</span><br><span class=\"line\">  // Must be a plain object or a URLSearchParams object</span><br><span class=\"line\">  params: &#123;</span><br><span class=\"line\">    ID: 12345</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `paramsSerializer` is an optional function in charge of serializing `params`</span><br><span class=\"line\">  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span><br><span class=\"line\">  paramsSerializer: function(params) &#123;</span><br><span class=\"line\">    return Qs.stringify(params, &#123;arrayFormat: &apos;brackets&apos;&#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `data` is the data to be sent as the request body</span><br><span class=\"line\">  // Only applicable for request methods &apos;PUT&apos;, &apos;POST&apos;, and &apos;PATCH&apos;</span><br><span class=\"line\">  // When no `transformRequest` is set, must be of one of the following types:</span><br><span class=\"line\">  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span><br><span class=\"line\">  // - Browser only: FormData, File, Blob</span><br><span class=\"line\">  // - Node only: Stream</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    firstName: &apos;Fred&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `timeout` specifies the number of milliseconds before the request times out.</span><br><span class=\"line\">  // If the request takes longer than `timeout`, the request will be aborted.</span><br><span class=\"line\">  timeout: 1000,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `withCredentials` indicates whether or not cross-site Access-Control requests</span><br><span class=\"line\">  // should be made using credentials</span><br><span class=\"line\">  withCredentials: false, // default</span><br><span class=\"line\"></span><br><span class=\"line\">  // `adapter` allows custom handling of requests which makes testing easier.</span><br><span class=\"line\">  // Return a promise and supply a valid response (see [response docs](#response-api)).</span><br><span class=\"line\">  adapter: function (config) &#123;</span><br><span class=\"line\">    /* ... */</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `auth` indicates that HTTP Basic auth should be used, and supplies credentials.</span><br><span class=\"line\">  // This will set an `Authorization` header, overwriting any existing</span><br><span class=\"line\">  // `Authorization` custom headers you have set using `headers`.</span><br><span class=\"line\">  auth: &#123;</span><br><span class=\"line\">    username: &apos;janedoe&apos;,</span><br><span class=\"line\">    password: &apos;s00pers3cret&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `responseType` indicates the type of data that the server will respond with</span><br><span class=\"line\">  // options are &apos;arraybuffer&apos;, &apos;blob&apos;, &apos;document&apos;, &apos;json&apos;, &apos;text&apos;, &apos;stream&apos;</span><br><span class=\"line\">  responseType: &apos;json&apos;, // default</span><br><span class=\"line\"></span><br><span class=\"line\">  // `xsrfCookieName` is the name of the cookie to use as a value for xsrf token</span><br><span class=\"line\">  xsrfCookieName: &apos;XSRF-TOKEN&apos;, // default</span><br><span class=\"line\"></span><br><span class=\"line\">  // `xsrfHeaderName` is the name of the http header that carries the xsrf token value</span><br><span class=\"line\">  xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // default</span><br><span class=\"line\"></span><br><span class=\"line\">  // `onUploadProgress` allows handling of progress events for uploads</span><br><span class=\"line\">  onUploadProgress: function (progressEvent) &#123;</span><br><span class=\"line\">    // Do whatever you want with the native progress event</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `onDownloadProgress` allows handling of progress events for downloads</span><br><span class=\"line\">  onDownloadProgress: function (progressEvent) &#123;</span><br><span class=\"line\">    // Do whatever you want with the native progress event</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `maxContentLength` defines the max size of the http response content allowed</span><br><span class=\"line\">  maxContentLength: 2000,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `validateStatus` defines whether to resolve or reject the promise for a given</span><br><span class=\"line\">  // HTTP response status code. If `validateStatus` returns `true` (or is set to `null`</span><br><span class=\"line\">  // or `undefined`), the promise will be resolved; otherwise, the promise will be</span><br><span class=\"line\">  // rejected.</span><br><span class=\"line\">  validateStatus: function (status) &#123;</span><br><span class=\"line\">    return status &gt;= 200 &amp;&amp; status &lt; 300; // default</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `maxRedirects` defines the maximum number of redirects to follow in node.js.</span><br><span class=\"line\">  // If set to 0, no redirects will be followed.</span><br><span class=\"line\">  maxRedirects: 5, // default</span><br><span class=\"line\"></span><br><span class=\"line\">  // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http</span><br><span class=\"line\">  // and https requests, respectively, in node.js. This allows to configure options like</span><br><span class=\"line\">  // `keepAlive` that are not enabled by default.</span><br><span class=\"line\">  httpAgent: new http.Agent(&#123; keepAlive: true &#125;),</span><br><span class=\"line\">  httpsAgent: new https.Agent(&#123; keepAlive: true &#125;),</span><br><span class=\"line\"></span><br><span class=\"line\">  // &apos;proxy&apos; defines the hostname and port of the proxy server</span><br><span class=\"line\">  // `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and supplies credentials.</span><br><span class=\"line\">  // This will set an `Proxy-Authorization` header, overwriting any existing `Proxy-Authorization` custom headers you have set using `headers`.</span><br><span class=\"line\">  proxy: &#123;</span><br><span class=\"line\">    host: &apos;127.0.0.1&apos;,</span><br><span class=\"line\">    port: 9000,</span><br><span class=\"line\">    auth: : &#123;</span><br><span class=\"line\">      username: &apos;mikeymike&apos;,</span><br><span class=\"line\">      password: &apos;rapunz3l&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `cancelToken` specifies a cancel token that can be used to cancel the request</span><br><span class=\"line\">  // (see Cancellation section below for details)</span><br><span class=\"line\">  cancelToken: new CancelToken(function (cancel) &#123;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"分析Config\"><a href=\"#分析Config\" class=\"headerlink\" title=\"分析Config\"></a>分析Config</h2><p>配置参数很多，我们一个一个来了解它们</p>\n<ul>\n<li><strong>url</strong> —— 用来向服务器发送请求的url</li>\n<li><strong>method</strong> —— 请求方法，默认是<code>GET</code>方法</li>\n<li><strong>baseURL</strong> —— 基础URL路径，假如<code>url</code>不是绝对路径，如<code>https://some-domain.com/api/v1/login?name=jack</code>,那么向服务器发送请求的URL将会是<code>baseURL + url</code>。</li>\n<li><strong>transformRequest</strong> —— <code>transformRequest</code>方法允许在请求发送到服务器之前修改该请求，此方法只适用于<code>PUT</code>、<code>POST</code>和<code>PATCH</code>方法中。而且，此方法最后必须返回一个string、ArrayBuffer或者Stream。</li>\n<li><strong>transformResponse</strong> —— <code>transformResponse</code>方法允许在数据传递到then/catch之前修改<code>response</code>数据。此方法最后也要返回数据。</li>\n<li><strong>headers</strong> —— 发送自定义Headers头文件，头文件中包含了http请求的各种信息。</li>\n<li><strong>params</strong> —— <code>params</code>是发送请求的查询参数对象，对象中的数据会被拼接成<code>url?param1=value1&amp;param2=value2</code>。</li>\n<li><strong>paramsSerializer</strong> —— <code>params</code>参数序列化器。</li>\n<li><strong>data</strong> —— <code>data</code>是在发送<code>POST</code>、<code>PUT</code>或者<code>PATCH</code>请求的数据对象。</li>\n<li><strong>timeout</strong> —— 请求超时设置，单位为毫秒</li>\n<li><strong>withCredentials</strong> —— 表明是否有跨域请求需要用到证书</li>\n<li><strong>adapter</strong> —— <code>adapter</code>允许用户处理更易于测试的请求。返回一个Promise和一个有效的response</li>\n<li><strong>auth</strong> —— <code>auth</code>表明提供凭证用于完成http的身份验证。这将会在headers中设置一个<code>Authorization</code>授权信息。自定义<code>Authorization</code>授权要设置在<code>headers</code>中。</li>\n<li><strong>responseType</strong> —— 表示服务器将返回响应的数据类型，有<code>arraybuffer</code>、<code>blob</code>、<code>document</code>、<code>json</code>、<code>text</code>、<code>stream</code>这6个类型，默认是<code>json</code>类似数据。</li>\n<li><strong>xsrfCookieName</strong> —— 用作 xsrf token 值的 cookie 名称</li>\n<li><strong>xsrfHeaderName</strong> —— 带有 xsrf token 值 http head 名称</li>\n<li><strong>onUploadProgress</strong> ——  允许在上传过程中的做一些操作</li>\n<li><strong>onDownloadProgress</strong> —— 允许在下载过程中的做一些操作</li>\n<li><strong>maxContentLength</strong> —— 定义了接收到的response响应数据的最大长度。</li>\n<li><strong>validateStatus</strong> —— <code>validateStatus</code>定义了根据HTTP响应状态码决定是否接收或拒绝获取到的promise。如果 <code>validateStatus</code> 返回 <code>true</code> (或设置为 <code>null</code> 或 <code>undefined</code> ),promise将被接收;否则,promise将被拒绝。</li>\n<li><strong>maxRedirects</strong> —— <code>maxRedirects</code>定义了在node.js中redirect的最大值，如果设置为0，则没有redirect。</li>\n<li><strong>httpAgent</strong> —— 定义在使用http请求时的代理</li>\n<li><strong>httpsAgent</strong> —— 定义在使用https请求时的代理</li>\n<li><strong>proxy</strong> —— <code>proxy</code>定义代理服务器的主机名和端口，<code>auth</code></li>\n<li><strong>cancelToken</strong> —— <code>cancelToken</code>定义一个 <code>cancel token</code> 用于取消请求</li>\n</ul>\n<h2 id=\"Response\"><a href=\"#Response\" class=\"headerlink\" title=\"Response\"></a>Response</h2><p>当我们ajax获取数据成功后会返回一个response对象，它包含了以下内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  // `data` is the response that was provided by the server</span><br><span class=\"line\">  data: &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `status` is the HTTP status code from the server response</span><br><span class=\"line\">  status: 200,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `statusText` is the HTTP status message from the server response</span><br><span class=\"line\">  statusText: &apos;OK&apos;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `headers` the headers that the server responded with</span><br><span class=\"line\">  headers: &#123;&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // `config` is the config that was provided to `axios` for the request</span><br><span class=\"line\">  config: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>response是通过promise的<code>then</code>方法来获取,具体使用方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.get(&apos;/user/12345&apos;)</span><br><span class=\"line\">  .then(function(response) &#123;</span><br><span class=\"line\">    console.log(response.data);</span><br><span class=\"line\">    console.log(response.status);</span><br><span class=\"line\">    console.log(response.statusText);</span><br><span class=\"line\">    console.log(response.headers);</span><br><span class=\"line\">    console.log(response.config);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>相对的，我们有时也会出现ajax报错，此时就会到我们的<code>catch</code>中去捕获异常<code>error</code>对象。</p>\n<h1 id=\"为何放弃vue-resource\"><a href=\"#为何放弃vue-resource\" class=\"headerlink\" title=\"为何放弃vue-resource\"></a>为何放弃vue-resource</h1><p>尤大的原话：</p>\n<blockquote>\n<p>最近团队讨论了一下，Ajax 本身跟 Vue 并没有什么需要特别整合的地方，使用 fetch polyfill 或是 axios、superagent 等等都可以起到同等的效果，vue-resource 提供的价值和其维护成本相比并不划算，所以决定在不久以后取消对 vue-resource 的官方推荐。已有的用户可以继续使用，但以后不再把 vue-resource 作为官方的 ajax 方案。<br>知乎链接：<a href=\"https://www.zhihu.com/question/52418455/answer/130535375\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/52418455/answer/130535375</a></p>\n</blockquote>\n<h1 id=\"Vue-js学习系列\"><a href=\"#Vue-js学习系列\" class=\"headerlink\" title=\"Vue.js学习系列\"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>\n<p><a href=\"http://www.jianshu.com/p/8013d8d37bd0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/d6f7e11f18af\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/8e5fb763c3d7\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href=\"http://www.jianshu.com/p/aef34acd111f\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href=\"http://www.jianshu.com/p/efb6fbed6fac\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href=\"http://www.jianshu.com/p/073d25a3bba0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href=\"https://www.jianshu.com/p/ba7466d7101a\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href=\"https://www.jianshu.com/p/15028f91226e\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>\n<h1 id=\"Vue-js学习系列项目地址\"><a href=\"#Vue-js学习系列项目地址\" class=\"headerlink\" title=\"Vue.js学习系列项目地址\"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack/VueStudyDemos</a></p>\n<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>\n<p>新浪微博： <a href=\"http://weibo.com/u/2640909603\" target=\"_blank\" rel=\"noopener\">http://weibo.com/u/2640909603</a><br>掘金：<a href=\"https://gold.xitu.io/user/571d953d39b0570068145cd1\" target=\"_blank\" rel=\"noopener\">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href=\"http://blog.csdn.net/violetjack0808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/violetjack0808</a><br>简书： <a href=\"http://www.jianshu.com/users/54ae4af3a98d/latest_articles\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href=\"https://github.com/violetjack\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack</a></p>\n"},{"title":"Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）","date":"2016-12-30T16:00:00.000Z","_content":"\n> 上次学习了vue-router的使用，让我能够在各个页面间切换，将页面搭建了起来。这次则要学习vue的状态管理模式——vuex。\n\n**注**：本文只是个人对vuex学习的一些理解，要深刻掌握还需要认真查阅[官方文档](http://vuex.vuejs.org/zh-cn/)。\n\n# 一、基本介绍\nVuex 是一个专为 Vue.js 的SPA单页组件化应用程序开发的**状态管理模式**插件。\n由于Vue SPA应用的模块化，每个组件都有它各自的数据(state)、界面(view)、和方法(actions)。这些数据、界面和方法分布在各个组件中，当项目内容变得越来越多时，每个组件中的状态会变得很难管理。这是vuex就派上用场啦~下面我们看一个简单的vuex例子。\n## 1. 单个组件中的状态\n假如只是在单个组件中要改变界面view很简单，只需要改变state数据源即可。如下代码：\n```\n<template>\n    <div>\n      view: {{ count }}\n      <button @click=\"increment\">increment</button>\n    </div>\n</template>\n\n<script>\nexport default {\n  // state\n  data () {\n    return {\n      count: 0\n    }\n  },\n  // actions\n  methods: {\n    increment () {\n      this.count++\n    }\n  }\n}\n</script>\n```\n所以，单个组件中的原理图是这样的：\n\n![单个组件中的原理图](http://upload-images.jianshu.io/upload_images/1987062-29836e1cb7325526.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 2. 多个组件中的状态\n然而，我们作为组件化的SPA应用，必定会牵扯到多个组件间的通信。\n比如有两个相同的组件A和B，它们共享一个数据count，并且都有一个方法可以操作这个count，我们使用vuex来写。\n**A组件和B组件的代码（代码相同）**\n```\n<template>\n  <div>\n    {{ $store.state.count }}\n    <button @click=\"increment\">increment</button>\n  </div>\n</template>\n\n<script>\n  export default {\n    methods: {\n      increment () {\n        this.$store.commit('increment')\n      }\n    }\n  }\n</script>\n```\n\n![结果1](http://upload-images.jianshu.io/upload_images/1987062-5971ec429e2ac23b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![结果2](http://upload-images.jianshu.io/upload_images/1987062-22872b0aa75b7f42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到，这里的两个increment按钮点击都会同时改变两个count的数据，**因为数据源count和方法increment都是全局的。**\n正如下面官方原理图所画的，我们把**全局数据源state、改变数据源的方法mutations、异步操作方法actions**都放提取出来放到store中，实现全局数据状态单独管理的功能。\n![vuex官方原理图](http://upload-images.jianshu.io/upload_images/1987062-9867083201b0c86e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 二、安装&配置\n## 1. 安装vuex\n使用npm安装并保存到package.json中：\n```\nnpm install vuex --save\n```\n**package.json**\n```\n  \"devDependencies\": {\n    ...\n    \"vuex\": \"^2.1.1\",\n    ...\n  },\n```\n## 2. 配置\n配置方式和路由的配置方式差不多\n```\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n//创建Store实例\nconst store = new Vuex.Store({\n  // 存储状态值\n  state: {\n    ...\n  },\n  // 状态值的改变方法,操作状态值\n  // 提交mutations是更改Vuex状态的唯一方法\n  mutations: {\n    ...\n  },\n  // 在store中定义getters（可以认为是store的计算属性）。Getters接收state作为其第一个函数\n  getters: {\n    ...\n  },\n  actions: { \n    ...\n  }\n})\n// 要改变状态值只能通过提交mutations来完成\n\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  template: '<App/>',\n  components: { App },\n  // 将store实例注入到根组件下的所有子组件中\n  store\n  // 子组件通过this.$store来方位store\n})\n\n```\n# 三、核心概念\n## 1. state\nstate就是全局的状态（数据源），我们可以用以下方式在Vue 组件中获得Vuex的state状态\n**template**\n```\n  <div>\n    {{ $store.state.count }}\n  </div>\n```\n**script**\n```\nconsole.log(this.$store.state.count)\n```\n## 2. getters\ngetters其实可以认为是 store 的计算属性，用法和计算属性差不多。\n定义getter：\n```\n  getters: {\n    done(state) {\n      return state.count + 5;\n    },\n  }\n```\n使用getter\n```\nconsole.log(this.$store.getters.done)\n```\n## 3. mutations\nmutations是操作state的唯一方法，即只有mutations方法能够改变state状态值。\n### 3.1 基本操作\n**mutations对state的操作**\n```\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n```\n**组件通过commit提交mutations的方式来请求改变state**\n```\nthis.$store.commit('increment')\n```\n这样的好处是我们可以跟踪到每一次state的变化，以便及时分析和解决问题。\n### 3.2 提交载荷（Payload）\nmutations方法中是可以传参的，具体用法如下：\n```\n  mutations: {\n    // 提交载荷 Payload\n    add(state, n) {\n      state.count += n\n    }\n  },\n```\n```\nthis.$store.commit('add', 10)\n```\n这里只是传了一个数字，在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读。\n### 3.3 注意\n**mutations方法必须是同步方法！**\n## 4. actions\n### 4.1 基本操作\n之前说mutations方法必须只能是同步方法，为了处理异步方法，actions出现了。关于action和mutations的区别有以下几点：\n* Action 提交的是 mutation，而不是直接变更状态。\n* Action 可以包含任意异步操作。\n* Action 还是得通过 mutation 方法来修改state\n同样是之前的increment方法,我们分别用同步和异步的action来验证上面所说的与mutations的不同之处：\n```\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    },\n    incrementAsync (context) {\n      // 延时1秒  \n      setTimeout(() => {\n        context.commit('increment')\n      }, 1000)\n    }\n  },\n```\n不同于mutations使用commit方法，actions使用dispatch方法。\n```\nthis.$store.dispatch('incrementAsync')\n```\n\n### 4.2 context\n**context是与 store 实例具有相同方法和属性的对象。**可以通过`context.state`和`context.getters`来获取 state 和 getters。\n### 4.3 以载荷形式分发\n```\n    incrementAsyncWithValue (context, value) {\n      setTimeout(() => {\n        context.commit('add', value)\n      }, 1000)\n    }\n```\n```\nthis.$store.dispatch('incrementAsyncWithValue', 5)\n```\n## 5. module\n使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。\n为了解决以上问题，Vuex 允许我们将 store 分割到**模块（module）**。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：\n```\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\nmodule其实还是对于大型的SPA应用来说的，暂时对module的应用和理解并没有太多，之后会补上这一块儿的内容。\n想要了解更多module知识，请查阅[官方module文档](http://vuex.vuejs.org/zh-cn/modules.html)\n\n# Vue.js学习系列\n鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。\n\n[Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）](http://www.jianshu.com/p/8013d8d37bd0)\n[Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）](http://www.jianshu.com/p/d6f7e11f18af)\n[Vue.js学习系列三 —— axios和网络传输相关知识的学习实践](http://www.jianshu.com/p/8e5fb763c3d7)\n[Vue.js学习系列四 —— Webpack打包工具的使用](http://www.jianshu.com/p/aef34acd111f)\n[Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint](http://www.jianshu.com/p/efb6fbed6fac)\n[Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记](http://www.jianshu.com/p/073d25a3bba0)\n[Vue.js学习系列七 —— Vue服务器渲染Nuxt学习](https://www.jianshu.com/p/ba7466d7101a)\n[Vue.js学习系列八 —— Vue源码学习之State学习](https://www.jianshu.com/p/15028f91226e)\n\n# Vue.js学习系列项目地址\n本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。\n[https://github.com/violetjack/VueStudyDemos](https://github.com/violetjack/VueStudyDemos)\n\n# 关于作者\nVioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。\n欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。\n\n新浪微博： http://weibo.com/u/2640909603\n掘金：https://gold.xitu.io/user/571d953d39b0570068145cd1\nCSDN: http://blog.csdn.net/violetjack0808\n简书： http://www.jianshu.com/users/54ae4af3a98d/latest_articles\nGithub： https://github.com/violetjack","source":"_posts/Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）.md","raw":"---\ntitle: Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）\ndate: 2016-12-31\n---\n\n> 上次学习了vue-router的使用，让我能够在各个页面间切换，将页面搭建了起来。这次则要学习vue的状态管理模式——vuex。\n\n**注**：本文只是个人对vuex学习的一些理解，要深刻掌握还需要认真查阅[官方文档](http://vuex.vuejs.org/zh-cn/)。\n\n# 一、基本介绍\nVuex 是一个专为 Vue.js 的SPA单页组件化应用程序开发的**状态管理模式**插件。\n由于Vue SPA应用的模块化，每个组件都有它各自的数据(state)、界面(view)、和方法(actions)。这些数据、界面和方法分布在各个组件中，当项目内容变得越来越多时，每个组件中的状态会变得很难管理。这是vuex就派上用场啦~下面我们看一个简单的vuex例子。\n## 1. 单个组件中的状态\n假如只是在单个组件中要改变界面view很简单，只需要改变state数据源即可。如下代码：\n```\n<template>\n    <div>\n      view: {{ count }}\n      <button @click=\"increment\">increment</button>\n    </div>\n</template>\n\n<script>\nexport default {\n  // state\n  data () {\n    return {\n      count: 0\n    }\n  },\n  // actions\n  methods: {\n    increment () {\n      this.count++\n    }\n  }\n}\n</script>\n```\n所以，单个组件中的原理图是这样的：\n\n![单个组件中的原理图](http://upload-images.jianshu.io/upload_images/1987062-29836e1cb7325526.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 2. 多个组件中的状态\n然而，我们作为组件化的SPA应用，必定会牵扯到多个组件间的通信。\n比如有两个相同的组件A和B，它们共享一个数据count，并且都有一个方法可以操作这个count，我们使用vuex来写。\n**A组件和B组件的代码（代码相同）**\n```\n<template>\n  <div>\n    {{ $store.state.count }}\n    <button @click=\"increment\">increment</button>\n  </div>\n</template>\n\n<script>\n  export default {\n    methods: {\n      increment () {\n        this.$store.commit('increment')\n      }\n    }\n  }\n</script>\n```\n\n![结果1](http://upload-images.jianshu.io/upload_images/1987062-5971ec429e2ac23b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![结果2](http://upload-images.jianshu.io/upload_images/1987062-22872b0aa75b7f42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到，这里的两个increment按钮点击都会同时改变两个count的数据，**因为数据源count和方法increment都是全局的。**\n正如下面官方原理图所画的，我们把**全局数据源state、改变数据源的方法mutations、异步操作方法actions**都放提取出来放到store中，实现全局数据状态单独管理的功能。\n![vuex官方原理图](http://upload-images.jianshu.io/upload_images/1987062-9867083201b0c86e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 二、安装&配置\n## 1. 安装vuex\n使用npm安装并保存到package.json中：\n```\nnpm install vuex --save\n```\n**package.json**\n```\n  \"devDependencies\": {\n    ...\n    \"vuex\": \"^2.1.1\",\n    ...\n  },\n```\n## 2. 配置\n配置方式和路由的配置方式差不多\n```\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n//创建Store实例\nconst store = new Vuex.Store({\n  // 存储状态值\n  state: {\n    ...\n  },\n  // 状态值的改变方法,操作状态值\n  // 提交mutations是更改Vuex状态的唯一方法\n  mutations: {\n    ...\n  },\n  // 在store中定义getters（可以认为是store的计算属性）。Getters接收state作为其第一个函数\n  getters: {\n    ...\n  },\n  actions: { \n    ...\n  }\n})\n// 要改变状态值只能通过提交mutations来完成\n\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  template: '<App/>',\n  components: { App },\n  // 将store实例注入到根组件下的所有子组件中\n  store\n  // 子组件通过this.$store来方位store\n})\n\n```\n# 三、核心概念\n## 1. state\nstate就是全局的状态（数据源），我们可以用以下方式在Vue 组件中获得Vuex的state状态\n**template**\n```\n  <div>\n    {{ $store.state.count }}\n  </div>\n```\n**script**\n```\nconsole.log(this.$store.state.count)\n```\n## 2. getters\ngetters其实可以认为是 store 的计算属性，用法和计算属性差不多。\n定义getter：\n```\n  getters: {\n    done(state) {\n      return state.count + 5;\n    },\n  }\n```\n使用getter\n```\nconsole.log(this.$store.getters.done)\n```\n## 3. mutations\nmutations是操作state的唯一方法，即只有mutations方法能够改变state状态值。\n### 3.1 基本操作\n**mutations对state的操作**\n```\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n```\n**组件通过commit提交mutations的方式来请求改变state**\n```\nthis.$store.commit('increment')\n```\n这样的好处是我们可以跟踪到每一次state的变化，以便及时分析和解决问题。\n### 3.2 提交载荷（Payload）\nmutations方法中是可以传参的，具体用法如下：\n```\n  mutations: {\n    // 提交载荷 Payload\n    add(state, n) {\n      state.count += n\n    }\n  },\n```\n```\nthis.$store.commit('add', 10)\n```\n这里只是传了一个数字，在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读。\n### 3.3 注意\n**mutations方法必须是同步方法！**\n## 4. actions\n### 4.1 基本操作\n之前说mutations方法必须只能是同步方法，为了处理异步方法，actions出现了。关于action和mutations的区别有以下几点：\n* Action 提交的是 mutation，而不是直接变更状态。\n* Action 可以包含任意异步操作。\n* Action 还是得通过 mutation 方法来修改state\n同样是之前的increment方法,我们分别用同步和异步的action来验证上面所说的与mutations的不同之处：\n```\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    },\n    incrementAsync (context) {\n      // 延时1秒  \n      setTimeout(() => {\n        context.commit('increment')\n      }, 1000)\n    }\n  },\n```\n不同于mutations使用commit方法，actions使用dispatch方法。\n```\nthis.$store.dispatch('incrementAsync')\n```\n\n### 4.2 context\n**context是与 store 实例具有相同方法和属性的对象。**可以通过`context.state`和`context.getters`来获取 state 和 getters。\n### 4.3 以载荷形式分发\n```\n    incrementAsyncWithValue (context, value) {\n      setTimeout(() => {\n        context.commit('add', value)\n      }, 1000)\n    }\n```\n```\nthis.$store.dispatch('incrementAsyncWithValue', 5)\n```\n## 5. module\n使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。\n为了解决以上问题，Vuex 允许我们将 store 分割到**模块（module）**。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：\n```\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\nmodule其实还是对于大型的SPA应用来说的，暂时对module的应用和理解并没有太多，之后会补上这一块儿的内容。\n想要了解更多module知识，请查阅[官方module文档](http://vuex.vuejs.org/zh-cn/modules.html)\n\n# Vue.js学习系列\n鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。\n\n[Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）](http://www.jianshu.com/p/8013d8d37bd0)\n[Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）](http://www.jianshu.com/p/d6f7e11f18af)\n[Vue.js学习系列三 —— axios和网络传输相关知识的学习实践](http://www.jianshu.com/p/8e5fb763c3d7)\n[Vue.js学习系列四 —— Webpack打包工具的使用](http://www.jianshu.com/p/aef34acd111f)\n[Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint](http://www.jianshu.com/p/efb6fbed6fac)\n[Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记](http://www.jianshu.com/p/073d25a3bba0)\n[Vue.js学习系列七 —— Vue服务器渲染Nuxt学习](https://www.jianshu.com/p/ba7466d7101a)\n[Vue.js学习系列八 —— Vue源码学习之State学习](https://www.jianshu.com/p/15028f91226e)\n\n# Vue.js学习系列项目地址\n本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。\n[https://github.com/violetjack/VueStudyDemos](https://github.com/violetjack/VueStudyDemos)\n\n# 关于作者\nVioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。\n欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。\n\n新浪微博： http://weibo.com/u/2640909603\n掘金：https://gold.xitu.io/user/571d953d39b0570068145cd1\nCSDN: http://blog.csdn.net/violetjack0808\n简书： http://www.jianshu.com/users/54ae4af3a98d/latest_articles\nGithub： https://github.com/violetjack","slug":"Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）","published":1,"updated":"2018-02-07T02:31:12.170Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjddwxbm60006i8btzpb9pmx2","content":"<blockquote>\n<p>上次学习了vue-router的使用，让我能够在各个页面间切换，将页面搭建了起来。这次则要学习vue的状态管理模式——vuex。</p>\n</blockquote>\n<p><strong>注</strong>：本文只是个人对vuex学习的一些理解，要深刻掌握还需要认真查阅<a href=\"http://vuex.vuejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">官方文档</a>。</p>\n<h1 id=\"一、基本介绍\"><a href=\"#一、基本介绍\" class=\"headerlink\" title=\"一、基本介绍\"></a>一、基本介绍</h1><p>Vuex 是一个专为 Vue.js 的SPA单页组件化应用程序开发的<strong>状态管理模式</strong>插件。<br>由于Vue SPA应用的模块化，每个组件都有它各自的数据(state)、界面(view)、和方法(actions)。这些数据、界面和方法分布在各个组件中，当项目内容变得越来越多时，每个组件中的状态会变得很难管理。这是vuex就派上用场啦~下面我们看一个简单的vuex例子。</p>\n<h2 id=\"1-单个组件中的状态\"><a href=\"#1-单个组件中的状态\" class=\"headerlink\" title=\"1. 单个组件中的状态\"></a>1. 单个组件中的状态</h2><p>假如只是在单个组件中要改变界面view很简单，只需要改变state数据源即可。如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      view: &#123;&#123; count &#125;&#125;</span><br><span class=\"line\">      &lt;button @click=&quot;increment&quot;&gt;increment&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  // state</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      count: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // actions</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    increment () &#123;</span><br><span class=\"line\">      this.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>所以，单个组件中的原理图是这样的：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1987062-29836e1cb7325526.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"单个组件中的原理图\"></p>\n<h2 id=\"2-多个组件中的状态\"><a href=\"#2-多个组件中的状态\" class=\"headerlink\" title=\"2. 多个组件中的状态\"></a>2. 多个组件中的状态</h2><p>然而，我们作为组件化的SPA应用，必定会牵扯到多个组件间的通信。<br>比如有两个相同的组件A和B，它们共享一个数据count，并且都有一个方法可以操作这个count，我们使用vuex来写。<br><strong>A组件和B组件的代码（代码相同）</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &#123;&#123; $store.state.count &#125;&#125;</span><br><span class=\"line\">    &lt;button @click=&quot;increment&quot;&gt;increment&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  export default &#123;</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">      increment () &#123;</span><br><span class=\"line\">        this.$store.commit(&apos;increment&apos;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1987062-5971ec429e2ac23b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"结果1\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1987062-22872b0aa75b7f42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"结果2\"></p>\n<p>可以看到，这里的两个increment按钮点击都会同时改变两个count的数据，<strong>因为数据源count和方法increment都是全局的。</strong><br>正如下面官方原理图所画的，我们把<strong>全局数据源state、改变数据源的方法mutations、异步操作方法actions</strong>都放提取出来放到store中，实现全局数据状态单独管理的功能。<br><img src=\"http://upload-images.jianshu.io/upload_images/1987062-9867083201b0c86e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"vuex官方原理图\"></p>\n<h1 id=\"二、安装-amp-配置\"><a href=\"#二、安装-amp-配置\" class=\"headerlink\" title=\"二、安装&amp;配置\"></a>二、安装&amp;配置</h1><h2 id=\"1-安装vuex\"><a href=\"#1-安装vuex\" class=\"headerlink\" title=\"1. 安装vuex\"></a>1. 安装vuex</h2><p>使用npm安装并保存到package.json中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vuex --save</span><br></pre></td></tr></table></figure></p>\n<p><strong>package.json</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &quot;vuex&quot;: &quot;^2.1.1&quot;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h2><p>配置方式和路由的配置方式差不多<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\">import Vuex from &apos;vuex&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Vuex)</span><br><span class=\"line\">//创建Store实例</span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  // 存储状态值</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 状态值的改变方法,操作状态值</span><br><span class=\"line\">  // 提交mutations是更改Vuex状态的唯一方法</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 在store中定义getters（可以认为是store的计算属性）。Getters接收state作为其第一个函数</span><br><span class=\"line\">  getters: &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  actions: &#123; </span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 要改变状态值只能通过提交mutations来完成</span><br><span class=\"line\"></span><br><span class=\"line\">/* eslint-disable no-new */</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#app&apos;,</span><br><span class=\"line\">  template: &apos;&lt;App/&gt;&apos;,</span><br><span class=\"line\">  components: &#123; App &#125;,</span><br><span class=\"line\">  // 将store实例注入到根组件下的所有子组件中</span><br><span class=\"line\">  store</span><br><span class=\"line\">  // 子组件通过this.$store来方位store</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"三、核心概念\"><a href=\"#三、核心概念\" class=\"headerlink\" title=\"三、核心概念\"></a>三、核心概念</h1><h2 id=\"1-state\"><a href=\"#1-state\" class=\"headerlink\" title=\"1. state\"></a>1. state</h2><p>state就是全局的状态（数据源），我们可以用以下方式在Vue 组件中获得Vuex的state状态<br><strong>template</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &#123;&#123; $store.state.count &#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>script</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(this.$store.state.count)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-getters\"><a href=\"#2-getters\" class=\"headerlink\" title=\"2. getters\"></a>2. getters</h2><p>getters其实可以认为是 store 的计算属性，用法和计算属性差不多。<br>定义getter：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getters: &#123;</span><br><span class=\"line\">  done(state) &#123;</span><br><span class=\"line\">    return state.count + 5;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用getter<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(this.$store.getters.done)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-mutations\"><a href=\"#3-mutations\" class=\"headerlink\" title=\"3. mutations\"></a>3. mutations</h2><p>mutations是操作state的唯一方法，即只有mutations方法能够改变state状态值。</p>\n<h3 id=\"3-1-基本操作\"><a href=\"#3-1-基本操作\" class=\"headerlink\" title=\"3.1 基本操作\"></a>3.1 基本操作</h3><p><strong>mutations对state的操作</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    count: 1</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    increment (state) &#123;</span><br><span class=\"line\">      // 变更状态</span><br><span class=\"line\">      state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>组件通过commit提交mutations的方式来请求改变state</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$store.commit(&apos;increment&apos;)</span><br></pre></td></tr></table></figure></p>\n<p>这样的好处是我们可以跟踪到每一次state的变化，以便及时分析和解决问题。</p>\n<h3 id=\"3-2-提交载荷（Payload）\"><a href=\"#3-2-提交载荷（Payload）\" class=\"headerlink\" title=\"3.2 提交载荷（Payload）\"></a>3.2 提交载荷（Payload）</h3><p>mutations方法中是可以传参的，具体用法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">  // 提交载荷 Payload</span><br><span class=\"line\">  add(state, n) &#123;</span><br><span class=\"line\">    state.count += n</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$store.commit(&apos;add&apos;, 10)</span><br></pre></td></tr></table></figure>\n<p>这里只是传了一个数字，在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读。</p>\n<h3 id=\"3-3-注意\"><a href=\"#3-3-注意\" class=\"headerlink\" title=\"3.3 注意\"></a>3.3 注意</h3><p><strong>mutations方法必须是同步方法！</strong></p>\n<h2 id=\"4-actions\"><a href=\"#4-actions\" class=\"headerlink\" title=\"4. actions\"></a>4. actions</h2><h3 id=\"4-1-基本操作\"><a href=\"#4-1-基本操作\" class=\"headerlink\" title=\"4.1 基本操作\"></a>4.1 基本操作</h3><p>之前说mutations方法必须只能是同步方法，为了处理异步方法，actions出现了。关于action和mutations的区别有以下几点：</p>\n<ul>\n<li>Action 提交的是 mutation，而不是直接变更状态。</li>\n<li>Action 可以包含任意异步操作。</li>\n<li>Action 还是得通过 mutation 方法来修改state<br>同样是之前的increment方法,我们分别用同步和异步的action来验证上面所说的与mutations的不同之处：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  increment (context) &#123;</span><br><span class=\"line\">    context.commit(&apos;increment&apos;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  incrementAsync (context) &#123;</span><br><span class=\"line\">    // 延时1秒  </span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      context.commit(&apos;increment&apos;)</span><br><span class=\"line\">    &#125;, 1000)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>不同于mutations使用commit方法，actions使用dispatch方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$store.dispatch(&apos;incrementAsync&apos;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-2-context\"><a href=\"#4-2-context\" class=\"headerlink\" title=\"4.2 context\"></a>4.2 context</h3><p><strong>context是与 store 实例具有相同方法和属性的对象。</strong>可以通过<code>context.state</code>和<code>context.getters</code>来获取 state 和 getters。</p>\n<h3 id=\"4-3-以载荷形式分发\"><a href=\"#4-3-以载荷形式分发\" class=\"headerlink\" title=\"4.3 以载荷形式分发\"></a>4.3 以载荷形式分发</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">incrementAsyncWithValue (context, value) &#123;</span><br><span class=\"line\">  setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    context.commit(&apos;add&apos;, value)</span><br><span class=\"line\">  &#125;, 1000)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$store.dispatch(&apos;incrementAsyncWithValue&apos;, 5)</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-module\"><a href=\"#5-module\" class=\"headerlink\" title=\"5. module\"></a>5. module</h2><p>使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。<br>为了解决以上问题，Vuex 允许我们将 store 分割到<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const moduleA = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const moduleB = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a // -&gt; moduleA 的状态</span><br><span class=\"line\">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure></p>\n<p>module其实还是对于大型的SPA应用来说的，暂时对module的应用和理解并没有太多，之后会补上这一块儿的内容。<br>想要了解更多module知识，请查阅<a href=\"http://vuex.vuejs.org/zh-cn/modules.html\" target=\"_blank\" rel=\"noopener\">官方module文档</a></p>\n<h1 id=\"Vue-js学习系列\"><a href=\"#Vue-js学习系列\" class=\"headerlink\" title=\"Vue.js学习系列\"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>\n<p><a href=\"http://www.jianshu.com/p/8013d8d37bd0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/d6f7e11f18af\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/8e5fb763c3d7\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href=\"http://www.jianshu.com/p/aef34acd111f\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href=\"http://www.jianshu.com/p/efb6fbed6fac\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href=\"http://www.jianshu.com/p/073d25a3bba0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href=\"https://www.jianshu.com/p/ba7466d7101a\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href=\"https://www.jianshu.com/p/15028f91226e\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>\n<h1 id=\"Vue-js学习系列项目地址\"><a href=\"#Vue-js学习系列项目地址\" class=\"headerlink\" title=\"Vue.js学习系列项目地址\"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack/VueStudyDemos</a></p>\n<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>\n<p>新浪微博： <a href=\"http://weibo.com/u/2640909603\" target=\"_blank\" rel=\"noopener\">http://weibo.com/u/2640909603</a><br>掘金：<a href=\"https://gold.xitu.io/user/571d953d39b0570068145cd1\" target=\"_blank\" rel=\"noopener\">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href=\"http://blog.csdn.net/violetjack0808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/violetjack0808</a><br>简书： <a href=\"http://www.jianshu.com/users/54ae4af3a98d/latest_articles\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href=\"https://github.com/violetjack\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>上次学习了vue-router的使用，让我能够在各个页面间切换，将页面搭建了起来。这次则要学习vue的状态管理模式——vuex。</p>\n</blockquote>\n<p><strong>注</strong>：本文只是个人对vuex学习的一些理解，要深刻掌握还需要认真查阅<a href=\"http://vuex.vuejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">官方文档</a>。</p>\n<h1 id=\"一、基本介绍\"><a href=\"#一、基本介绍\" class=\"headerlink\" title=\"一、基本介绍\"></a>一、基本介绍</h1><p>Vuex 是一个专为 Vue.js 的SPA单页组件化应用程序开发的<strong>状态管理模式</strong>插件。<br>由于Vue SPA应用的模块化，每个组件都有它各自的数据(state)、界面(view)、和方法(actions)。这些数据、界面和方法分布在各个组件中，当项目内容变得越来越多时，每个组件中的状态会变得很难管理。这是vuex就派上用场啦~下面我们看一个简单的vuex例子。</p>\n<h2 id=\"1-单个组件中的状态\"><a href=\"#1-单个组件中的状态\" class=\"headerlink\" title=\"1. 单个组件中的状态\"></a>1. 单个组件中的状态</h2><p>假如只是在单个组件中要改变界面view很简单，只需要改变state数据源即可。如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      view: &#123;&#123; count &#125;&#125;</span><br><span class=\"line\">      &lt;button @click=&quot;increment&quot;&gt;increment&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  // state</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      count: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // actions</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    increment () &#123;</span><br><span class=\"line\">      this.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>所以，单个组件中的原理图是这样的：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1987062-29836e1cb7325526.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"单个组件中的原理图\"></p>\n<h2 id=\"2-多个组件中的状态\"><a href=\"#2-多个组件中的状态\" class=\"headerlink\" title=\"2. 多个组件中的状态\"></a>2. 多个组件中的状态</h2><p>然而，我们作为组件化的SPA应用，必定会牵扯到多个组件间的通信。<br>比如有两个相同的组件A和B，它们共享一个数据count，并且都有一个方法可以操作这个count，我们使用vuex来写。<br><strong>A组件和B组件的代码（代码相同）</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &#123;&#123; $store.state.count &#125;&#125;</span><br><span class=\"line\">    &lt;button @click=&quot;increment&quot;&gt;increment&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  export default &#123;</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">      increment () &#123;</span><br><span class=\"line\">        this.$store.commit(&apos;increment&apos;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1987062-5971ec429e2ac23b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"结果1\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1987062-22872b0aa75b7f42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"结果2\"></p>\n<p>可以看到，这里的两个increment按钮点击都会同时改变两个count的数据，<strong>因为数据源count和方法increment都是全局的。</strong><br>正如下面官方原理图所画的，我们把<strong>全局数据源state、改变数据源的方法mutations、异步操作方法actions</strong>都放提取出来放到store中，实现全局数据状态单独管理的功能。<br><img src=\"http://upload-images.jianshu.io/upload_images/1987062-9867083201b0c86e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"vuex官方原理图\"></p>\n<h1 id=\"二、安装-amp-配置\"><a href=\"#二、安装-amp-配置\" class=\"headerlink\" title=\"二、安装&amp;配置\"></a>二、安装&amp;配置</h1><h2 id=\"1-安装vuex\"><a href=\"#1-安装vuex\" class=\"headerlink\" title=\"1. 安装vuex\"></a>1. 安装vuex</h2><p>使用npm安装并保存到package.json中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vuex --save</span><br></pre></td></tr></table></figure></p>\n<p><strong>package.json</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &quot;vuex&quot;: &quot;^2.1.1&quot;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h2><p>配置方式和路由的配置方式差不多<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\">import Vuex from &apos;vuex&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Vuex)</span><br><span class=\"line\">//创建Store实例</span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  // 存储状态值</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 状态值的改变方法,操作状态值</span><br><span class=\"line\">  // 提交mutations是更改Vuex状态的唯一方法</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 在store中定义getters（可以认为是store的计算属性）。Getters接收state作为其第一个函数</span><br><span class=\"line\">  getters: &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  actions: &#123; </span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 要改变状态值只能通过提交mutations来完成</span><br><span class=\"line\"></span><br><span class=\"line\">/* eslint-disable no-new */</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#app&apos;,</span><br><span class=\"line\">  template: &apos;&lt;App/&gt;&apos;,</span><br><span class=\"line\">  components: &#123; App &#125;,</span><br><span class=\"line\">  // 将store实例注入到根组件下的所有子组件中</span><br><span class=\"line\">  store</span><br><span class=\"line\">  // 子组件通过this.$store来方位store</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"三、核心概念\"><a href=\"#三、核心概念\" class=\"headerlink\" title=\"三、核心概念\"></a>三、核心概念</h1><h2 id=\"1-state\"><a href=\"#1-state\" class=\"headerlink\" title=\"1. state\"></a>1. state</h2><p>state就是全局的状态（数据源），我们可以用以下方式在Vue 组件中获得Vuex的state状态<br><strong>template</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &#123;&#123; $store.state.count &#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>script</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(this.$store.state.count)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-getters\"><a href=\"#2-getters\" class=\"headerlink\" title=\"2. getters\"></a>2. getters</h2><p>getters其实可以认为是 store 的计算属性，用法和计算属性差不多。<br>定义getter：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getters: &#123;</span><br><span class=\"line\">  done(state) &#123;</span><br><span class=\"line\">    return state.count + 5;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用getter<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(this.$store.getters.done)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-mutations\"><a href=\"#3-mutations\" class=\"headerlink\" title=\"3. mutations\"></a>3. mutations</h2><p>mutations是操作state的唯一方法，即只有mutations方法能够改变state状态值。</p>\n<h3 id=\"3-1-基本操作\"><a href=\"#3-1-基本操作\" class=\"headerlink\" title=\"3.1 基本操作\"></a>3.1 基本操作</h3><p><strong>mutations对state的操作</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    count: 1</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    increment (state) &#123;</span><br><span class=\"line\">      // 变更状态</span><br><span class=\"line\">      state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>组件通过commit提交mutations的方式来请求改变state</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$store.commit(&apos;increment&apos;)</span><br></pre></td></tr></table></figure></p>\n<p>这样的好处是我们可以跟踪到每一次state的变化，以便及时分析和解决问题。</p>\n<h3 id=\"3-2-提交载荷（Payload）\"><a href=\"#3-2-提交载荷（Payload）\" class=\"headerlink\" title=\"3.2 提交载荷（Payload）\"></a>3.2 提交载荷（Payload）</h3><p>mutations方法中是可以传参的，具体用法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">  // 提交载荷 Payload</span><br><span class=\"line\">  add(state, n) &#123;</span><br><span class=\"line\">    state.count += n</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$store.commit(&apos;add&apos;, 10)</span><br></pre></td></tr></table></figure>\n<p>这里只是传了一个数字，在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读。</p>\n<h3 id=\"3-3-注意\"><a href=\"#3-3-注意\" class=\"headerlink\" title=\"3.3 注意\"></a>3.3 注意</h3><p><strong>mutations方法必须是同步方法！</strong></p>\n<h2 id=\"4-actions\"><a href=\"#4-actions\" class=\"headerlink\" title=\"4. actions\"></a>4. actions</h2><h3 id=\"4-1-基本操作\"><a href=\"#4-1-基本操作\" class=\"headerlink\" title=\"4.1 基本操作\"></a>4.1 基本操作</h3><p>之前说mutations方法必须只能是同步方法，为了处理异步方法，actions出现了。关于action和mutations的区别有以下几点：</p>\n<ul>\n<li>Action 提交的是 mutation，而不是直接变更状态。</li>\n<li>Action 可以包含任意异步操作。</li>\n<li>Action 还是得通过 mutation 方法来修改state<br>同样是之前的increment方法,我们分别用同步和异步的action来验证上面所说的与mutations的不同之处：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  increment (context) &#123;</span><br><span class=\"line\">    context.commit(&apos;increment&apos;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  incrementAsync (context) &#123;</span><br><span class=\"line\">    // 延时1秒  </span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      context.commit(&apos;increment&apos;)</span><br><span class=\"line\">    &#125;, 1000)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>不同于mutations使用commit方法，actions使用dispatch方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$store.dispatch(&apos;incrementAsync&apos;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-2-context\"><a href=\"#4-2-context\" class=\"headerlink\" title=\"4.2 context\"></a>4.2 context</h3><p><strong>context是与 store 实例具有相同方法和属性的对象。</strong>可以通过<code>context.state</code>和<code>context.getters</code>来获取 state 和 getters。</p>\n<h3 id=\"4-3-以载荷形式分发\"><a href=\"#4-3-以载荷形式分发\" class=\"headerlink\" title=\"4.3 以载荷形式分发\"></a>4.3 以载荷形式分发</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">incrementAsyncWithValue (context, value) &#123;</span><br><span class=\"line\">  setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    context.commit(&apos;add&apos;, value)</span><br><span class=\"line\">  &#125;, 1000)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$store.dispatch(&apos;incrementAsyncWithValue&apos;, 5)</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-module\"><a href=\"#5-module\" class=\"headerlink\" title=\"5. module\"></a>5. module</h2><p>使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。<br>为了解决以上问题，Vuex 允许我们将 store 分割到<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const moduleA = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const moduleB = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a // -&gt; moduleA 的状态</span><br><span class=\"line\">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure></p>\n<p>module其实还是对于大型的SPA应用来说的，暂时对module的应用和理解并没有太多，之后会补上这一块儿的内容。<br>想要了解更多module知识，请查阅<a href=\"http://vuex.vuejs.org/zh-cn/modules.html\" target=\"_blank\" rel=\"noopener\">官方module文档</a></p>\n<h1 id=\"Vue-js学习系列\"><a href=\"#Vue-js学习系列\" class=\"headerlink\" title=\"Vue.js学习系列\"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>\n<p><a href=\"http://www.jianshu.com/p/8013d8d37bd0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/d6f7e11f18af\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/8e5fb763c3d7\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href=\"http://www.jianshu.com/p/aef34acd111f\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href=\"http://www.jianshu.com/p/efb6fbed6fac\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href=\"http://www.jianshu.com/p/073d25a3bba0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href=\"https://www.jianshu.com/p/ba7466d7101a\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href=\"https://www.jianshu.com/p/15028f91226e\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>\n<h1 id=\"Vue-js学习系列项目地址\"><a href=\"#Vue-js学习系列项目地址\" class=\"headerlink\" title=\"Vue.js学习系列项目地址\"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack/VueStudyDemos</a></p>\n<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>\n<p>新浪微博： <a href=\"http://weibo.com/u/2640909603\" target=\"_blank\" rel=\"noopener\">http://weibo.com/u/2640909603</a><br>掘金：<a href=\"https://gold.xitu.io/user/571d953d39b0570068145cd1\" target=\"_blank\" rel=\"noopener\">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href=\"http://blog.csdn.net/violetjack0808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/violetjack0808</a><br>简书： <a href=\"http://www.jianshu.com/users/54ae4af3a98d/latest_articles\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href=\"https://github.com/violetjack\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack</a></p>\n"},{"title":"Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint","date":"2017-05-18T16:00:00.000Z","_content":"\n> 最近在用vue-cli写项目的时候，经常和ESLint打交道，也算是不打不相识啦。下面总结一下在学习Vue的时候遇到的一些问题。\n\n# ESLint简介\n关于ESLint的介绍网上很多，这里就简单说些有用的。\nESLint的作用是检查代码错误和统一代码风格的。由于每个人写代码的习惯都会有所不同，所以统一代码风格在团队协作中尤为重要。\n\n# vue-cli的eslint相关\nvue-cli在init初始化时会询问是否需要添加ESLint，确认之后在创建的项目中就会出现`.eslintignore`和`.eslintrc.js`两个文件。\n`.eslintignore`类似Git的`.gitignore`用来忽略一些文件不使用ESLint检查。\n`.eslintrc.js`是ESLint配置文件，用来设置插件、自定义规则、解析器等配置。\n\n**.eslintrc.js**\n```\n// http://eslint.org/docs/user-guide/configuring\n\nmodule.exports = {\n  root: true,\n  parser: 'babel-eslint',\n  parserOptions: {\n    sourceType: 'module'\n  },\n  env: {\n    browser: true,\n  },\n  // https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style\n  extends: 'standard',\n  // required to lint *.vue files\n  plugins: [\n    'html'\n  ],\n  // add your custom rules here\n  'rules': {\n    // allow paren-less arrow functions\n    'arrow-parens': 0,\n    // allow async-await\n    'generator-star-spacing': 0,\n    // allow debugger during development\n    'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0\n  }\n}\n```\n**解析器(parser)：**使用了babel-eslint，这个可以在package.json中找到，说明我们已经安装过该解析器了。\n**环境配置(env)：**在浏览器中使用eslint。\n**继承(extends)：**该配置文件继承了[standard](https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style)规则，具体规则自己看文档，看不懂有[中文版](https://github.com/feross/standard/blob/master/docs/RULES-zhcn.md)的。\n**规则(rules)：**对于三个自定义规则，我特地查了官方文档。\n> \n* arrow-parems 允许箭头函数参数使用括号,具体操作请看[文档](http://eslint.org/docs/rules/arrow-parens)\n* generator-star-spacing 允许方法之间加星号，如`function * generator() {}`。[文档](http://eslint.org/docs/rules/generator-star-spacing)在此。特地查了下，发现这是ES6提供的[生成器函数](https://imququ.com/post/generator-function-in-es6.html)，回头学习下。\n* no-debugger' 允许在开发环境下使用debugger。这个比较简单，不过还是贴下[文档](http://eslint.org/docs/rules/no-debugger)便于查看。\n\n**注意：**在`rules`中每个配置项后面第一个值是eslint规则的**错误等级**。\n* \"off\" 或 0 - 关闭这条规则\n* \"warn\" 或 1 - 违反规则会警告（不会影响项目运行）\n* \"error\" 或 2 - 违反规则会报错（屏幕上一堆错误代码~）\n\n# 遇到过的问题\n由于一开始我不了解ESLint就写项目，不知道要看Standard的[文档](https://github.com/feross/standard/blob/master/docs/RULES-zhcn.md)，所以遇到了很多ESLint的错误和警告，分享下希望能对朋友们有帮助。\n\n### 1. Do not use 'new' for side effects\n该错误是由于我删除了`/* eslint-disable no-new*/`这段注释引发的，`/* eslint-disable */`这段注释的作用就是不让eslint检查注释下面的代码。\n```\nnew Vue({\n  el: '#app',\n  router,\n  template: '<App/>',\n  components: { App }\n})\n\n```\n**错误原因：**不可以直接new一个新对象，需要将新对象赋值给一个变量。\n```\nvar vm = new Vue()\n```\n### 2. Strings must use singlequote\n**错误原因：**字符串必须用单引号\n```\nreturn {\n      msg: \"Welcome to Your Vue.js App\", //双引号，报错！\n    }\n```\n### 3. Expected space(s) after \"return\"\n**错误原因：**括号两侧必须要有空格隔开\n```\nreturn{// 没有空格报错\n  msg: 'Welcome to Your Vue.js App', \n}\n\nstartClock (){} //){中间没有空格，报错！\n```\n### 4. Expected indentation of 8 spaces but found 6 \n**错误原因：**使用两个空格进行缩进。\n```\n      if (this.IntervalID === '') {\n      this.IntervalID = setInterval(this.countDown, 1000)\n      }\n```\n其实ESLint的报错并不难懂，只要理解错误原因还是很好解决的。如果提前看看文档，更不会出现太多报错问题了。这个故事告诉我们**看文档是很重要滴~%>_<%**\n# Tips\n**发现ESLint的报错都会在报错语句前面显示一个URL**，点击进去可以看到详细的错误信息哦。这是我刚在写博客的时候发现的。\n```\n  http://eslint.org/docs/rules/no-new  Do not use 'new' for side effects  \n  E:\\Github\\EfficiencyTools\\EfficiencyTool-VueMobile\\src\\main.js:15:1\n  new Vue({\n```\n这里的 http://eslint.org/docs/rules/no-new 就是ESLint规则报错的原因，还是很人性化的。\n\n# 编辑器\n推荐使用VSCode来编辑代码。按照着[VSCode拓展插件推荐——提高Node和Vue开发效率](https://github.com/varHarrie/Dawn-Blossoms/issues/10)来安装和配置插件后，写vue项目方便了很多。\n\n# 总结\n其实vue-cli的ESLint不需要我们配置太多，基本的都配置好了，如果你愿意完全可以照着vue-cli提供的规则去写代码。当我们需要修改一些规则的时候添加到rules中替换原有规则就可以了。一开始用ESLint写代码很烦，经常由于一些格式问题调试报错，让回去改格式。不过慢慢的就会发现使用ESLint之后代码的确可读性、美观性上都好了很多。\n推荐使用ESLint来规范代码编辑~\n\n# Vue.js学习系列\n鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。\n\n[Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）](http://www.jianshu.com/p/8013d8d37bd0)\n[Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）](http://www.jianshu.com/p/d6f7e11f18af)\n[Vue.js学习系列三 —— axios和网络传输相关知识的学习实践](http://www.jianshu.com/p/8e5fb763c3d7)\n[Vue.js学习系列四 —— Webpack打包工具的使用](http://www.jianshu.com/p/aef34acd111f)\n[Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint](http://www.jianshu.com/p/efb6fbed6fac)\n[Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记](http://www.jianshu.com/p/073d25a3bba0)\n[Vue.js学习系列七 —— Vue服务器渲染Nuxt学习](https://www.jianshu.com/p/ba7466d7101a)\n[Vue.js学习系列八 —— Vue源码学习之State学习](https://www.jianshu.com/p/15028f91226e)\n\n# Vue.js学习系列项目地址\n本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。\n[https://github.com/violetjack/VueStudyDemos](https://github.com/violetjack/VueStudyDemos)\n\n# 关于作者\nVioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。\n欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。\n\n新浪微博： http://weibo.com/u/2640909603\n掘金：https://gold.xitu.io/user/571d953d39b0570068145cd1\nCSDN: http://blog.csdn.net/violetjack0808\n简书： http://www.jianshu.com/users/54ae4af3a98d/latest_articles\nGithub： https://github.com/violetjack","source":"_posts/Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint.md","raw":"---\ntitle: Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint\ndate: 2017-05-19\n---\n\n> 最近在用vue-cli写项目的时候，经常和ESLint打交道，也算是不打不相识啦。下面总结一下在学习Vue的时候遇到的一些问题。\n\n# ESLint简介\n关于ESLint的介绍网上很多，这里就简单说些有用的。\nESLint的作用是检查代码错误和统一代码风格的。由于每个人写代码的习惯都会有所不同，所以统一代码风格在团队协作中尤为重要。\n\n# vue-cli的eslint相关\nvue-cli在init初始化时会询问是否需要添加ESLint，确认之后在创建的项目中就会出现`.eslintignore`和`.eslintrc.js`两个文件。\n`.eslintignore`类似Git的`.gitignore`用来忽略一些文件不使用ESLint检查。\n`.eslintrc.js`是ESLint配置文件，用来设置插件、自定义规则、解析器等配置。\n\n**.eslintrc.js**\n```\n// http://eslint.org/docs/user-guide/configuring\n\nmodule.exports = {\n  root: true,\n  parser: 'babel-eslint',\n  parserOptions: {\n    sourceType: 'module'\n  },\n  env: {\n    browser: true,\n  },\n  // https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style\n  extends: 'standard',\n  // required to lint *.vue files\n  plugins: [\n    'html'\n  ],\n  // add your custom rules here\n  'rules': {\n    // allow paren-less arrow functions\n    'arrow-parens': 0,\n    // allow async-await\n    'generator-star-spacing': 0,\n    // allow debugger during development\n    'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0\n  }\n}\n```\n**解析器(parser)：**使用了babel-eslint，这个可以在package.json中找到，说明我们已经安装过该解析器了。\n**环境配置(env)：**在浏览器中使用eslint。\n**继承(extends)：**该配置文件继承了[standard](https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style)规则，具体规则自己看文档，看不懂有[中文版](https://github.com/feross/standard/blob/master/docs/RULES-zhcn.md)的。\n**规则(rules)：**对于三个自定义规则，我特地查了官方文档。\n> \n* arrow-parems 允许箭头函数参数使用括号,具体操作请看[文档](http://eslint.org/docs/rules/arrow-parens)\n* generator-star-spacing 允许方法之间加星号，如`function * generator() {}`。[文档](http://eslint.org/docs/rules/generator-star-spacing)在此。特地查了下，发现这是ES6提供的[生成器函数](https://imququ.com/post/generator-function-in-es6.html)，回头学习下。\n* no-debugger' 允许在开发环境下使用debugger。这个比较简单，不过还是贴下[文档](http://eslint.org/docs/rules/no-debugger)便于查看。\n\n**注意：**在`rules`中每个配置项后面第一个值是eslint规则的**错误等级**。\n* \"off\" 或 0 - 关闭这条规则\n* \"warn\" 或 1 - 违反规则会警告（不会影响项目运行）\n* \"error\" 或 2 - 违反规则会报错（屏幕上一堆错误代码~）\n\n# 遇到过的问题\n由于一开始我不了解ESLint就写项目，不知道要看Standard的[文档](https://github.com/feross/standard/blob/master/docs/RULES-zhcn.md)，所以遇到了很多ESLint的错误和警告，分享下希望能对朋友们有帮助。\n\n### 1. Do not use 'new' for side effects\n该错误是由于我删除了`/* eslint-disable no-new*/`这段注释引发的，`/* eslint-disable */`这段注释的作用就是不让eslint检查注释下面的代码。\n```\nnew Vue({\n  el: '#app',\n  router,\n  template: '<App/>',\n  components: { App }\n})\n\n```\n**错误原因：**不可以直接new一个新对象，需要将新对象赋值给一个变量。\n```\nvar vm = new Vue()\n```\n### 2. Strings must use singlequote\n**错误原因：**字符串必须用单引号\n```\nreturn {\n      msg: \"Welcome to Your Vue.js App\", //双引号，报错！\n    }\n```\n### 3. Expected space(s) after \"return\"\n**错误原因：**括号两侧必须要有空格隔开\n```\nreturn{// 没有空格报错\n  msg: 'Welcome to Your Vue.js App', \n}\n\nstartClock (){} //){中间没有空格，报错！\n```\n### 4. Expected indentation of 8 spaces but found 6 \n**错误原因：**使用两个空格进行缩进。\n```\n      if (this.IntervalID === '') {\n      this.IntervalID = setInterval(this.countDown, 1000)\n      }\n```\n其实ESLint的报错并不难懂，只要理解错误原因还是很好解决的。如果提前看看文档，更不会出现太多报错问题了。这个故事告诉我们**看文档是很重要滴~%>_<%**\n# Tips\n**发现ESLint的报错都会在报错语句前面显示一个URL**，点击进去可以看到详细的错误信息哦。这是我刚在写博客的时候发现的。\n```\n  http://eslint.org/docs/rules/no-new  Do not use 'new' for side effects  \n  E:\\Github\\EfficiencyTools\\EfficiencyTool-VueMobile\\src\\main.js:15:1\n  new Vue({\n```\n这里的 http://eslint.org/docs/rules/no-new 就是ESLint规则报错的原因，还是很人性化的。\n\n# 编辑器\n推荐使用VSCode来编辑代码。按照着[VSCode拓展插件推荐——提高Node和Vue开发效率](https://github.com/varHarrie/Dawn-Blossoms/issues/10)来安装和配置插件后，写vue项目方便了很多。\n\n# 总结\n其实vue-cli的ESLint不需要我们配置太多，基本的都配置好了，如果你愿意完全可以照着vue-cli提供的规则去写代码。当我们需要修改一些规则的时候添加到rules中替换原有规则就可以了。一开始用ESLint写代码很烦，经常由于一些格式问题调试报错，让回去改格式。不过慢慢的就会发现使用ESLint之后代码的确可读性、美观性上都好了很多。\n推荐使用ESLint来规范代码编辑~\n\n# Vue.js学习系列\n鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。\n\n[Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）](http://www.jianshu.com/p/8013d8d37bd0)\n[Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）](http://www.jianshu.com/p/d6f7e11f18af)\n[Vue.js学习系列三 —— axios和网络传输相关知识的学习实践](http://www.jianshu.com/p/8e5fb763c3d7)\n[Vue.js学习系列四 —— Webpack打包工具的使用](http://www.jianshu.com/p/aef34acd111f)\n[Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint](http://www.jianshu.com/p/efb6fbed6fac)\n[Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记](http://www.jianshu.com/p/073d25a3bba0)\n[Vue.js学习系列七 —— Vue服务器渲染Nuxt学习](https://www.jianshu.com/p/ba7466d7101a)\n[Vue.js学习系列八 —— Vue源码学习之State学习](https://www.jianshu.com/p/15028f91226e)\n\n# Vue.js学习系列项目地址\n本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。\n[https://github.com/violetjack/VueStudyDemos](https://github.com/violetjack/VueStudyDemos)\n\n# 关于作者\nVioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。\n欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。\n\n新浪微博： http://weibo.com/u/2640909603\n掘金：https://gold.xitu.io/user/571d953d39b0570068145cd1\nCSDN: http://blog.csdn.net/violetjack0808\n简书： http://www.jianshu.com/users/54ae4af3a98d/latest_articles\nGithub： https://github.com/violetjack","slug":"Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint","published":1,"updated":"2018-02-07T02:29:42.893Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjddwxbm70007i8btygx0dza3","content":"<blockquote>\n<p>最近在用vue-cli写项目的时候，经常和ESLint打交道，也算是不打不相识啦。下面总结一下在学习Vue的时候遇到的一些问题。</p>\n</blockquote>\n<h1 id=\"ESLint简介\"><a href=\"#ESLint简介\" class=\"headerlink\" title=\"ESLint简介\"></a>ESLint简介</h1><p>关于ESLint的介绍网上很多，这里就简单说些有用的。<br>ESLint的作用是检查代码错误和统一代码风格的。由于每个人写代码的习惯都会有所不同，所以统一代码风格在团队协作中尤为重要。</p>\n<h1 id=\"vue-cli的eslint相关\"><a href=\"#vue-cli的eslint相关\" class=\"headerlink\" title=\"vue-cli的eslint相关\"></a>vue-cli的eslint相关</h1><p>vue-cli在init初始化时会询问是否需要添加ESLint，确认之后在创建的项目中就会出现<code>.eslintignore</code>和<code>.eslintrc.js</code>两个文件。<br><code>.eslintignore</code>类似Git的<code>.gitignore</code>用来忽略一些文件不使用ESLint检查。<br><code>.eslintrc.js</code>是ESLint配置文件，用来设置插件、自定义规则、解析器等配置。</p>\n<p><strong>.eslintrc.js</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// http://eslint.org/docs/user-guide/configuring</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  root: true,</span><br><span class=\"line\">  parser: &apos;babel-eslint&apos;,</span><br><span class=\"line\">  parserOptions: &#123;</span><br><span class=\"line\">    sourceType: &apos;module&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  env: &#123;</span><br><span class=\"line\">    browser: true,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style</span><br><span class=\"line\">  extends: &apos;standard&apos;,</span><br><span class=\"line\">  // required to lint *.vue files</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    &apos;html&apos;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  // add your custom rules here</span><br><span class=\"line\">  &apos;rules&apos;: &#123;</span><br><span class=\"line\">    // allow paren-less arrow functions</span><br><span class=\"line\">    &apos;arrow-parens&apos;: 0,</span><br><span class=\"line\">    // allow async-await</span><br><span class=\"line\">    &apos;generator-star-spacing&apos;: 0,</span><br><span class=\"line\">    // allow debugger during development</span><br><span class=\"line\">    &apos;no-debugger&apos;: process.env.NODE_ENV === &apos;production&apos; ? 2 : 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>解析器(parser)：</strong>使用了babel-eslint，这个可以在package.json中找到，说明我们已经安装过该解析器了。<br><strong>环境配置(env)：</strong>在浏览器中使用eslint。<br><strong>继承(extends)：</strong>该配置文件继承了<a href=\"https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style\" target=\"_blank\" rel=\"noopener\">standard</a>规则，具体规则自己看文档，看不懂有<a href=\"https://github.com/feross/standard/blob/master/docs/RULES-zhcn.md\" target=\"_blank\" rel=\"noopener\">中文版</a>的。<br><strong>规则(rules)：</strong>对于三个自定义规则，我特地查了官方文档。</p>\n<blockquote>\n<ul>\n<li>arrow-parems 允许箭头函数参数使用括号,具体操作请看<a href=\"http://eslint.org/docs/rules/arrow-parens\" target=\"_blank\" rel=\"noopener\">文档</a></li>\n<li>generator-star-spacing 允许方法之间加星号，如<code>function * generator() {}</code>。<a href=\"http://eslint.org/docs/rules/generator-star-spacing\" target=\"_blank\" rel=\"noopener\">文档</a>在此。特地查了下，发现这是ES6提供的<a href=\"https://imququ.com/post/generator-function-in-es6.html\" target=\"_blank\" rel=\"noopener\">生成器函数</a>，回头学习下。</li>\n<li>no-debugger’ 允许在开发环境下使用debugger。这个比较简单，不过还是贴下<a href=\"http://eslint.org/docs/rules/no-debugger\" target=\"_blank\" rel=\"noopener\">文档</a>便于查看。</li>\n</ul>\n</blockquote>\n<p><strong>注意：</strong>在<code>rules</code>中每个配置项后面第一个值是eslint规则的<strong>错误等级</strong>。</p>\n<ul>\n<li>“off” 或 0 - 关闭这条规则</li>\n<li>“warn” 或 1 - 违反规则会警告（不会影响项目运行）</li>\n<li>“error” 或 2 - 违反规则会报错（屏幕上一堆错误代码~）</li>\n</ul>\n<h1 id=\"遇到过的问题\"><a href=\"#遇到过的问题\" class=\"headerlink\" title=\"遇到过的问题\"></a>遇到过的问题</h1><p>由于一开始我不了解ESLint就写项目，不知道要看Standard的<a href=\"https://github.com/feross/standard/blob/master/docs/RULES-zhcn.md\" target=\"_blank\" rel=\"noopener\">文档</a>，所以遇到了很多ESLint的错误和警告，分享下希望能对朋友们有帮助。</p>\n<h3 id=\"1-Do-not-use-‘new’-for-side-effects\"><a href=\"#1-Do-not-use-‘new’-for-side-effects\" class=\"headerlink\" title=\"1. Do not use ‘new’ for side effects\"></a>1. Do not use ‘new’ for side effects</h3><p>该错误是由于我删除了<code>/* eslint-disable no-new*/</code>这段注释引发的，<code>/* eslint-disable */</code>这段注释的作用就是不让eslint检查注释下面的代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#app&apos;,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  template: &apos;&lt;App/&gt;&apos;,</span><br><span class=\"line\">  components: &#123; App &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>错误原因：</strong>不可以直接new一个新对象，需要将新对象赋值给一个变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm = new Vue()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-Strings-must-use-singlequote\"><a href=\"#2-Strings-must-use-singlequote\" class=\"headerlink\" title=\"2. Strings must use singlequote\"></a>2. Strings must use singlequote</h3><p><strong>错误原因：</strong>字符串必须用单引号<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return &#123;</span><br><span class=\"line\">      msg: &quot;Welcome to Your Vue.js App&quot;, //双引号，报错！</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-Expected-space-s-after-“return”\"><a href=\"#3-Expected-space-s-after-“return”\" class=\"headerlink\" title=\"3. Expected space(s) after “return”\"></a>3. Expected space(s) after “return”</h3><p><strong>错误原因：</strong>括号两侧必须要有空格隔开<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return&#123;// 没有空格报错</span><br><span class=\"line\">  msg: &apos;Welcome to Your Vue.js App&apos;, </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">startClock ()&#123;&#125; //)&#123;中间没有空格，报错！</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-Expected-indentation-of-8-spaces-but-found-6\"><a href=\"#4-Expected-indentation-of-8-spaces-but-found-6\" class=\"headerlink\" title=\"4. Expected indentation of 8 spaces but found 6\"></a>4. Expected indentation of 8 spaces but found 6</h3><p><strong>错误原因：</strong>使用两个空格进行缩进。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (this.IntervalID === &apos;&apos;) &#123;</span><br><span class=\"line\">this.IntervalID = setInterval(this.countDown, 1000)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实ESLint的报错并不难懂，只要理解错误原因还是很好解决的。如果提前看看文档，更不会出现太多报错问题了。这个故事告诉我们<strong>看文档是很重要滴~%&gt;_&lt;%</strong></p>\n<h1 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h1><p><strong>发现ESLint的报错都会在报错语句前面显示一个URL</strong>，点击进去可以看到详细的错误信息哦。这是我刚在写博客的时候发现的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://eslint.org/docs/rules/no-new  Do not use &apos;new&apos; for side effects  </span><br><span class=\"line\">E:\\Github\\EfficiencyTools\\EfficiencyTool-VueMobile\\src\\main.js:15:1</span><br><span class=\"line\">new Vue(&#123;</span><br></pre></td></tr></table></figure></p>\n<p>这里的 <a href=\"http://eslint.org/docs/rules/no-new\" target=\"_blank\" rel=\"noopener\">http://eslint.org/docs/rules/no-new</a> 就是ESLint规则报错的原因，还是很人性化的。</p>\n<h1 id=\"编辑器\"><a href=\"#编辑器\" class=\"headerlink\" title=\"编辑器\"></a>编辑器</h1><p>推荐使用VSCode来编辑代码。按照着<a href=\"https://github.com/varHarrie/Dawn-Blossoms/issues/10\" target=\"_blank\" rel=\"noopener\">VSCode拓展插件推荐——提高Node和Vue开发效率</a>来安装和配置插件后，写vue项目方便了很多。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>其实vue-cli的ESLint不需要我们配置太多，基本的都配置好了，如果你愿意完全可以照着vue-cli提供的规则去写代码。当我们需要修改一些规则的时候添加到rules中替换原有规则就可以了。一开始用ESLint写代码很烦，经常由于一些格式问题调试报错，让回去改格式。不过慢慢的就会发现使用ESLint之后代码的确可读性、美观性上都好了很多。<br>推荐使用ESLint来规范代码编辑~</p>\n<h1 id=\"Vue-js学习系列\"><a href=\"#Vue-js学习系列\" class=\"headerlink\" title=\"Vue.js学习系列\"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>\n<p><a href=\"http://www.jianshu.com/p/8013d8d37bd0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/d6f7e11f18af\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/8e5fb763c3d7\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href=\"http://www.jianshu.com/p/aef34acd111f\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href=\"http://www.jianshu.com/p/efb6fbed6fac\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href=\"http://www.jianshu.com/p/073d25a3bba0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href=\"https://www.jianshu.com/p/ba7466d7101a\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href=\"https://www.jianshu.com/p/15028f91226e\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>\n<h1 id=\"Vue-js学习系列项目地址\"><a href=\"#Vue-js学习系列项目地址\" class=\"headerlink\" title=\"Vue.js学习系列项目地址\"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack/VueStudyDemos</a></p>\n<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>\n<p>新浪微博： <a href=\"http://weibo.com/u/2640909603\" target=\"_blank\" rel=\"noopener\">http://weibo.com/u/2640909603</a><br>掘金：<a href=\"https://gold.xitu.io/user/571d953d39b0570068145cd1\" target=\"_blank\" rel=\"noopener\">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href=\"http://blog.csdn.net/violetjack0808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/violetjack0808</a><br>简书： <a href=\"http://www.jianshu.com/users/54ae4af3a98d/latest_articles\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href=\"https://github.com/violetjack\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近在用vue-cli写项目的时候，经常和ESLint打交道，也算是不打不相识啦。下面总结一下在学习Vue的时候遇到的一些问题。</p>\n</blockquote>\n<h1 id=\"ESLint简介\"><a href=\"#ESLint简介\" class=\"headerlink\" title=\"ESLint简介\"></a>ESLint简介</h1><p>关于ESLint的介绍网上很多，这里就简单说些有用的。<br>ESLint的作用是检查代码错误和统一代码风格的。由于每个人写代码的习惯都会有所不同，所以统一代码风格在团队协作中尤为重要。</p>\n<h1 id=\"vue-cli的eslint相关\"><a href=\"#vue-cli的eslint相关\" class=\"headerlink\" title=\"vue-cli的eslint相关\"></a>vue-cli的eslint相关</h1><p>vue-cli在init初始化时会询问是否需要添加ESLint，确认之后在创建的项目中就会出现<code>.eslintignore</code>和<code>.eslintrc.js</code>两个文件。<br><code>.eslintignore</code>类似Git的<code>.gitignore</code>用来忽略一些文件不使用ESLint检查。<br><code>.eslintrc.js</code>是ESLint配置文件，用来设置插件、自定义规则、解析器等配置。</p>\n<p><strong>.eslintrc.js</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// http://eslint.org/docs/user-guide/configuring</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  root: true,</span><br><span class=\"line\">  parser: &apos;babel-eslint&apos;,</span><br><span class=\"line\">  parserOptions: &#123;</span><br><span class=\"line\">    sourceType: &apos;module&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  env: &#123;</span><br><span class=\"line\">    browser: true,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style</span><br><span class=\"line\">  extends: &apos;standard&apos;,</span><br><span class=\"line\">  // required to lint *.vue files</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    &apos;html&apos;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  // add your custom rules here</span><br><span class=\"line\">  &apos;rules&apos;: &#123;</span><br><span class=\"line\">    // allow paren-less arrow functions</span><br><span class=\"line\">    &apos;arrow-parens&apos;: 0,</span><br><span class=\"line\">    // allow async-await</span><br><span class=\"line\">    &apos;generator-star-spacing&apos;: 0,</span><br><span class=\"line\">    // allow debugger during development</span><br><span class=\"line\">    &apos;no-debugger&apos;: process.env.NODE_ENV === &apos;production&apos; ? 2 : 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>解析器(parser)：</strong>使用了babel-eslint，这个可以在package.json中找到，说明我们已经安装过该解析器了。<br><strong>环境配置(env)：</strong>在浏览器中使用eslint。<br><strong>继承(extends)：</strong>该配置文件继承了<a href=\"https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style\" target=\"_blank\" rel=\"noopener\">standard</a>规则，具体规则自己看文档，看不懂有<a href=\"https://github.com/feross/standard/blob/master/docs/RULES-zhcn.md\" target=\"_blank\" rel=\"noopener\">中文版</a>的。<br><strong>规则(rules)：</strong>对于三个自定义规则，我特地查了官方文档。</p>\n<blockquote>\n<ul>\n<li>arrow-parems 允许箭头函数参数使用括号,具体操作请看<a href=\"http://eslint.org/docs/rules/arrow-parens\" target=\"_blank\" rel=\"noopener\">文档</a></li>\n<li>generator-star-spacing 允许方法之间加星号，如<code>function * generator() {}</code>。<a href=\"http://eslint.org/docs/rules/generator-star-spacing\" target=\"_blank\" rel=\"noopener\">文档</a>在此。特地查了下，发现这是ES6提供的<a href=\"https://imququ.com/post/generator-function-in-es6.html\" target=\"_blank\" rel=\"noopener\">生成器函数</a>，回头学习下。</li>\n<li>no-debugger’ 允许在开发环境下使用debugger。这个比较简单，不过还是贴下<a href=\"http://eslint.org/docs/rules/no-debugger\" target=\"_blank\" rel=\"noopener\">文档</a>便于查看。</li>\n</ul>\n</blockquote>\n<p><strong>注意：</strong>在<code>rules</code>中每个配置项后面第一个值是eslint规则的<strong>错误等级</strong>。</p>\n<ul>\n<li>“off” 或 0 - 关闭这条规则</li>\n<li>“warn” 或 1 - 违反规则会警告（不会影响项目运行）</li>\n<li>“error” 或 2 - 违反规则会报错（屏幕上一堆错误代码~）</li>\n</ul>\n<h1 id=\"遇到过的问题\"><a href=\"#遇到过的问题\" class=\"headerlink\" title=\"遇到过的问题\"></a>遇到过的问题</h1><p>由于一开始我不了解ESLint就写项目，不知道要看Standard的<a href=\"https://github.com/feross/standard/blob/master/docs/RULES-zhcn.md\" target=\"_blank\" rel=\"noopener\">文档</a>，所以遇到了很多ESLint的错误和警告，分享下希望能对朋友们有帮助。</p>\n<h3 id=\"1-Do-not-use-‘new’-for-side-effects\"><a href=\"#1-Do-not-use-‘new’-for-side-effects\" class=\"headerlink\" title=\"1. Do not use ‘new’ for side effects\"></a>1. Do not use ‘new’ for side effects</h3><p>该错误是由于我删除了<code>/* eslint-disable no-new*/</code>这段注释引发的，<code>/* eslint-disable */</code>这段注释的作用就是不让eslint检查注释下面的代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#app&apos;,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  template: &apos;&lt;App/&gt;&apos;,</span><br><span class=\"line\">  components: &#123; App &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>错误原因：</strong>不可以直接new一个新对象，需要将新对象赋值给一个变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm = new Vue()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-Strings-must-use-singlequote\"><a href=\"#2-Strings-must-use-singlequote\" class=\"headerlink\" title=\"2. Strings must use singlequote\"></a>2. Strings must use singlequote</h3><p><strong>错误原因：</strong>字符串必须用单引号<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return &#123;</span><br><span class=\"line\">      msg: &quot;Welcome to Your Vue.js App&quot;, //双引号，报错！</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-Expected-space-s-after-“return”\"><a href=\"#3-Expected-space-s-after-“return”\" class=\"headerlink\" title=\"3. Expected space(s) after “return”\"></a>3. Expected space(s) after “return”</h3><p><strong>错误原因：</strong>括号两侧必须要有空格隔开<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return&#123;// 没有空格报错</span><br><span class=\"line\">  msg: &apos;Welcome to Your Vue.js App&apos;, </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">startClock ()&#123;&#125; //)&#123;中间没有空格，报错！</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-Expected-indentation-of-8-spaces-but-found-6\"><a href=\"#4-Expected-indentation-of-8-spaces-but-found-6\" class=\"headerlink\" title=\"4. Expected indentation of 8 spaces but found 6\"></a>4. Expected indentation of 8 spaces but found 6</h3><p><strong>错误原因：</strong>使用两个空格进行缩进。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (this.IntervalID === &apos;&apos;) &#123;</span><br><span class=\"line\">this.IntervalID = setInterval(this.countDown, 1000)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实ESLint的报错并不难懂，只要理解错误原因还是很好解决的。如果提前看看文档，更不会出现太多报错问题了。这个故事告诉我们<strong>看文档是很重要滴~%&gt;_&lt;%</strong></p>\n<h1 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h1><p><strong>发现ESLint的报错都会在报错语句前面显示一个URL</strong>，点击进去可以看到详细的错误信息哦。这是我刚在写博客的时候发现的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://eslint.org/docs/rules/no-new  Do not use &apos;new&apos; for side effects  </span><br><span class=\"line\">E:\\Github\\EfficiencyTools\\EfficiencyTool-VueMobile\\src\\main.js:15:1</span><br><span class=\"line\">new Vue(&#123;</span><br></pre></td></tr></table></figure></p>\n<p>这里的 <a href=\"http://eslint.org/docs/rules/no-new\" target=\"_blank\" rel=\"noopener\">http://eslint.org/docs/rules/no-new</a> 就是ESLint规则报错的原因，还是很人性化的。</p>\n<h1 id=\"编辑器\"><a href=\"#编辑器\" class=\"headerlink\" title=\"编辑器\"></a>编辑器</h1><p>推荐使用VSCode来编辑代码。按照着<a href=\"https://github.com/varHarrie/Dawn-Blossoms/issues/10\" target=\"_blank\" rel=\"noopener\">VSCode拓展插件推荐——提高Node和Vue开发效率</a>来安装和配置插件后，写vue项目方便了很多。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>其实vue-cli的ESLint不需要我们配置太多，基本的都配置好了，如果你愿意完全可以照着vue-cli提供的规则去写代码。当我们需要修改一些规则的时候添加到rules中替换原有规则就可以了。一开始用ESLint写代码很烦，经常由于一些格式问题调试报错，让回去改格式。不过慢慢的就会发现使用ESLint之后代码的确可读性、美观性上都好了很多。<br>推荐使用ESLint来规范代码编辑~</p>\n<h1 id=\"Vue-js学习系列\"><a href=\"#Vue-js学习系列\" class=\"headerlink\" title=\"Vue.js学习系列\"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>\n<p><a href=\"http://www.jianshu.com/p/8013d8d37bd0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/d6f7e11f18af\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/8e5fb763c3d7\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href=\"http://www.jianshu.com/p/aef34acd111f\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href=\"http://www.jianshu.com/p/efb6fbed6fac\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href=\"http://www.jianshu.com/p/073d25a3bba0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href=\"https://www.jianshu.com/p/ba7466d7101a\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href=\"https://www.jianshu.com/p/15028f91226e\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>\n<h1 id=\"Vue-js学习系列项目地址\"><a href=\"#Vue-js学习系列项目地址\" class=\"headerlink\" title=\"Vue.js学习系列项目地址\"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack/VueStudyDemos</a></p>\n<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>\n<p>新浪微博： <a href=\"http://weibo.com/u/2640909603\" target=\"_blank\" rel=\"noopener\">http://weibo.com/u/2640909603</a><br>掘金：<a href=\"https://gold.xitu.io/user/571d953d39b0570068145cd1\" target=\"_blank\" rel=\"noopener\">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href=\"http://blog.csdn.net/violetjack0808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/violetjack0808</a><br>简书： <a href=\"http://www.jianshu.com/users/54ae4af3a98d/latest_articles\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href=\"https://github.com/violetjack\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack</a></p>\n"},{"title":"Vue.js学习系列八 —— Vue源码学习之State学习","date":"2018-02-02T16:00:00.000Z","_content":"\n> 关于Vue源码学习的博客， [HcySunYang](http://hcysun.me/)的[Vue2.1.7源码学习](http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/)是我所见过讲的最清晰明了的博客了，非常适合想了解Vue源码的同学入手。本文是在看了这篇博客之后进一步的学习心得。\n注意：本文所用Vue版本为 `2.5.13`\n\n# 关于源码学习\n关于学习源码，我有话要说~\n一开始我学习Vue的源码，是将 [Vue.js](https://github.com/vuejs/vue/blob/dev/dist/vue.js) 这个文件下载下来逐行去看……因为我听信了我同事说的“不过一万多行代码，实现也很简单，可以直接看。”结果可想而知，花了十几个小时看完代码，还通过打断点看流程，除了学习到一些新的js语法、一些优雅的代码写法、和对整个代码熟悉了之外，没啥其他收获。\n其实，这是一个丢西瓜捡芝麻的行为，没有明确的目的笼统的看源码，最终迷失在各种细枝末节上了。\n所以呢，我看源码的经验教训有如下几点：\n* 看代码，必须带着问题去找实现代码。\n* 保持主线，不要纠结于细枝末节。永远记住你要解决什么问题。\n* 找到一篇优质的博客、向前辈学习，让前辈带着你去学习事半功倍。\n* 想看某编程语言的代码，必须要有扎实的语言基础。走路不稳就想跑，会摔得很惨~\n* 学习之道，不能盲目。应该找到一种快速有效的方法，来有目的的实现学习目标。不要用战术上的勤奋来掩盖战略上的失误。看代码如此、看书学习亦如此~\n\n# 如何开始\n这里我们来解决从哪里开始看代码的流程，重点是**找到Vue构造函数的实现**。\n首先，找到 `package.json` 文件，从中找到编译命令 `\"dev\": \"rollup -w -c scripts/config.js --environment TARGET:web-full-dev\"`，这里 `rollup` 是类似于 Webpack 的打包工具，打包文件在 `script/config.js` 中，找到该文件。找 `entry` 入口关键字（不会rollup，但配置方式和 Webpack 差不太多）。入口文件有好多配置，我们就找到会生成 `dist/vue.js` 的配置项：\n```\n  // Runtime+compiler development build (Browser)\n  'web-full-dev': {\n    entry: resolve('web/entry-runtime-with-compiler.js'),\n    dest: resolve('dist/vue.js'),\n    format: 'umd',\n    env: 'development',\n    alias: { he: './entity-decoder' },\n    banner\n  },\n```\n好，这里就找到了 `web/entry-runtime-with-compiler.js` 这个路径，完整路径应该是 `src/platform/web/entry-runtime-with-compiler.js`。在这个文件中我们找到一个Vue对象import进来了。\n```\nimport Vue from './runtime/index'\n```\n我们顺着找到到 `src/platform/web/runtime/index.js` 这个文件，在文件中发现导入文件 \n```\nimport Vue from 'core/index'\n```\n就顺着这个思路找，最终找到 `src/core/instance/index.js` 这个文件。\n完整找到Vue实例入口文件的流程如下：\n```\npackage.json\nscript/config.js\nsrc/platform/web/entry-runtime-with-compiler.js\nsrc/platform/web/runtime/index.js\nsrc/core/index.js\nsrc/core/instance/index.js\n```\n简单看看Vue构造函数的样子~\n```\nimport { initMixin } from './init'\nimport { stateMixin } from './state'\nimport { renderMixin } from './render'\nimport { eventsMixin } from './events'\nimport { lifecycleMixin } from './lifecycle'\nimport { warn } from '../util/index'\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n\ninitMixin(Vue) // 初始化\nstateMixin(Vue) // 状态混合\neventsMixin(Vue) // 事件混合\nlifecycleMixin(Vue) // 生命周期混合\nrenderMixin(Vue) // 渲染混合\n\nexport default Vue\n```\n可以看到Vue的构造函数，里面只做了 `this._init(options)` 行为。这个 `_init` 方法在执行 `initMixin` 方法的时候定义了。找到同目录下的 `init.js` 文件。\n```\nexport function initMixin (Vue: Class<Component>) {\n  Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n\n    let startTag, endTag\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = `vue-perf-start:${vm._uid}`\n      endTag = `vue-perf-end:${vm._uid}`\n      mark(startTag)\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      // 合并配置项\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm) // 初始化代理\n    } else {\n      vm._renderProxy = vm\n    }\n    \n    vm._self = vm // 暴露对象自身\n    initLifecycle(vm) // 初始化生命周期\n    initEvents(vm) // 初始化事件：on,once,off,emit\n    initRender(vm) // 初始化渲染：涉及到Virtual DOM\n    callHook(vm, 'beforeCreate') //  触发 beforeCreate 生命周期钩子\n    initInjections(vm) // 在初始化 data/props 前初始化Injections\n    initState(vm) // 初始化状态选项\n    initProvide(vm) // 在初始化 data/props 后初始化Provide\n    // 有关inject和provide请查阅 https://cn.vuejs.org/v2/api/#provide-inject\n    callHook(vm, 'created') // 触发 created 生命周期钩子\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false)\n      mark(endTag)\n      measure(`vue ${vm._name} init`, startTag, endTag)\n    }\n    // 如果Vue配置项中有el，直接挂在到DOM中\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n}\n```\n抓住重点，**我们是要来学习State的。**从上面代码中可以找到initState方法的执行，这就是我们此行的目的——State数据选项。除此之外还有其他重要方法的初始化方式，这将会在之后的博客中继续讨论和学习。\n\n# 学习State\n之前是简单提一下学习源码的方法论和如何开始学习Vue源码学习。并且找到了我们要学习的State所在，现在进入正题：\n> 了解Vue的数据选项的运行机制。\n\n在[Vue2.1.7源码学习](http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/)中，作者已经非常非常非常清晰明了的帮我们分析了data的实现。在此基础上开始好好学习其他数据选项的实现逻辑。\n\n## 通过data理解mvvm\n这里我通过自己的思路再来整理下项目中data的实现。\n**注：**由于这一部分已经被各类源码解析博客讲烂了，而要把这部分讲清楚要大量篇幅。所以我就不贴代码了。还是那句话，抓重点！我们主要研究的是data之外的实现方式。关于data的实现和mvvm的逐步实现，[Vue2.1.7源码学习](http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/)中讲的非常清晰明了。\n\n**以下是我整理的思路，有兴趣的同学可以顺着我的思路去看看。**\n\n在 state.js 中找到 initState，并顺利找到 initData 函数。initData中主要做了以下几步操作：\n1. 获取data数据，data数据通常是一个方法，执行方法返回data数据。所以说我们要将data写成函数方法的形式。\n2. 遍历data数据，判断是否有data与props的key同名，如果没有执行proxy方法，该方法用于将data中的数据同步到vm对象上，所以我们可以通过 `vm.name` 来修改和获取 data 中的 name 的值。\n3. 执行observe方法，监听data的变化。\n\n重点在 `observe` 方法，于是我们根据 import 关系找到 `src/core/observer/index.js` 文件。`observe` 方法通过传入的值最终返回一个Observer类的实例对象。\n找到Observer类，在构造函数中为当前类创建Dep实例，然后判断数据，如果是数组，触发 observeArray 方法，遍历执行 observe 方法；如果是对象，触发walk方法。\n找到walk方法，方法中遍历了数据对象，为对象每个属性执行 defineReactive 方法。\n**找到 defineReactive 方法，该方法为 mvvm 数据变化检测的核心。**为对象属性添加 set 和 get 方法。重点来了， vue 在 get 方法中执行 `dep.depend()` 方法，在 set 方法中执行 `dep.notify()` 方法。这个先不多讲，最后进行联结说明。\n找到同目录下的 `dep.js` 文件，文件不长。定义了 Dep 类和`pushTarget`、`popTarget` 方法。在 Dep 类中有我们之前提到的 `depend` 和 `notify` 方法。看下两个方法的实现：\n```\n  depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this)\n    }\n  }\n\n  notify () {\n    // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n```\n在 `depend` 方法中，Dep.target 就是一个 Watcher 实例，它的 `addDep` 方法最终会调用到 Dep 的 `addSubs` 方法。subs 是 Watcher 数组。即将当前 watcher 存到 Dep 的 subs 数组中。\n在 `notify` 方法中，将 Watcher 数组 subs 遍历，执行他们的 `update` 方法。`update` 最终会去执行 `watcher` 的回调函数。\n即在 get 方法中将 watcher 添加到 dep，在 set 方法中通过 dep 对 watcher 进行回调函数触发。\n这里其实已经实现了数据监听，接着我们来看看 Watcher，其实 Watcher 就是Vue中 watch 选项的实现了。说到 watch 选项我们都知道它用来监听数据变化。Watcher 就是实现这个过程的玩意啦~\nWatcher的构造函数最终调用了 `get` 方法，代码如下：\n```\n get () {\n    pushTarget(this)\n    let value\n    const vm = this.vm\n    try {\n      value = this.getter.call(vm, vm)\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, `getter for watcher \"${this.expression}\"`)\n      } else {\n        throw e\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value)\n      }\n      popTarget()\n      this.cleanupDeps()\n    }\n    return value\n  }\n```\n`get` 方法做了如下几步：\n1. 将当前 Watcher 实例传递给 Dep 的 Dep.target。\n2. 执行 Watcher 所监测的数据的 `getter` 方法。\n3. 最终，将 `Dep.target` 恢复到上一个值，并且将当前 Watcher 从 Dep 的 subs 中去除。\n\n其中要注意的是，在第二步中数据的 `getter` 方法会执行到 `dep.depend()` 方法，`depend` 方法将当前 watcher 加入到 subs 中。至于步骤一和三还不太理解。挖个坑先~\n这样 watcher 就监测上数据了。那怎么使用呢？当然是数据变化时使用咯。当监测的数据变化时，执行数据 setter 方法，然后执行 dep 的 `notify` 方法。由于我们之前已经将 watcher 都收集到 dep 的 subs 中，`notify` 方法遍历执行 watcher 的 `update` 方法，`update` 方法最终遍历执行回调函数。\n\n1. 执行 `observe` 方法，创建 Observer 执行 `walk` 为对象数据添加setter 和 getter\n2. 在添加 setter 和 getter 时，创建 Dep，在 getter 方法中执行 `dep.depend()` 收集 watcher，在 setter 方法中执行 `dep.notify()` 方法，最终遍历执行 watcher 数组的回调函数。\n3. Dep 类似于 Watcher 和 Observer 的中间件。\n4. Watcher 用于监听变化，并执行回调函数。\n5. 当 Watcher 实例创建时，Watcher 实例会将自身传递给 Dep.target\n6. Watcher 调用监测数据的 `getter`方法触发 `dep.depend()`\n7. `dep.depend()`方法将当前 Watcher（Dep.target）传递给Dep的subs（watcher数组）中。\n8. 当被监测的数据内容发生改变时，执行 `setter` 方法，触发 `dep.notify()` 方法，遍历 Dep 中的 subs（watcher数组），执行 Watcher 的回调函数。\n\n嗯……就是这样~之后把挖的坑填上！\n\n## watch实现\n\n说完了 Data 的监听流程，说说 watch 应该就不难啦~\n找到 `src/core/instance/state.js` 的 `initWatch` 函数，该方法用来遍历 Vue 实例中的 watch 项，最终所有 watch 都会执行 `createWatcher` 方法。\n继续看 `createWatcher` 方法，这个方法也很简单，最终返回 `vm.$watch(keyOrFn, handler, options)`。我们继续往下找~\n在 `stateMixin` 方法中找到了定义 Vue 的 $watch 方法属性。来看看怎么实现的：\n```\n  Vue.prototype.$watch = function (\n    expOrFn: string | Function,\n    cb: any,\n    options?: Object\n  ): Function {\n    const vm: Component = this\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {}\n    options.user = true\n    const watcher = new Watcher(vm, expOrFn, cb, options)\n    if (options.immediate) {\n      cb.call(vm, watcher.value)\n    }\n    return function unwatchFn () {\n      watcher.teardown()\n    }\n  }\n```\n如果回调函数 cb 是一个对象，那么返回并执行 `createWatcher` 函数，最终还是会走到 $watch 方法中。\n否则，创建一个 Watcher 实例，当这个实例创建后，目标数据有任何变化 watch 选项中都能监听到了。如果是有 immediate 参数，那么立即执行一次Watcher的回调函数。最后返回一个解除监听的方法，执行了 Watcher 的 teardown 方法。\n那么问题来了，为什么watch选项监听数据的方法中参数是如下写法呢？\n```\nwatch: {\n  a: function(val, oldVal){\n    console.log(val)\n  }\n}\n```\n可以找到 `src/core/instance/observer/watcher.js` 中找到 `run` 方法。可以看到 `this.cb.call(this.vm, value, oldValue)` 这里的 cb 回调函数传递的参数就是 value 和 oldValue。\n这里说个基础知识，函数使用[ call 方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)执行，第一个参数是方法的this值，之后才是真正的参数。\n```\nrun () {\n    if (this.active) {\n      const value = this.get()\n      if (\n        value !== this.value ||\n        // Deep watchers and watchers on Object/Arrays should fire even\n        // when the value is the same, because the value may\n        // have mutated.\n        isObject(value) ||\n        this.deep\n      ) {\n        // set new value\n        const oldValue = this.value\n        this.value = value\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue)\n          } catch (e) {\n            handleError(e, this.vm, `callback for watcher \"${this.expression}\"`)\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue)\n        }\n      }\n    }\n  }\n```\n**小结：watch 选项其实就是为指定数据创建 Watcher 实例，接收回调函数的过程。**\n\n## props实现\n\n接下来我们看看props，官网对props的定义如下：\n\n> props 可以是数组或对象，用于接收来自父组件的数据。\n\n找到 `initProps` 方法。\n```\nfunction initProps (vm: Component, propsOptions: Object) {\n  const propsData = vm.$options.propsData || {}\n  const props = vm._props = {}\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  const keys = vm.$options._propKeys = []\n  const isRoot = !vm.$parent\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot\n  for (const key in propsOptions) {\n    keys.push(key)\n    const value = validateProp(key, propsOptions, propsData, vm)\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      const hyphenatedKey = hyphenate(key)\n      if (isReservedAttribute(hyphenatedKey) ||\n          config.isReservedAttr(hyphenatedKey)) {\n        warn(\n          `\"${hyphenatedKey}\" is a reserved attribute and cannot be used as component prop.`,\n          vm\n        )\n      }\n      defineReactive(props, key, value, () => {\n        if (vm.$parent && !isUpdatingChildComponent) {\n          warn(\n            `Avoid mutating a prop directly since the value will be ` +\n            `overwritten whenever the parent component re-renders. ` +\n            `Instead, use a data or computed property based on the prop's ` +\n            `value. Prop being mutated: \"${key}\"`,\n            vm\n          )\n        }\n      })\n    } else {\n      defineReactive(props, key, value)\n    }\n\n    if (!(key in vm)) {\n      proxy(vm, `_props`, key)\n    }\n  }\n  observerState.shouldConvert = true\n}\n```\n可以看到，props 和 data 类似。在 `initProps` 中无非做了两步：`defineReactive` 和 `proxy`，这两个方法我们在提到 data 的时候讲过了。`defineReactive` 为数据设置 setter、getter，`proxy` 方法将 `props` 中的属性映射到 Vue 实例 vm 上，便于我们可以用 `vm.myProps` 来获取数据。\n至此，我有个疑问：data与props有何不同呢？\ndata使用的是observe方法，创建一个Observer对象，Observer对象最终是执行了defineReactive方法。而props是遍历选项属性，执行defineReactive方法。中间可能就多了个Observer对象，那么这个Observer对象的作用到底在哪呢？经过实践props属性改变后界面也会改变。说明mvvm对props也是成立的。\n另外，data和props有个不同的地方就是props是不建议改变的。详见[单向数据流](https://cn.vuejs.org/v2/guide/components.html#单向数据流)\n小结：逻辑和data类似，都是监听数据。不同之处呢……再研究研究~\n\n## computed实现\n\n再来说说computed，找到初始化computed方法 `src/core/instance/state.js` 中的 `initComputed` 方法，去除非关键代码后看到其实主要有俩个行为，为 computed 属性创建 Watcher，然后执行 `defineComputed `方法。\n```\nfunction initComputed (vm: Component, computed: Object) {\n  ...\n  for (const key in computed) {\n    ...\n    if (!isSSR) {\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      )\n    }\n\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef)\n    } \n    ...\n  }\n}\n```\ndefineComputed 做了两步行为：一是定义 sharedPropertyDefinition 的 getter 和 setter，二是将 sharedPropertyDefinition 的属性传给vm，即 `Object.defineProperty(target, key, sharedPropertyDefinition)`。自此，我们可以通过 `vm.computedValue` 来获取计算属性结果了。\n**小结：computed其实也就是一个数据监听行为，与data和props不同之处就是在get函数中需要进行逻辑计算处理。**\n\n## methods实现\n\n继续在 `state.js` 中看到 `initMethods` 方法。顾名思义，这是初始化methods的方法。实现很简单，代码如下：\n```\nfunction initMethods (vm: Component, methods: Object) {\n  const props = vm.$options.props\n  for (const key in methods) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\n          `Method \"${key}\" has an undefined value in the component definition. ` +\n          `Did you reference the function correctly?`,\n          vm\n        )\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          `Method \"${key}\" has already been defined as a prop.`,\n          vm\n        )\n      }\n      if ((key in vm) && isReserved(key)) {\n        warn(\n          `Method \"${key}\" conflicts with an existing Vue instance method. ` +\n          `Avoid defining component methods that start with _ or $.`\n        )\n      }\n    }\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm)\n  }\n}\n```\n重点在最后一句。前面都排除重名和空值错误的，最后将 methods 中的方法传给 vm，方法内容如果为空则方法什么都不做。否则调用 `bind` 方法执行该函数。\n找到这个 `bind` 方法，位置在 `src/shared/util.js` 中。\n```\nexport function bind (fn: Function, ctx: Object): Function {\n  function boundFn (a) {\n    const l: number = arguments.length\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length\n  return boundFn\n}\n```\n该方法返回一个执行 `methods` 中函数的方法（这种方法的执行方式比较快）。\n**小结：将methods的方法用bind函数优化执行过程。然后将methods中的各个方法传给Vue实例对象。**\n\n# 最后\n\n本文纯属个人理解，如有任何问题，请及时指出，不胜感激~\n最后提出一个看源码的小心得：\n> 我发现……看源码、跟流程，尽量将注意力集中在**方法的执行**和**类的实例化**行为上。对于变量的获取和赋值、测试环境警报提示，简略看下就行，避免逐行阅读代码拉低效率。\n\n至此，Vue中的几个数据选项都学习了一遍了。关键在于理解mvvm的过程。data 理解之后，props、watch、computed 都好理解了。methods 和 mvvm 无关……\n通过四个早上的时间把文章写出来了~对 Vue 的理解深刻了一些，但是还是能感觉到有很多未知的知识点等着我去发掘。加油吧！今年专注于 Vue 前端学习，把 Vue 给弄懂！\n\n\n# Vue.js学习系列\n鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。\n\n[Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）](http://www.jianshu.com/p/8013d8d37bd0)\n[Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）](http://www.jianshu.com/p/d6f7e11f18af)\n[Vue.js学习系列三 —— axios和网络传输相关知识的学习实践](http://www.jianshu.com/p/8e5fb763c3d7)\n[Vue.js学习系列四 —— Webpack打包工具的使用](http://www.jianshu.com/p/aef34acd111f)\n[Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint](http://www.jianshu.com/p/efb6fbed6fac)\n[Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记](http://www.jianshu.com/p/073d25a3bba0)\n[Vue.js学习系列七 —— Vue服务器渲染Nuxt学习](https://www.jianshu.com/p/ba7466d7101a)\n[Vue.js学习系列八 —— Vue源码学习之State学习](https://www.jianshu.com/p/15028f91226e)\n\n# Vue.js学习系列项目地址\n本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。\n[https://github.com/violetjack/VueStudyDemos](https://github.com/violetjack/VueStudyDemos)\n\n# 关于作者\nVioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。\n欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。\n\n新浪微博： http://weibo.com/u/2640909603\n掘金：https://gold.xitu.io/user/571d953d39b0570068145cd1\nCSDN: http://blog.csdn.net/violetjack0808\n简书： http://www.jianshu.com/users/54ae4af3a98d/latest_articles\nGithub： https://github.com/violetjack\n\n\n","source":"_posts/Vue.js学习系列八 —— Vue源码学习之State学习.md","raw":"---\ntitle: Vue.js学习系列八 —— Vue源码学习之State学习\ndate: 2018-02-03\n---\n\n> 关于Vue源码学习的博客， [HcySunYang](http://hcysun.me/)的[Vue2.1.7源码学习](http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/)是我所见过讲的最清晰明了的博客了，非常适合想了解Vue源码的同学入手。本文是在看了这篇博客之后进一步的学习心得。\n注意：本文所用Vue版本为 `2.5.13`\n\n# 关于源码学习\n关于学习源码，我有话要说~\n一开始我学习Vue的源码，是将 [Vue.js](https://github.com/vuejs/vue/blob/dev/dist/vue.js) 这个文件下载下来逐行去看……因为我听信了我同事说的“不过一万多行代码，实现也很简单，可以直接看。”结果可想而知，花了十几个小时看完代码，还通过打断点看流程，除了学习到一些新的js语法、一些优雅的代码写法、和对整个代码熟悉了之外，没啥其他收获。\n其实，这是一个丢西瓜捡芝麻的行为，没有明确的目的笼统的看源码，最终迷失在各种细枝末节上了。\n所以呢，我看源码的经验教训有如下几点：\n* 看代码，必须带着问题去找实现代码。\n* 保持主线，不要纠结于细枝末节。永远记住你要解决什么问题。\n* 找到一篇优质的博客、向前辈学习，让前辈带着你去学习事半功倍。\n* 想看某编程语言的代码，必须要有扎实的语言基础。走路不稳就想跑，会摔得很惨~\n* 学习之道，不能盲目。应该找到一种快速有效的方法，来有目的的实现学习目标。不要用战术上的勤奋来掩盖战略上的失误。看代码如此、看书学习亦如此~\n\n# 如何开始\n这里我们来解决从哪里开始看代码的流程，重点是**找到Vue构造函数的实现**。\n首先，找到 `package.json` 文件，从中找到编译命令 `\"dev\": \"rollup -w -c scripts/config.js --environment TARGET:web-full-dev\"`，这里 `rollup` 是类似于 Webpack 的打包工具，打包文件在 `script/config.js` 中，找到该文件。找 `entry` 入口关键字（不会rollup，但配置方式和 Webpack 差不太多）。入口文件有好多配置，我们就找到会生成 `dist/vue.js` 的配置项：\n```\n  // Runtime+compiler development build (Browser)\n  'web-full-dev': {\n    entry: resolve('web/entry-runtime-with-compiler.js'),\n    dest: resolve('dist/vue.js'),\n    format: 'umd',\n    env: 'development',\n    alias: { he: './entity-decoder' },\n    banner\n  },\n```\n好，这里就找到了 `web/entry-runtime-with-compiler.js` 这个路径，完整路径应该是 `src/platform/web/entry-runtime-with-compiler.js`。在这个文件中我们找到一个Vue对象import进来了。\n```\nimport Vue from './runtime/index'\n```\n我们顺着找到到 `src/platform/web/runtime/index.js` 这个文件，在文件中发现导入文件 \n```\nimport Vue from 'core/index'\n```\n就顺着这个思路找，最终找到 `src/core/instance/index.js` 这个文件。\n完整找到Vue实例入口文件的流程如下：\n```\npackage.json\nscript/config.js\nsrc/platform/web/entry-runtime-with-compiler.js\nsrc/platform/web/runtime/index.js\nsrc/core/index.js\nsrc/core/instance/index.js\n```\n简单看看Vue构造函数的样子~\n```\nimport { initMixin } from './init'\nimport { stateMixin } from './state'\nimport { renderMixin } from './render'\nimport { eventsMixin } from './events'\nimport { lifecycleMixin } from './lifecycle'\nimport { warn } from '../util/index'\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n\ninitMixin(Vue) // 初始化\nstateMixin(Vue) // 状态混合\neventsMixin(Vue) // 事件混合\nlifecycleMixin(Vue) // 生命周期混合\nrenderMixin(Vue) // 渲染混合\n\nexport default Vue\n```\n可以看到Vue的构造函数，里面只做了 `this._init(options)` 行为。这个 `_init` 方法在执行 `initMixin` 方法的时候定义了。找到同目录下的 `init.js` 文件。\n```\nexport function initMixin (Vue: Class<Component>) {\n  Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n\n    let startTag, endTag\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = `vue-perf-start:${vm._uid}`\n      endTag = `vue-perf-end:${vm._uid}`\n      mark(startTag)\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      // 合并配置项\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm) // 初始化代理\n    } else {\n      vm._renderProxy = vm\n    }\n    \n    vm._self = vm // 暴露对象自身\n    initLifecycle(vm) // 初始化生命周期\n    initEvents(vm) // 初始化事件：on,once,off,emit\n    initRender(vm) // 初始化渲染：涉及到Virtual DOM\n    callHook(vm, 'beforeCreate') //  触发 beforeCreate 生命周期钩子\n    initInjections(vm) // 在初始化 data/props 前初始化Injections\n    initState(vm) // 初始化状态选项\n    initProvide(vm) // 在初始化 data/props 后初始化Provide\n    // 有关inject和provide请查阅 https://cn.vuejs.org/v2/api/#provide-inject\n    callHook(vm, 'created') // 触发 created 生命周期钩子\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false)\n      mark(endTag)\n      measure(`vue ${vm._name} init`, startTag, endTag)\n    }\n    // 如果Vue配置项中有el，直接挂在到DOM中\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n}\n```\n抓住重点，**我们是要来学习State的。**从上面代码中可以找到initState方法的执行，这就是我们此行的目的——State数据选项。除此之外还有其他重要方法的初始化方式，这将会在之后的博客中继续讨论和学习。\n\n# 学习State\n之前是简单提一下学习源码的方法论和如何开始学习Vue源码学习。并且找到了我们要学习的State所在，现在进入正题：\n> 了解Vue的数据选项的运行机制。\n\n在[Vue2.1.7源码学习](http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/)中，作者已经非常非常非常清晰明了的帮我们分析了data的实现。在此基础上开始好好学习其他数据选项的实现逻辑。\n\n## 通过data理解mvvm\n这里我通过自己的思路再来整理下项目中data的实现。\n**注：**由于这一部分已经被各类源码解析博客讲烂了，而要把这部分讲清楚要大量篇幅。所以我就不贴代码了。还是那句话，抓重点！我们主要研究的是data之外的实现方式。关于data的实现和mvvm的逐步实现，[Vue2.1.7源码学习](http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/)中讲的非常清晰明了。\n\n**以下是我整理的思路，有兴趣的同学可以顺着我的思路去看看。**\n\n在 state.js 中找到 initState，并顺利找到 initData 函数。initData中主要做了以下几步操作：\n1. 获取data数据，data数据通常是一个方法，执行方法返回data数据。所以说我们要将data写成函数方法的形式。\n2. 遍历data数据，判断是否有data与props的key同名，如果没有执行proxy方法，该方法用于将data中的数据同步到vm对象上，所以我们可以通过 `vm.name` 来修改和获取 data 中的 name 的值。\n3. 执行observe方法，监听data的变化。\n\n重点在 `observe` 方法，于是我们根据 import 关系找到 `src/core/observer/index.js` 文件。`observe` 方法通过传入的值最终返回一个Observer类的实例对象。\n找到Observer类，在构造函数中为当前类创建Dep实例，然后判断数据，如果是数组，触发 observeArray 方法，遍历执行 observe 方法；如果是对象，触发walk方法。\n找到walk方法，方法中遍历了数据对象，为对象每个属性执行 defineReactive 方法。\n**找到 defineReactive 方法，该方法为 mvvm 数据变化检测的核心。**为对象属性添加 set 和 get 方法。重点来了， vue 在 get 方法中执行 `dep.depend()` 方法，在 set 方法中执行 `dep.notify()` 方法。这个先不多讲，最后进行联结说明。\n找到同目录下的 `dep.js` 文件，文件不长。定义了 Dep 类和`pushTarget`、`popTarget` 方法。在 Dep 类中有我们之前提到的 `depend` 和 `notify` 方法。看下两个方法的实现：\n```\n  depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this)\n    }\n  }\n\n  notify () {\n    // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n```\n在 `depend` 方法中，Dep.target 就是一个 Watcher 实例，它的 `addDep` 方法最终会调用到 Dep 的 `addSubs` 方法。subs 是 Watcher 数组。即将当前 watcher 存到 Dep 的 subs 数组中。\n在 `notify` 方法中，将 Watcher 数组 subs 遍历，执行他们的 `update` 方法。`update` 最终会去执行 `watcher` 的回调函数。\n即在 get 方法中将 watcher 添加到 dep，在 set 方法中通过 dep 对 watcher 进行回调函数触发。\n这里其实已经实现了数据监听，接着我们来看看 Watcher，其实 Watcher 就是Vue中 watch 选项的实现了。说到 watch 选项我们都知道它用来监听数据变化。Watcher 就是实现这个过程的玩意啦~\nWatcher的构造函数最终调用了 `get` 方法，代码如下：\n```\n get () {\n    pushTarget(this)\n    let value\n    const vm = this.vm\n    try {\n      value = this.getter.call(vm, vm)\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, `getter for watcher \"${this.expression}\"`)\n      } else {\n        throw e\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value)\n      }\n      popTarget()\n      this.cleanupDeps()\n    }\n    return value\n  }\n```\n`get` 方法做了如下几步：\n1. 将当前 Watcher 实例传递给 Dep 的 Dep.target。\n2. 执行 Watcher 所监测的数据的 `getter` 方法。\n3. 最终，将 `Dep.target` 恢复到上一个值，并且将当前 Watcher 从 Dep 的 subs 中去除。\n\n其中要注意的是，在第二步中数据的 `getter` 方法会执行到 `dep.depend()` 方法，`depend` 方法将当前 watcher 加入到 subs 中。至于步骤一和三还不太理解。挖个坑先~\n这样 watcher 就监测上数据了。那怎么使用呢？当然是数据变化时使用咯。当监测的数据变化时，执行数据 setter 方法，然后执行 dep 的 `notify` 方法。由于我们之前已经将 watcher 都收集到 dep 的 subs 中，`notify` 方法遍历执行 watcher 的 `update` 方法，`update` 方法最终遍历执行回调函数。\n\n1. 执行 `observe` 方法，创建 Observer 执行 `walk` 为对象数据添加setter 和 getter\n2. 在添加 setter 和 getter 时，创建 Dep，在 getter 方法中执行 `dep.depend()` 收集 watcher，在 setter 方法中执行 `dep.notify()` 方法，最终遍历执行 watcher 数组的回调函数。\n3. Dep 类似于 Watcher 和 Observer 的中间件。\n4. Watcher 用于监听变化，并执行回调函数。\n5. 当 Watcher 实例创建时，Watcher 实例会将自身传递给 Dep.target\n6. Watcher 调用监测数据的 `getter`方法触发 `dep.depend()`\n7. `dep.depend()`方法将当前 Watcher（Dep.target）传递给Dep的subs（watcher数组）中。\n8. 当被监测的数据内容发生改变时，执行 `setter` 方法，触发 `dep.notify()` 方法，遍历 Dep 中的 subs（watcher数组），执行 Watcher 的回调函数。\n\n嗯……就是这样~之后把挖的坑填上！\n\n## watch实现\n\n说完了 Data 的监听流程，说说 watch 应该就不难啦~\n找到 `src/core/instance/state.js` 的 `initWatch` 函数，该方法用来遍历 Vue 实例中的 watch 项，最终所有 watch 都会执行 `createWatcher` 方法。\n继续看 `createWatcher` 方法，这个方法也很简单，最终返回 `vm.$watch(keyOrFn, handler, options)`。我们继续往下找~\n在 `stateMixin` 方法中找到了定义 Vue 的 $watch 方法属性。来看看怎么实现的：\n```\n  Vue.prototype.$watch = function (\n    expOrFn: string | Function,\n    cb: any,\n    options?: Object\n  ): Function {\n    const vm: Component = this\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {}\n    options.user = true\n    const watcher = new Watcher(vm, expOrFn, cb, options)\n    if (options.immediate) {\n      cb.call(vm, watcher.value)\n    }\n    return function unwatchFn () {\n      watcher.teardown()\n    }\n  }\n```\n如果回调函数 cb 是一个对象，那么返回并执行 `createWatcher` 函数，最终还是会走到 $watch 方法中。\n否则，创建一个 Watcher 实例，当这个实例创建后，目标数据有任何变化 watch 选项中都能监听到了。如果是有 immediate 参数，那么立即执行一次Watcher的回调函数。最后返回一个解除监听的方法，执行了 Watcher 的 teardown 方法。\n那么问题来了，为什么watch选项监听数据的方法中参数是如下写法呢？\n```\nwatch: {\n  a: function(val, oldVal){\n    console.log(val)\n  }\n}\n```\n可以找到 `src/core/instance/observer/watcher.js` 中找到 `run` 方法。可以看到 `this.cb.call(this.vm, value, oldValue)` 这里的 cb 回调函数传递的参数就是 value 和 oldValue。\n这里说个基础知识，函数使用[ call 方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)执行，第一个参数是方法的this值，之后才是真正的参数。\n```\nrun () {\n    if (this.active) {\n      const value = this.get()\n      if (\n        value !== this.value ||\n        // Deep watchers and watchers on Object/Arrays should fire even\n        // when the value is the same, because the value may\n        // have mutated.\n        isObject(value) ||\n        this.deep\n      ) {\n        // set new value\n        const oldValue = this.value\n        this.value = value\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue)\n          } catch (e) {\n            handleError(e, this.vm, `callback for watcher \"${this.expression}\"`)\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue)\n        }\n      }\n    }\n  }\n```\n**小结：watch 选项其实就是为指定数据创建 Watcher 实例，接收回调函数的过程。**\n\n## props实现\n\n接下来我们看看props，官网对props的定义如下：\n\n> props 可以是数组或对象，用于接收来自父组件的数据。\n\n找到 `initProps` 方法。\n```\nfunction initProps (vm: Component, propsOptions: Object) {\n  const propsData = vm.$options.propsData || {}\n  const props = vm._props = {}\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  const keys = vm.$options._propKeys = []\n  const isRoot = !vm.$parent\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot\n  for (const key in propsOptions) {\n    keys.push(key)\n    const value = validateProp(key, propsOptions, propsData, vm)\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      const hyphenatedKey = hyphenate(key)\n      if (isReservedAttribute(hyphenatedKey) ||\n          config.isReservedAttr(hyphenatedKey)) {\n        warn(\n          `\"${hyphenatedKey}\" is a reserved attribute and cannot be used as component prop.`,\n          vm\n        )\n      }\n      defineReactive(props, key, value, () => {\n        if (vm.$parent && !isUpdatingChildComponent) {\n          warn(\n            `Avoid mutating a prop directly since the value will be ` +\n            `overwritten whenever the parent component re-renders. ` +\n            `Instead, use a data or computed property based on the prop's ` +\n            `value. Prop being mutated: \"${key}\"`,\n            vm\n          )\n        }\n      })\n    } else {\n      defineReactive(props, key, value)\n    }\n\n    if (!(key in vm)) {\n      proxy(vm, `_props`, key)\n    }\n  }\n  observerState.shouldConvert = true\n}\n```\n可以看到，props 和 data 类似。在 `initProps` 中无非做了两步：`defineReactive` 和 `proxy`，这两个方法我们在提到 data 的时候讲过了。`defineReactive` 为数据设置 setter、getter，`proxy` 方法将 `props` 中的属性映射到 Vue 实例 vm 上，便于我们可以用 `vm.myProps` 来获取数据。\n至此，我有个疑问：data与props有何不同呢？\ndata使用的是observe方法，创建一个Observer对象，Observer对象最终是执行了defineReactive方法。而props是遍历选项属性，执行defineReactive方法。中间可能就多了个Observer对象，那么这个Observer对象的作用到底在哪呢？经过实践props属性改变后界面也会改变。说明mvvm对props也是成立的。\n另外，data和props有个不同的地方就是props是不建议改变的。详见[单向数据流](https://cn.vuejs.org/v2/guide/components.html#单向数据流)\n小结：逻辑和data类似，都是监听数据。不同之处呢……再研究研究~\n\n## computed实现\n\n再来说说computed，找到初始化computed方法 `src/core/instance/state.js` 中的 `initComputed` 方法，去除非关键代码后看到其实主要有俩个行为，为 computed 属性创建 Watcher，然后执行 `defineComputed `方法。\n```\nfunction initComputed (vm: Component, computed: Object) {\n  ...\n  for (const key in computed) {\n    ...\n    if (!isSSR) {\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      )\n    }\n\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef)\n    } \n    ...\n  }\n}\n```\ndefineComputed 做了两步行为：一是定义 sharedPropertyDefinition 的 getter 和 setter，二是将 sharedPropertyDefinition 的属性传给vm，即 `Object.defineProperty(target, key, sharedPropertyDefinition)`。自此，我们可以通过 `vm.computedValue` 来获取计算属性结果了。\n**小结：computed其实也就是一个数据监听行为，与data和props不同之处就是在get函数中需要进行逻辑计算处理。**\n\n## methods实现\n\n继续在 `state.js` 中看到 `initMethods` 方法。顾名思义，这是初始化methods的方法。实现很简单，代码如下：\n```\nfunction initMethods (vm: Component, methods: Object) {\n  const props = vm.$options.props\n  for (const key in methods) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\n          `Method \"${key}\" has an undefined value in the component definition. ` +\n          `Did you reference the function correctly?`,\n          vm\n        )\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          `Method \"${key}\" has already been defined as a prop.`,\n          vm\n        )\n      }\n      if ((key in vm) && isReserved(key)) {\n        warn(\n          `Method \"${key}\" conflicts with an existing Vue instance method. ` +\n          `Avoid defining component methods that start with _ or $.`\n        )\n      }\n    }\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm)\n  }\n}\n```\n重点在最后一句。前面都排除重名和空值错误的，最后将 methods 中的方法传给 vm，方法内容如果为空则方法什么都不做。否则调用 `bind` 方法执行该函数。\n找到这个 `bind` 方法，位置在 `src/shared/util.js` 中。\n```\nexport function bind (fn: Function, ctx: Object): Function {\n  function boundFn (a) {\n    const l: number = arguments.length\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length\n  return boundFn\n}\n```\n该方法返回一个执行 `methods` 中函数的方法（这种方法的执行方式比较快）。\n**小结：将methods的方法用bind函数优化执行过程。然后将methods中的各个方法传给Vue实例对象。**\n\n# 最后\n\n本文纯属个人理解，如有任何问题，请及时指出，不胜感激~\n最后提出一个看源码的小心得：\n> 我发现……看源码、跟流程，尽量将注意力集中在**方法的执行**和**类的实例化**行为上。对于变量的获取和赋值、测试环境警报提示，简略看下就行，避免逐行阅读代码拉低效率。\n\n至此，Vue中的几个数据选项都学习了一遍了。关键在于理解mvvm的过程。data 理解之后，props、watch、computed 都好理解了。methods 和 mvvm 无关……\n通过四个早上的时间把文章写出来了~对 Vue 的理解深刻了一些，但是还是能感觉到有很多未知的知识点等着我去发掘。加油吧！今年专注于 Vue 前端学习，把 Vue 给弄懂！\n\n\n# Vue.js学习系列\n鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。\n\n[Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）](http://www.jianshu.com/p/8013d8d37bd0)\n[Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）](http://www.jianshu.com/p/d6f7e11f18af)\n[Vue.js学习系列三 —— axios和网络传输相关知识的学习实践](http://www.jianshu.com/p/8e5fb763c3d7)\n[Vue.js学习系列四 —— Webpack打包工具的使用](http://www.jianshu.com/p/aef34acd111f)\n[Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint](http://www.jianshu.com/p/efb6fbed6fac)\n[Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记](http://www.jianshu.com/p/073d25a3bba0)\n[Vue.js学习系列七 —— Vue服务器渲染Nuxt学习](https://www.jianshu.com/p/ba7466d7101a)\n[Vue.js学习系列八 —— Vue源码学习之State学习](https://www.jianshu.com/p/15028f91226e)\n\n# Vue.js学习系列项目地址\n本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。\n[https://github.com/violetjack/VueStudyDemos](https://github.com/violetjack/VueStudyDemos)\n\n# 关于作者\nVioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。\n欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。\n\n新浪微博： http://weibo.com/u/2640909603\n掘金：https://gold.xitu.io/user/571d953d39b0570068145cd1\nCSDN: http://blog.csdn.net/violetjack0808\n简书： http://www.jianshu.com/users/54ae4af3a98d/latest_articles\nGithub： https://github.com/violetjack\n\n\n","slug":"Vue.js学习系列八 —— Vue源码学习之State学习","published":1,"updated":"2018-02-07T02:55:17.244Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjddwxbm80008i8bt8kbny8fd","content":"<blockquote>\n<p>关于Vue源码学习的博客， <a href=\"http://hcysun.me/\" target=\"_blank\" rel=\"noopener\">HcySunYang</a>的<a href=\"http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/\" target=\"_blank\" rel=\"noopener\">Vue2.1.7源码学习</a>是我所见过讲的最清晰明了的博客了，非常适合想了解Vue源码的同学入手。本文是在看了这篇博客之后进一步的学习心得。<br>注意：本文所用Vue版本为 <code>2.5.13</code></p>\n</blockquote>\n<h1 id=\"关于源码学习\"><a href=\"#关于源码学习\" class=\"headerlink\" title=\"关于源码学习\"></a>关于源码学习</h1><p>关于学习源码，我有话要说~<br>一开始我学习Vue的源码，是将 <a href=\"https://github.com/vuejs/vue/blob/dev/dist/vue.js\" target=\"_blank\" rel=\"noopener\">Vue.js</a> 这个文件下载下来逐行去看……因为我听信了我同事说的“不过一万多行代码，实现也很简单，可以直接看。”结果可想而知，花了十几个小时看完代码，还通过打断点看流程，除了学习到一些新的js语法、一些优雅的代码写法、和对整个代码熟悉了之外，没啥其他收获。<br>其实，这是一个丢西瓜捡芝麻的行为，没有明确的目的笼统的看源码，最终迷失在各种细枝末节上了。<br>所以呢，我看源码的经验教训有如下几点：</p>\n<ul>\n<li>看代码，必须带着问题去找实现代码。</li>\n<li>保持主线，不要纠结于细枝末节。永远记住你要解决什么问题。</li>\n<li>找到一篇优质的博客、向前辈学习，让前辈带着你去学习事半功倍。</li>\n<li>想看某编程语言的代码，必须要有扎实的语言基础。走路不稳就想跑，会摔得很惨~</li>\n<li>学习之道，不能盲目。应该找到一种快速有效的方法，来有目的的实现学习目标。不要用战术上的勤奋来掩盖战略上的失误。看代码如此、看书学习亦如此~</li>\n</ul>\n<h1 id=\"如何开始\"><a href=\"#如何开始\" class=\"headerlink\" title=\"如何开始\"></a>如何开始</h1><p>这里我们来解决从哪里开始看代码的流程，重点是<strong>找到Vue构造函数的实现</strong>。<br>首先，找到 <code>package.json</code> 文件，从中找到编译命令 <code>&quot;dev&quot;: &quot;rollup -w -c scripts/config.js --environment TARGET:web-full-dev&quot;</code>，这里 <code>rollup</code> 是类似于 Webpack 的打包工具，打包文件在 <code>script/config.js</code> 中，找到该文件。找 <code>entry</code> 入口关键字（不会rollup，但配置方式和 Webpack 差不太多）。入口文件有好多配置，我们就找到会生成 <code>dist/vue.js</code> 的配置项：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Runtime+compiler development build (Browser)</span><br><span class=\"line\">&apos;web-full-dev&apos;: &#123;</span><br><span class=\"line\">  entry: resolve(&apos;web/entry-runtime-with-compiler.js&apos;),</span><br><span class=\"line\">  dest: resolve(&apos;dist/vue.js&apos;),</span><br><span class=\"line\">  format: &apos;umd&apos;,</span><br><span class=\"line\">  env: &apos;development&apos;,</span><br><span class=\"line\">  alias: &#123; he: &apos;./entity-decoder&apos; &#125;,</span><br><span class=\"line\">  banner</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>好，这里就找到了 <code>web/entry-runtime-with-compiler.js</code> 这个路径，完整路径应该是 <code>src/platform/web/entry-runtime-with-compiler.js</code>。在这个文件中我们找到一个Vue对象import进来了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;./runtime/index&apos;</span><br></pre></td></tr></table></figure></p>\n<p>我们顺着找到到 <code>src/platform/web/runtime/index.js</code> 这个文件，在文件中发现导入文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;core/index&apos;</span><br></pre></td></tr></table></figure></p>\n<p>就顺着这个思路找，最终找到 <code>src/core/instance/index.js</code> 这个文件。<br>完整找到Vue实例入口文件的流程如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package.json</span><br><span class=\"line\">script/config.js</span><br><span class=\"line\">src/platform/web/entry-runtime-with-compiler.js</span><br><span class=\"line\">src/platform/web/runtime/index.js</span><br><span class=\"line\">src/core/index.js</span><br><span class=\"line\">src/core/instance/index.js</span><br></pre></td></tr></table></figure></p>\n<p>简单看看Vue构造函数的样子~<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; initMixin &#125; from &apos;./init&apos;</span><br><span class=\"line\">import &#123; stateMixin &#125; from &apos;./state&apos;</span><br><span class=\"line\">import &#123; renderMixin &#125; from &apos;./render&apos;</span><br><span class=\"line\">import &#123; eventsMixin &#125; from &apos;./events&apos;</span><br><span class=\"line\">import &#123; lifecycleMixin &#125; from &apos;./lifecycle&apos;</span><br><span class=\"line\">import &#123; warn &#125; from &apos;../util/index&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">function Vue (options) &#123;</span><br><span class=\"line\">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class=\"line\">    !(this instanceof Vue)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">initMixin(Vue) // 初始化</span><br><span class=\"line\">stateMixin(Vue) // 状态混合</span><br><span class=\"line\">eventsMixin(Vue) // 事件混合</span><br><span class=\"line\">lifecycleMixin(Vue) // 生命周期混合</span><br><span class=\"line\">renderMixin(Vue) // 渲染混合</span><br><span class=\"line\"></span><br><span class=\"line\">export default Vue</span><br></pre></td></tr></table></figure></p>\n<p>可以看到Vue的构造函数，里面只做了 <code>this._init(options)</code> 行为。这个 <code>_init</code> 方法在执行 <code>initMixin</code> 方法的时候定义了。找到同目录下的 <code>init.js</code> 文件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function initMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class=\"line\">  Vue.prototype._init = function (options?: Object) &#123;</span><br><span class=\"line\">    const vm: Component = this</span><br><span class=\"line\">    // a uid</span><br><span class=\"line\">    vm._uid = uid++</span><br><span class=\"line\"></span><br><span class=\"line\">    let startTag, endTag</span><br><span class=\"line\">    /* istanbul ignore if */</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class=\"line\">      startTag = `vue-perf-start:$&#123;vm._uid&#125;`</span><br><span class=\"line\">      endTag = `vue-perf-end:$&#123;vm._uid&#125;`</span><br><span class=\"line\">      mark(startTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // a flag to avoid this being observed</span><br><span class=\"line\">    vm._isVue = true</span><br><span class=\"line\">    // merge options</span><br><span class=\"line\">    if (options &amp;&amp; options._isComponent) &#123;</span><br><span class=\"line\">      // optimize internal component instantiation</span><br><span class=\"line\">      // since dynamic options merging is pretty slow, and none of the</span><br><span class=\"line\">      // internal component options needs special treatment.</span><br><span class=\"line\">      initInternalComponent(vm, options)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // 合并配置项</span><br><span class=\"line\">      vm.$options = mergeOptions(</span><br><span class=\"line\">        resolveConstructorOptions(vm.constructor),</span><br><span class=\"line\">        options || &#123;&#125;,</span><br><span class=\"line\">        vm</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /* istanbul ignore else */</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      initProxy(vm) // 初始化代理</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      vm._renderProxy = vm</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vm._self = vm // 暴露对象自身</span><br><span class=\"line\">    initLifecycle(vm) // 初始化生命周期</span><br><span class=\"line\">    initEvents(vm) // 初始化事件：on,once,off,emit</span><br><span class=\"line\">    initRender(vm) // 初始化渲染：涉及到Virtual DOM</span><br><span class=\"line\">    callHook(vm, &apos;beforeCreate&apos;) //  触发 beforeCreate 生命周期钩子</span><br><span class=\"line\">    initInjections(vm) // 在初始化 data/props 前初始化Injections</span><br><span class=\"line\">    initState(vm) // 初始化状态选项</span><br><span class=\"line\">    initProvide(vm) // 在初始化 data/props 后初始化Provide</span><br><span class=\"line\">    // 有关inject和provide请查阅 https://cn.vuejs.org/v2/api/#provide-inject</span><br><span class=\"line\">    callHook(vm, &apos;created&apos;) // 触发 created 生命周期钩子</span><br><span class=\"line\"></span><br><span class=\"line\">    /* istanbul ignore if */</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class=\"line\">      vm._name = formatComponentName(vm, false)</span><br><span class=\"line\">      mark(endTag)</span><br><span class=\"line\">      measure(`vue $&#123;vm._name&#125; init`, startTag, endTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果Vue配置项中有el，直接挂在到DOM中</span><br><span class=\"line\">    if (vm.$options.el) &#123;</span><br><span class=\"line\">      vm.$mount(vm.$options.el)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>抓住重点，<strong>我们是要来学习State的。</strong>从上面代码中可以找到initState方法的执行，这就是我们此行的目的——State数据选项。除此之外还有其他重要方法的初始化方式，这将会在之后的博客中继续讨论和学习。</p>\n<h1 id=\"学习State\"><a href=\"#学习State\" class=\"headerlink\" title=\"学习State\"></a>学习State</h1><p>之前是简单提一下学习源码的方法论和如何开始学习Vue源码学习。并且找到了我们要学习的State所在，现在进入正题：</p>\n<blockquote>\n<p>了解Vue的数据选项的运行机制。</p>\n</blockquote>\n<p>在<a href=\"http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/\" target=\"_blank\" rel=\"noopener\">Vue2.1.7源码学习</a>中，作者已经非常非常非常清晰明了的帮我们分析了data的实现。在此基础上开始好好学习其他数据选项的实现逻辑。</p>\n<h2 id=\"通过data理解mvvm\"><a href=\"#通过data理解mvvm\" class=\"headerlink\" title=\"通过data理解mvvm\"></a>通过data理解mvvm</h2><p>这里我通过自己的思路再来整理下项目中data的实现。<br><strong>注：</strong>由于这一部分已经被各类源码解析博客讲烂了，而要把这部分讲清楚要大量篇幅。所以我就不贴代码了。还是那句话，抓重点！我们主要研究的是data之外的实现方式。关于data的实现和mvvm的逐步实现，<a href=\"http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/\" target=\"_blank\" rel=\"noopener\">Vue2.1.7源码学习</a>中讲的非常清晰明了。</p>\n<p><strong>以下是我整理的思路，有兴趣的同学可以顺着我的思路去看看。</strong></p>\n<p>在 state.js 中找到 initState，并顺利找到 initData 函数。initData中主要做了以下几步操作：</p>\n<ol>\n<li>获取data数据，data数据通常是一个方法，执行方法返回data数据。所以说我们要将data写成函数方法的形式。</li>\n<li>遍历data数据，判断是否有data与props的key同名，如果没有执行proxy方法，该方法用于将data中的数据同步到vm对象上，所以我们可以通过 <code>vm.name</code> 来修改和获取 data 中的 name 的值。</li>\n<li>执行observe方法，监听data的变化。</li>\n</ol>\n<p>重点在 <code>observe</code> 方法，于是我们根据 import 关系找到 <code>src/core/observer/index.js</code> 文件。<code>observe</code> 方法通过传入的值最终返回一个Observer类的实例对象。<br>找到Observer类，在构造函数中为当前类创建Dep实例，然后判断数据，如果是数组，触发 observeArray 方法，遍历执行 observe 方法；如果是对象，触发walk方法。<br>找到walk方法，方法中遍历了数据对象，为对象每个属性执行 defineReactive 方法。<br><strong>找到 defineReactive 方法，该方法为 mvvm 数据变化检测的核心。</strong>为对象属性添加 set 和 get 方法。重点来了， vue 在 get 方法中执行 <code>dep.depend()</code> 方法，在 set 方法中执行 <code>dep.notify()</code> 方法。这个先不多讲，最后进行联结说明。<br>找到同目录下的 <code>dep.js</code> 文件，文件不长。定义了 Dep 类和<code>pushTarget</code>、<code>popTarget</code> 方法。在 Dep 类中有我们之前提到的 <code>depend</code> 和 <code>notify</code> 方法。看下两个方法的实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">depend () &#123;</span><br><span class=\"line\">  if (Dep.target) &#123;</span><br><span class=\"line\">    Dep.target.addDep(this)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">notify () &#123;</span><br><span class=\"line\">  // stabilize the subscriber list first</span><br><span class=\"line\">  const subs = this.subs.slice()</span><br><span class=\"line\">  for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">    subs[i].update()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 <code>depend</code> 方法中，Dep.target 就是一个 Watcher 实例，它的 <code>addDep</code> 方法最终会调用到 Dep 的 <code>addSubs</code> 方法。subs 是 Watcher 数组。即将当前 watcher 存到 Dep 的 subs 数组中。<br>在 <code>notify</code> 方法中，将 Watcher 数组 subs 遍历，执行他们的 <code>update</code> 方法。<code>update</code> 最终会去执行 <code>watcher</code> 的回调函数。<br>即在 get 方法中将 watcher 添加到 dep，在 set 方法中通过 dep 对 watcher 进行回调函数触发。<br>这里其实已经实现了数据监听，接着我们来看看 Watcher，其实 Watcher 就是Vue中 watch 选项的实现了。说到 watch 选项我们都知道它用来监听数据变化。Watcher 就是实现这个过程的玩意啦~<br>Watcher的构造函数最终调用了 <code>get</code> 方法，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get () &#123;</span><br><span class=\"line\">   pushTarget(this)</span><br><span class=\"line\">   let value</span><br><span class=\"line\">   const vm = this.vm</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">     value = this.getter.call(vm, vm)</span><br><span class=\"line\">   &#125; catch (e) &#123;</span><br><span class=\"line\">     if (this.user) &#123;</span><br><span class=\"line\">       handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class=\"line\">     &#125; else &#123;</span><br><span class=\"line\">       throw e</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125; finally &#123;</span><br><span class=\"line\">     // &quot;touch&quot; every property so they are all tracked as</span><br><span class=\"line\">     // dependencies for deep watching</span><br><span class=\"line\">     if (this.deep) &#123;</span><br><span class=\"line\">       traverse(value)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     popTarget()</span><br><span class=\"line\">     this.cleanupDeps()</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return value</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>get</code> 方法做了如下几步：</p>\n<ol>\n<li>将当前 Watcher 实例传递给 Dep 的 Dep.target。</li>\n<li>执行 Watcher 所监测的数据的 <code>getter</code> 方法。</li>\n<li>最终，将 <code>Dep.target</code> 恢复到上一个值，并且将当前 Watcher 从 Dep 的 subs 中去除。</li>\n</ol>\n<p>其中要注意的是，在第二步中数据的 <code>getter</code> 方法会执行到 <code>dep.depend()</code> 方法，<code>depend</code> 方法将当前 watcher 加入到 subs 中。至于步骤一和三还不太理解。挖个坑先~<br>这样 watcher 就监测上数据了。那怎么使用呢？当然是数据变化时使用咯。当监测的数据变化时，执行数据 setter 方法，然后执行 dep 的 <code>notify</code> 方法。由于我们之前已经将 watcher 都收集到 dep 的 subs 中，<code>notify</code> 方法遍历执行 watcher 的 <code>update</code> 方法，<code>update</code> 方法最终遍历执行回调函数。</p>\n<ol>\n<li>执行 <code>observe</code> 方法，创建 Observer 执行 <code>walk</code> 为对象数据添加setter 和 getter</li>\n<li>在添加 setter 和 getter 时，创建 Dep，在 getter 方法中执行 <code>dep.depend()</code> 收集 watcher，在 setter 方法中执行 <code>dep.notify()</code> 方法，最终遍历执行 watcher 数组的回调函数。</li>\n<li>Dep 类似于 Watcher 和 Observer 的中间件。</li>\n<li>Watcher 用于监听变化，并执行回调函数。</li>\n<li>当 Watcher 实例创建时，Watcher 实例会将自身传递给 Dep.target</li>\n<li>Watcher 调用监测数据的 <code>getter</code>方法触发 <code>dep.depend()</code></li>\n<li><code>dep.depend()</code>方法将当前 Watcher（Dep.target）传递给Dep的subs（watcher数组）中。</li>\n<li>当被监测的数据内容发生改变时，执行 <code>setter</code> 方法，触发 <code>dep.notify()</code> 方法，遍历 Dep 中的 subs（watcher数组），执行 Watcher 的回调函数。</li>\n</ol>\n<p>嗯……就是这样~之后把挖的坑填上！</p>\n<h2 id=\"watch实现\"><a href=\"#watch实现\" class=\"headerlink\" title=\"watch实现\"></a>watch实现</h2><p>说完了 Data 的监听流程，说说 watch 应该就不难啦~<br>找到 <code>src/core/instance/state.js</code> 的 <code>initWatch</code> 函数，该方法用来遍历 Vue 实例中的 watch 项，最终所有 watch 都会执行 <code>createWatcher</code> 方法。<br>继续看 <code>createWatcher</code> 方法，这个方法也很简单，最终返回 <code>vm.$watch(keyOrFn, handler, options)</code>。我们继续往下找~<br>在 <code>stateMixin</code> 方法中找到了定义 Vue 的 $watch 方法属性。来看看怎么实现的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.prototype.$watch = function (</span><br><span class=\"line\">  expOrFn: string | Function,</span><br><span class=\"line\">  cb: any,</span><br><span class=\"line\">  options?: Object</span><br><span class=\"line\">): Function &#123;</span><br><span class=\"line\">  const vm: Component = this</span><br><span class=\"line\">  if (isPlainObject(cb)) &#123;</span><br><span class=\"line\">    return createWatcher(vm, expOrFn, cb, options)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  options = options || &#123;&#125;</span><br><span class=\"line\">  options.user = true</span><br><span class=\"line\">  const watcher = new Watcher(vm, expOrFn, cb, options)</span><br><span class=\"line\">  if (options.immediate) &#123;</span><br><span class=\"line\">    cb.call(vm, watcher.value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return function unwatchFn () &#123;</span><br><span class=\"line\">    watcher.teardown()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果回调函数 cb 是一个对象，那么返回并执行 <code>createWatcher</code> 函数，最终还是会走到 $watch 方法中。<br>否则，创建一个 Watcher 实例，当这个实例创建后，目标数据有任何变化 watch 选项中都能监听到了。如果是有 immediate 参数，那么立即执行一次Watcher的回调函数。最后返回一个解除监听的方法，执行了 Watcher 的 teardown 方法。<br>那么问题来了，为什么watch选项监听数据的方法中参数是如下写法呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch: &#123;</span><br><span class=\"line\">  a: function(val, oldVal)&#123;</span><br><span class=\"line\">    console.log(val)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以找到 <code>src/core/instance/observer/watcher.js</code> 中找到 <code>run</code> 方法。可以看到 <code>this.cb.call(this.vm, value, oldValue)</code> 这里的 cb 回调函数传递的参数就是 value 和 oldValue。<br>这里说个基础知识，函数使用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call\" target=\"_blank\" rel=\"noopener\"> call 方法</a>执行，第一个参数是方法的this值，之后才是真正的参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">run () &#123;</span><br><span class=\"line\">    if (this.active) &#123;</span><br><span class=\"line\">      const value = this.get()</span><br><span class=\"line\">      if (</span><br><span class=\"line\">        value !== this.value ||</span><br><span class=\"line\">        // Deep watchers and watchers on Object/Arrays should fire even</span><br><span class=\"line\">        // when the value is the same, because the value may</span><br><span class=\"line\">        // have mutated.</span><br><span class=\"line\">        isObject(value) ||</span><br><span class=\"line\">        this.deep</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        // set new value</span><br><span class=\"line\">        const oldValue = this.value</span><br><span class=\"line\">        this.value = value</span><br><span class=\"line\">        if (this.user) &#123;</span><br><span class=\"line\">          try &#123;</span><br><span class=\"line\">            this.cb.call(this.vm, value, oldValue)</span><br><span class=\"line\">          &#125; catch (e) &#123;</span><br><span class=\"line\">            handleError(e, this.vm, `callback for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          this.cb.call(this.vm, value, oldValue)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>小结：watch 选项其实就是为指定数据创建 Watcher 实例，接收回调函数的过程。</strong></p>\n<h2 id=\"props实现\"><a href=\"#props实现\" class=\"headerlink\" title=\"props实现\"></a>props实现</h2><p>接下来我们看看props，官网对props的定义如下：</p>\n<blockquote>\n<p>props 可以是数组或对象，用于接收来自父组件的数据。</p>\n</blockquote>\n<p>找到 <code>initProps</code> 方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function initProps (vm: Component, propsOptions: Object) &#123;</span><br><span class=\"line\">  const propsData = vm.$options.propsData || &#123;&#125;</span><br><span class=\"line\">  const props = vm._props = &#123;&#125;</span><br><span class=\"line\">  // cache prop keys so that future props updates can iterate using Array</span><br><span class=\"line\">  // instead of dynamic object key enumeration.</span><br><span class=\"line\">  const keys = vm.$options._propKeys = []</span><br><span class=\"line\">  const isRoot = !vm.$parent</span><br><span class=\"line\">  // root instance props should be converted</span><br><span class=\"line\">  observerState.shouldConvert = isRoot</span><br><span class=\"line\">  for (const key in propsOptions) &#123;</span><br><span class=\"line\">    keys.push(key)</span><br><span class=\"line\">    const value = validateProp(key, propsOptions, propsData, vm)</span><br><span class=\"line\">    /* istanbul ignore else */</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      const hyphenatedKey = hyphenate(key)</span><br><span class=\"line\">      if (isReservedAttribute(hyphenatedKey) ||</span><br><span class=\"line\">          config.isReservedAttr(hyphenatedKey)) &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          `&quot;$&#123;hyphenatedKey&#125;&quot; is a reserved attribute and cannot be used as component prop.`,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      defineReactive(props, key, value, () =&gt; &#123;</span><br><span class=\"line\">        if (vm.$parent &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class=\"line\">          warn(</span><br><span class=\"line\">            `Avoid mutating a prop directly since the value will be ` +</span><br><span class=\"line\">            `overwritten whenever the parent component re-renders. ` +</span><br><span class=\"line\">            `Instead, use a data or computed property based on the prop&apos;s ` +</span><br><span class=\"line\">            `value. Prop being mutated: &quot;$&#123;key&#125;&quot;`,</span><br><span class=\"line\">            vm</span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      defineReactive(props, key, value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!(key in vm)) &#123;</span><br><span class=\"line\">      proxy(vm, `_props`, key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  observerState.shouldConvert = true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，props 和 data 类似。在 <code>initProps</code> 中无非做了两步：<code>defineReactive</code> 和 <code>proxy</code>，这两个方法我们在提到 data 的时候讲过了。<code>defineReactive</code> 为数据设置 setter、getter，<code>proxy</code> 方法将 <code>props</code> 中的属性映射到 Vue 实例 vm 上，便于我们可以用 <code>vm.myProps</code> 来获取数据。<br>至此，我有个疑问：data与props有何不同呢？<br>data使用的是observe方法，创建一个Observer对象，Observer对象最终是执行了defineReactive方法。而props是遍历选项属性，执行defineReactive方法。中间可能就多了个Observer对象，那么这个Observer对象的作用到底在哪呢？经过实践props属性改变后界面也会改变。说明mvvm对props也是成立的。<br>另外，data和props有个不同的地方就是props是不建议改变的。详见<a href=\"https://cn.vuejs.org/v2/guide/components.html#单向数据流\" target=\"_blank\" rel=\"noopener\">单向数据流</a><br>小结：逻辑和data类似，都是监听数据。不同之处呢……再研究研究~</p>\n<h2 id=\"computed实现\"><a href=\"#computed实现\" class=\"headerlink\" title=\"computed实现\"></a>computed实现</h2><p>再来说说computed，找到初始化computed方法 <code>src/core/instance/state.js</code> 中的 <code>initComputed</code> 方法，去除非关键代码后看到其实主要有俩个行为，为 computed 属性创建 Watcher，然后执行 <code>defineComputed</code>方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function initComputed (vm: Component, computed: Object) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  for (const key in computed) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    if (!isSSR) &#123;</span><br><span class=\"line\">      watchers[key] = new Watcher(</span><br><span class=\"line\">        vm,</span><br><span class=\"line\">        getter || noop,</span><br><span class=\"line\">        noop,</span><br><span class=\"line\">        computedWatcherOptions</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!(key in vm)) &#123;</span><br><span class=\"line\">      defineComputed(vm, key, userDef)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>defineComputed 做了两步行为：一是定义 sharedPropertyDefinition 的 getter 和 setter，二是将 sharedPropertyDefinition 的属性传给vm，即 <code>Object.defineProperty(target, key, sharedPropertyDefinition)</code>。自此，我们可以通过 <code>vm.computedValue</code> 来获取计算属性结果了。<br><strong>小结：computed其实也就是一个数据监听行为，与data和props不同之处就是在get函数中需要进行逻辑计算处理。</strong></p>\n<h2 id=\"methods实现\"><a href=\"#methods实现\" class=\"headerlink\" title=\"methods实现\"></a>methods实现</h2><p>继续在 <code>state.js</code> 中看到 <code>initMethods</code> 方法。顾名思义，这是初始化methods的方法。实现很简单，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function initMethods (vm: Component, methods: Object) &#123;</span><br><span class=\"line\">  const props = vm.$options.props</span><br><span class=\"line\">  for (const key in methods) &#123;</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      if (methods[key] == null) &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          `Method &quot;$&#123;key&#125;&quot; has an undefined value in the component definition. ` +</span><br><span class=\"line\">          `Did you reference the function correctly?`,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          `Method &quot;$&#123;key&#125;&quot; has already been defined as a prop.`,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if ((key in vm) &amp;&amp; isReserved(key)) &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          `Method &quot;$&#123;key&#125;&quot; conflicts with an existing Vue instance method. ` +</span><br><span class=\"line\">          `Avoid defining component methods that start with _ or $.`</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vm[key] = methods[key] == null ? noop : bind(methods[key], vm)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>重点在最后一句。前面都排除重名和空值错误的，最后将 methods 中的方法传给 vm，方法内容如果为空则方法什么都不做。否则调用 <code>bind</code> 方法执行该函数。<br>找到这个 <code>bind</code> 方法，位置在 <code>src/shared/util.js</code> 中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function bind (fn: Function, ctx: Object): Function &#123;</span><br><span class=\"line\">  function boundFn (a) &#123;</span><br><span class=\"line\">    const l: number = arguments.length</span><br><span class=\"line\">    return l</span><br><span class=\"line\">      ? l &gt; 1</span><br><span class=\"line\">        ? fn.apply(ctx, arguments)</span><br><span class=\"line\">        : fn.call(ctx, a)</span><br><span class=\"line\">      : fn.call(ctx)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // record original fn length</span><br><span class=\"line\">  boundFn._length = fn.length</span><br><span class=\"line\">  return boundFn</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该方法返回一个执行 <code>methods</code> 中函数的方法（这种方法的执行方式比较快）。<br><strong>小结：将methods的方法用bind函数优化执行过程。然后将methods中的各个方法传给Vue实例对象。</strong></p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>本文纯属个人理解，如有任何问题，请及时指出，不胜感激~<br>最后提出一个看源码的小心得：</p>\n<blockquote>\n<p>我发现……看源码、跟流程，尽量将注意力集中在<strong>方法的执行</strong>和<strong>类的实例化</strong>行为上。对于变量的获取和赋值、测试环境警报提示，简略看下就行，避免逐行阅读代码拉低效率。</p>\n</blockquote>\n<p>至此，Vue中的几个数据选项都学习了一遍了。关键在于理解mvvm的过程。data 理解之后，props、watch、computed 都好理解了。methods 和 mvvm 无关……<br>通过四个早上的时间把文章写出来了~对 Vue 的理解深刻了一些，但是还是能感觉到有很多未知的知识点等着我去发掘。加油吧！今年专注于 Vue 前端学习，把 Vue 给弄懂！</p>\n<h1 id=\"Vue-js学习系列\"><a href=\"#Vue-js学习系列\" class=\"headerlink\" title=\"Vue.js学习系列\"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>\n<p><a href=\"http://www.jianshu.com/p/8013d8d37bd0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/d6f7e11f18af\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/8e5fb763c3d7\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href=\"http://www.jianshu.com/p/aef34acd111f\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href=\"http://www.jianshu.com/p/efb6fbed6fac\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href=\"http://www.jianshu.com/p/073d25a3bba0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href=\"https://www.jianshu.com/p/ba7466d7101a\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href=\"https://www.jianshu.com/p/15028f91226e\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>\n<h1 id=\"Vue-js学习系列项目地址\"><a href=\"#Vue-js学习系列项目地址\" class=\"headerlink\" title=\"Vue.js学习系列项目地址\"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack/VueStudyDemos</a></p>\n<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>\n<p>新浪微博： <a href=\"http://weibo.com/u/2640909603\" target=\"_blank\" rel=\"noopener\">http://weibo.com/u/2640909603</a><br>掘金：<a href=\"https://gold.xitu.io/user/571d953d39b0570068145cd1\" target=\"_blank\" rel=\"noopener\">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href=\"http://blog.csdn.net/violetjack0808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/violetjack0808</a><br>简书： <a href=\"http://www.jianshu.com/users/54ae4af3a98d/latest_articles\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href=\"https://github.com/violetjack\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>关于Vue源码学习的博客， <a href=\"http://hcysun.me/\" target=\"_blank\" rel=\"noopener\">HcySunYang</a>的<a href=\"http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/\" target=\"_blank\" rel=\"noopener\">Vue2.1.7源码学习</a>是我所见过讲的最清晰明了的博客了，非常适合想了解Vue源码的同学入手。本文是在看了这篇博客之后进一步的学习心得。<br>注意：本文所用Vue版本为 <code>2.5.13</code></p>\n</blockquote>\n<h1 id=\"关于源码学习\"><a href=\"#关于源码学习\" class=\"headerlink\" title=\"关于源码学习\"></a>关于源码学习</h1><p>关于学习源码，我有话要说~<br>一开始我学习Vue的源码，是将 <a href=\"https://github.com/vuejs/vue/blob/dev/dist/vue.js\" target=\"_blank\" rel=\"noopener\">Vue.js</a> 这个文件下载下来逐行去看……因为我听信了我同事说的“不过一万多行代码，实现也很简单，可以直接看。”结果可想而知，花了十几个小时看完代码，还通过打断点看流程，除了学习到一些新的js语法、一些优雅的代码写法、和对整个代码熟悉了之外，没啥其他收获。<br>其实，这是一个丢西瓜捡芝麻的行为，没有明确的目的笼统的看源码，最终迷失在各种细枝末节上了。<br>所以呢，我看源码的经验教训有如下几点：</p>\n<ul>\n<li>看代码，必须带着问题去找实现代码。</li>\n<li>保持主线，不要纠结于细枝末节。永远记住你要解决什么问题。</li>\n<li>找到一篇优质的博客、向前辈学习，让前辈带着你去学习事半功倍。</li>\n<li>想看某编程语言的代码，必须要有扎实的语言基础。走路不稳就想跑，会摔得很惨~</li>\n<li>学习之道，不能盲目。应该找到一种快速有效的方法，来有目的的实现学习目标。不要用战术上的勤奋来掩盖战略上的失误。看代码如此、看书学习亦如此~</li>\n</ul>\n<h1 id=\"如何开始\"><a href=\"#如何开始\" class=\"headerlink\" title=\"如何开始\"></a>如何开始</h1><p>这里我们来解决从哪里开始看代码的流程，重点是<strong>找到Vue构造函数的实现</strong>。<br>首先，找到 <code>package.json</code> 文件，从中找到编译命令 <code>&quot;dev&quot;: &quot;rollup -w -c scripts/config.js --environment TARGET:web-full-dev&quot;</code>，这里 <code>rollup</code> 是类似于 Webpack 的打包工具，打包文件在 <code>script/config.js</code> 中，找到该文件。找 <code>entry</code> 入口关键字（不会rollup，但配置方式和 Webpack 差不太多）。入口文件有好多配置，我们就找到会生成 <code>dist/vue.js</code> 的配置项：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Runtime+compiler development build (Browser)</span><br><span class=\"line\">&apos;web-full-dev&apos;: &#123;</span><br><span class=\"line\">  entry: resolve(&apos;web/entry-runtime-with-compiler.js&apos;),</span><br><span class=\"line\">  dest: resolve(&apos;dist/vue.js&apos;),</span><br><span class=\"line\">  format: &apos;umd&apos;,</span><br><span class=\"line\">  env: &apos;development&apos;,</span><br><span class=\"line\">  alias: &#123; he: &apos;./entity-decoder&apos; &#125;,</span><br><span class=\"line\">  banner</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>好，这里就找到了 <code>web/entry-runtime-with-compiler.js</code> 这个路径，完整路径应该是 <code>src/platform/web/entry-runtime-with-compiler.js</code>。在这个文件中我们找到一个Vue对象import进来了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;./runtime/index&apos;</span><br></pre></td></tr></table></figure></p>\n<p>我们顺着找到到 <code>src/platform/web/runtime/index.js</code> 这个文件，在文件中发现导入文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;core/index&apos;</span><br></pre></td></tr></table></figure></p>\n<p>就顺着这个思路找，最终找到 <code>src/core/instance/index.js</code> 这个文件。<br>完整找到Vue实例入口文件的流程如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package.json</span><br><span class=\"line\">script/config.js</span><br><span class=\"line\">src/platform/web/entry-runtime-with-compiler.js</span><br><span class=\"line\">src/platform/web/runtime/index.js</span><br><span class=\"line\">src/core/index.js</span><br><span class=\"line\">src/core/instance/index.js</span><br></pre></td></tr></table></figure></p>\n<p>简单看看Vue构造函数的样子~<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; initMixin &#125; from &apos;./init&apos;</span><br><span class=\"line\">import &#123; stateMixin &#125; from &apos;./state&apos;</span><br><span class=\"line\">import &#123; renderMixin &#125; from &apos;./render&apos;</span><br><span class=\"line\">import &#123; eventsMixin &#125; from &apos;./events&apos;</span><br><span class=\"line\">import &#123; lifecycleMixin &#125; from &apos;./lifecycle&apos;</span><br><span class=\"line\">import &#123; warn &#125; from &apos;../util/index&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">function Vue (options) &#123;</span><br><span class=\"line\">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class=\"line\">    !(this instanceof Vue)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">initMixin(Vue) // 初始化</span><br><span class=\"line\">stateMixin(Vue) // 状态混合</span><br><span class=\"line\">eventsMixin(Vue) // 事件混合</span><br><span class=\"line\">lifecycleMixin(Vue) // 生命周期混合</span><br><span class=\"line\">renderMixin(Vue) // 渲染混合</span><br><span class=\"line\"></span><br><span class=\"line\">export default Vue</span><br></pre></td></tr></table></figure></p>\n<p>可以看到Vue的构造函数，里面只做了 <code>this._init(options)</code> 行为。这个 <code>_init</code> 方法在执行 <code>initMixin</code> 方法的时候定义了。找到同目录下的 <code>init.js</code> 文件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function initMixin (Vue: Class&lt;Component&gt;) &#123;</span><br><span class=\"line\">  Vue.prototype._init = function (options?: Object) &#123;</span><br><span class=\"line\">    const vm: Component = this</span><br><span class=\"line\">    // a uid</span><br><span class=\"line\">    vm._uid = uid++</span><br><span class=\"line\"></span><br><span class=\"line\">    let startTag, endTag</span><br><span class=\"line\">    /* istanbul ignore if */</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class=\"line\">      startTag = `vue-perf-start:$&#123;vm._uid&#125;`</span><br><span class=\"line\">      endTag = `vue-perf-end:$&#123;vm._uid&#125;`</span><br><span class=\"line\">      mark(startTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // a flag to avoid this being observed</span><br><span class=\"line\">    vm._isVue = true</span><br><span class=\"line\">    // merge options</span><br><span class=\"line\">    if (options &amp;&amp; options._isComponent) &#123;</span><br><span class=\"line\">      // optimize internal component instantiation</span><br><span class=\"line\">      // since dynamic options merging is pretty slow, and none of the</span><br><span class=\"line\">      // internal component options needs special treatment.</span><br><span class=\"line\">      initInternalComponent(vm, options)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // 合并配置项</span><br><span class=\"line\">      vm.$options = mergeOptions(</span><br><span class=\"line\">        resolveConstructorOptions(vm.constructor),</span><br><span class=\"line\">        options || &#123;&#125;,</span><br><span class=\"line\">        vm</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /* istanbul ignore else */</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      initProxy(vm) // 初始化代理</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      vm._renderProxy = vm</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vm._self = vm // 暴露对象自身</span><br><span class=\"line\">    initLifecycle(vm) // 初始化生命周期</span><br><span class=\"line\">    initEvents(vm) // 初始化事件：on,once,off,emit</span><br><span class=\"line\">    initRender(vm) // 初始化渲染：涉及到Virtual DOM</span><br><span class=\"line\">    callHook(vm, &apos;beforeCreate&apos;) //  触发 beforeCreate 生命周期钩子</span><br><span class=\"line\">    initInjections(vm) // 在初始化 data/props 前初始化Injections</span><br><span class=\"line\">    initState(vm) // 初始化状态选项</span><br><span class=\"line\">    initProvide(vm) // 在初始化 data/props 后初始化Provide</span><br><span class=\"line\">    // 有关inject和provide请查阅 https://cn.vuejs.org/v2/api/#provide-inject</span><br><span class=\"line\">    callHook(vm, &apos;created&apos;) // 触发 created 生命周期钩子</span><br><span class=\"line\"></span><br><span class=\"line\">    /* istanbul ignore if */</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class=\"line\">      vm._name = formatComponentName(vm, false)</span><br><span class=\"line\">      mark(endTag)</span><br><span class=\"line\">      measure(`vue $&#123;vm._name&#125; init`, startTag, endTag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 如果Vue配置项中有el，直接挂在到DOM中</span><br><span class=\"line\">    if (vm.$options.el) &#123;</span><br><span class=\"line\">      vm.$mount(vm.$options.el)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>抓住重点，<strong>我们是要来学习State的。</strong>从上面代码中可以找到initState方法的执行，这就是我们此行的目的——State数据选项。除此之外还有其他重要方法的初始化方式，这将会在之后的博客中继续讨论和学习。</p>\n<h1 id=\"学习State\"><a href=\"#学习State\" class=\"headerlink\" title=\"学习State\"></a>学习State</h1><p>之前是简单提一下学习源码的方法论和如何开始学习Vue源码学习。并且找到了我们要学习的State所在，现在进入正题：</p>\n<blockquote>\n<p>了解Vue的数据选项的运行机制。</p>\n</blockquote>\n<p>在<a href=\"http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/\" target=\"_blank\" rel=\"noopener\">Vue2.1.7源码学习</a>中，作者已经非常非常非常清晰明了的帮我们分析了data的实现。在此基础上开始好好学习其他数据选项的实现逻辑。</p>\n<h2 id=\"通过data理解mvvm\"><a href=\"#通过data理解mvvm\" class=\"headerlink\" title=\"通过data理解mvvm\"></a>通过data理解mvvm</h2><p>这里我通过自己的思路再来整理下项目中data的实现。<br><strong>注：</strong>由于这一部分已经被各类源码解析博客讲烂了，而要把这部分讲清楚要大量篇幅。所以我就不贴代码了。还是那句话，抓重点！我们主要研究的是data之外的实现方式。关于data的实现和mvvm的逐步实现，<a href=\"http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/\" target=\"_blank\" rel=\"noopener\">Vue2.1.7源码学习</a>中讲的非常清晰明了。</p>\n<p><strong>以下是我整理的思路，有兴趣的同学可以顺着我的思路去看看。</strong></p>\n<p>在 state.js 中找到 initState，并顺利找到 initData 函数。initData中主要做了以下几步操作：</p>\n<ol>\n<li>获取data数据，data数据通常是一个方法，执行方法返回data数据。所以说我们要将data写成函数方法的形式。</li>\n<li>遍历data数据，判断是否有data与props的key同名，如果没有执行proxy方法，该方法用于将data中的数据同步到vm对象上，所以我们可以通过 <code>vm.name</code> 来修改和获取 data 中的 name 的值。</li>\n<li>执行observe方法，监听data的变化。</li>\n</ol>\n<p>重点在 <code>observe</code> 方法，于是我们根据 import 关系找到 <code>src/core/observer/index.js</code> 文件。<code>observe</code> 方法通过传入的值最终返回一个Observer类的实例对象。<br>找到Observer类，在构造函数中为当前类创建Dep实例，然后判断数据，如果是数组，触发 observeArray 方法，遍历执行 observe 方法；如果是对象，触发walk方法。<br>找到walk方法，方法中遍历了数据对象，为对象每个属性执行 defineReactive 方法。<br><strong>找到 defineReactive 方法，该方法为 mvvm 数据变化检测的核心。</strong>为对象属性添加 set 和 get 方法。重点来了， vue 在 get 方法中执行 <code>dep.depend()</code> 方法，在 set 方法中执行 <code>dep.notify()</code> 方法。这个先不多讲，最后进行联结说明。<br>找到同目录下的 <code>dep.js</code> 文件，文件不长。定义了 Dep 类和<code>pushTarget</code>、<code>popTarget</code> 方法。在 Dep 类中有我们之前提到的 <code>depend</code> 和 <code>notify</code> 方法。看下两个方法的实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">depend () &#123;</span><br><span class=\"line\">  if (Dep.target) &#123;</span><br><span class=\"line\">    Dep.target.addDep(this)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">notify () &#123;</span><br><span class=\"line\">  // stabilize the subscriber list first</span><br><span class=\"line\">  const subs = this.subs.slice()</span><br><span class=\"line\">  for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">    subs[i].update()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 <code>depend</code> 方法中，Dep.target 就是一个 Watcher 实例，它的 <code>addDep</code> 方法最终会调用到 Dep 的 <code>addSubs</code> 方法。subs 是 Watcher 数组。即将当前 watcher 存到 Dep 的 subs 数组中。<br>在 <code>notify</code> 方法中，将 Watcher 数组 subs 遍历，执行他们的 <code>update</code> 方法。<code>update</code> 最终会去执行 <code>watcher</code> 的回调函数。<br>即在 get 方法中将 watcher 添加到 dep，在 set 方法中通过 dep 对 watcher 进行回调函数触发。<br>这里其实已经实现了数据监听，接着我们来看看 Watcher，其实 Watcher 就是Vue中 watch 选项的实现了。说到 watch 选项我们都知道它用来监听数据变化。Watcher 就是实现这个过程的玩意啦~<br>Watcher的构造函数最终调用了 <code>get</code> 方法，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get () &#123;</span><br><span class=\"line\">   pushTarget(this)</span><br><span class=\"line\">   let value</span><br><span class=\"line\">   const vm = this.vm</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">     value = this.getter.call(vm, vm)</span><br><span class=\"line\">   &#125; catch (e) &#123;</span><br><span class=\"line\">     if (this.user) &#123;</span><br><span class=\"line\">       handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class=\"line\">     &#125; else &#123;</span><br><span class=\"line\">       throw e</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125; finally &#123;</span><br><span class=\"line\">     // &quot;touch&quot; every property so they are all tracked as</span><br><span class=\"line\">     // dependencies for deep watching</span><br><span class=\"line\">     if (this.deep) &#123;</span><br><span class=\"line\">       traverse(value)</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     popTarget()</span><br><span class=\"line\">     this.cleanupDeps()</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return value</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>get</code> 方法做了如下几步：</p>\n<ol>\n<li>将当前 Watcher 实例传递给 Dep 的 Dep.target。</li>\n<li>执行 Watcher 所监测的数据的 <code>getter</code> 方法。</li>\n<li>最终，将 <code>Dep.target</code> 恢复到上一个值，并且将当前 Watcher 从 Dep 的 subs 中去除。</li>\n</ol>\n<p>其中要注意的是，在第二步中数据的 <code>getter</code> 方法会执行到 <code>dep.depend()</code> 方法，<code>depend</code> 方法将当前 watcher 加入到 subs 中。至于步骤一和三还不太理解。挖个坑先~<br>这样 watcher 就监测上数据了。那怎么使用呢？当然是数据变化时使用咯。当监测的数据变化时，执行数据 setter 方法，然后执行 dep 的 <code>notify</code> 方法。由于我们之前已经将 watcher 都收集到 dep 的 subs 中，<code>notify</code> 方法遍历执行 watcher 的 <code>update</code> 方法，<code>update</code> 方法最终遍历执行回调函数。</p>\n<ol>\n<li>执行 <code>observe</code> 方法，创建 Observer 执行 <code>walk</code> 为对象数据添加setter 和 getter</li>\n<li>在添加 setter 和 getter 时，创建 Dep，在 getter 方法中执行 <code>dep.depend()</code> 收集 watcher，在 setter 方法中执行 <code>dep.notify()</code> 方法，最终遍历执行 watcher 数组的回调函数。</li>\n<li>Dep 类似于 Watcher 和 Observer 的中间件。</li>\n<li>Watcher 用于监听变化，并执行回调函数。</li>\n<li>当 Watcher 实例创建时，Watcher 实例会将自身传递给 Dep.target</li>\n<li>Watcher 调用监测数据的 <code>getter</code>方法触发 <code>dep.depend()</code></li>\n<li><code>dep.depend()</code>方法将当前 Watcher（Dep.target）传递给Dep的subs（watcher数组）中。</li>\n<li>当被监测的数据内容发生改变时，执行 <code>setter</code> 方法，触发 <code>dep.notify()</code> 方法，遍历 Dep 中的 subs（watcher数组），执行 Watcher 的回调函数。</li>\n</ol>\n<p>嗯……就是这样~之后把挖的坑填上！</p>\n<h2 id=\"watch实现\"><a href=\"#watch实现\" class=\"headerlink\" title=\"watch实现\"></a>watch实现</h2><p>说完了 Data 的监听流程，说说 watch 应该就不难啦~<br>找到 <code>src/core/instance/state.js</code> 的 <code>initWatch</code> 函数，该方法用来遍历 Vue 实例中的 watch 项，最终所有 watch 都会执行 <code>createWatcher</code> 方法。<br>继续看 <code>createWatcher</code> 方法，这个方法也很简单，最终返回 <code>vm.$watch(keyOrFn, handler, options)</code>。我们继续往下找~<br>在 <code>stateMixin</code> 方法中找到了定义 Vue 的 $watch 方法属性。来看看怎么实现的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.prototype.$watch = function (</span><br><span class=\"line\">  expOrFn: string | Function,</span><br><span class=\"line\">  cb: any,</span><br><span class=\"line\">  options?: Object</span><br><span class=\"line\">): Function &#123;</span><br><span class=\"line\">  const vm: Component = this</span><br><span class=\"line\">  if (isPlainObject(cb)) &#123;</span><br><span class=\"line\">    return createWatcher(vm, expOrFn, cb, options)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  options = options || &#123;&#125;</span><br><span class=\"line\">  options.user = true</span><br><span class=\"line\">  const watcher = new Watcher(vm, expOrFn, cb, options)</span><br><span class=\"line\">  if (options.immediate) &#123;</span><br><span class=\"line\">    cb.call(vm, watcher.value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return function unwatchFn () &#123;</span><br><span class=\"line\">    watcher.teardown()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果回调函数 cb 是一个对象，那么返回并执行 <code>createWatcher</code> 函数，最终还是会走到 $watch 方法中。<br>否则，创建一个 Watcher 实例，当这个实例创建后，目标数据有任何变化 watch 选项中都能监听到了。如果是有 immediate 参数，那么立即执行一次Watcher的回调函数。最后返回一个解除监听的方法，执行了 Watcher 的 teardown 方法。<br>那么问题来了，为什么watch选项监听数据的方法中参数是如下写法呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch: &#123;</span><br><span class=\"line\">  a: function(val, oldVal)&#123;</span><br><span class=\"line\">    console.log(val)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以找到 <code>src/core/instance/observer/watcher.js</code> 中找到 <code>run</code> 方法。可以看到 <code>this.cb.call(this.vm, value, oldValue)</code> 这里的 cb 回调函数传递的参数就是 value 和 oldValue。<br>这里说个基础知识，函数使用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call\" target=\"_blank\" rel=\"noopener\"> call 方法</a>执行，第一个参数是方法的this值，之后才是真正的参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">run () &#123;</span><br><span class=\"line\">    if (this.active) &#123;</span><br><span class=\"line\">      const value = this.get()</span><br><span class=\"line\">      if (</span><br><span class=\"line\">        value !== this.value ||</span><br><span class=\"line\">        // Deep watchers and watchers on Object/Arrays should fire even</span><br><span class=\"line\">        // when the value is the same, because the value may</span><br><span class=\"line\">        // have mutated.</span><br><span class=\"line\">        isObject(value) ||</span><br><span class=\"line\">        this.deep</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        // set new value</span><br><span class=\"line\">        const oldValue = this.value</span><br><span class=\"line\">        this.value = value</span><br><span class=\"line\">        if (this.user) &#123;</span><br><span class=\"line\">          try &#123;</span><br><span class=\"line\">            this.cb.call(this.vm, value, oldValue)</span><br><span class=\"line\">          &#125; catch (e) &#123;</span><br><span class=\"line\">            handleError(e, this.vm, `callback for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          this.cb.call(this.vm, value, oldValue)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>小结：watch 选项其实就是为指定数据创建 Watcher 实例，接收回调函数的过程。</strong></p>\n<h2 id=\"props实现\"><a href=\"#props实现\" class=\"headerlink\" title=\"props实现\"></a>props实现</h2><p>接下来我们看看props，官网对props的定义如下：</p>\n<blockquote>\n<p>props 可以是数组或对象，用于接收来自父组件的数据。</p>\n</blockquote>\n<p>找到 <code>initProps</code> 方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function initProps (vm: Component, propsOptions: Object) &#123;</span><br><span class=\"line\">  const propsData = vm.$options.propsData || &#123;&#125;</span><br><span class=\"line\">  const props = vm._props = &#123;&#125;</span><br><span class=\"line\">  // cache prop keys so that future props updates can iterate using Array</span><br><span class=\"line\">  // instead of dynamic object key enumeration.</span><br><span class=\"line\">  const keys = vm.$options._propKeys = []</span><br><span class=\"line\">  const isRoot = !vm.$parent</span><br><span class=\"line\">  // root instance props should be converted</span><br><span class=\"line\">  observerState.shouldConvert = isRoot</span><br><span class=\"line\">  for (const key in propsOptions) &#123;</span><br><span class=\"line\">    keys.push(key)</span><br><span class=\"line\">    const value = validateProp(key, propsOptions, propsData, vm)</span><br><span class=\"line\">    /* istanbul ignore else */</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      const hyphenatedKey = hyphenate(key)</span><br><span class=\"line\">      if (isReservedAttribute(hyphenatedKey) ||</span><br><span class=\"line\">          config.isReservedAttr(hyphenatedKey)) &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          `&quot;$&#123;hyphenatedKey&#125;&quot; is a reserved attribute and cannot be used as component prop.`,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      defineReactive(props, key, value, () =&gt; &#123;</span><br><span class=\"line\">        if (vm.$parent &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class=\"line\">          warn(</span><br><span class=\"line\">            `Avoid mutating a prop directly since the value will be ` +</span><br><span class=\"line\">            `overwritten whenever the parent component re-renders. ` +</span><br><span class=\"line\">            `Instead, use a data or computed property based on the prop&apos;s ` +</span><br><span class=\"line\">            `value. Prop being mutated: &quot;$&#123;key&#125;&quot;`,</span><br><span class=\"line\">            vm</span><br><span class=\"line\">          )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      defineReactive(props, key, value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!(key in vm)) &#123;</span><br><span class=\"line\">      proxy(vm, `_props`, key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  observerState.shouldConvert = true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，props 和 data 类似。在 <code>initProps</code> 中无非做了两步：<code>defineReactive</code> 和 <code>proxy</code>，这两个方法我们在提到 data 的时候讲过了。<code>defineReactive</code> 为数据设置 setter、getter，<code>proxy</code> 方法将 <code>props</code> 中的属性映射到 Vue 实例 vm 上，便于我们可以用 <code>vm.myProps</code> 来获取数据。<br>至此，我有个疑问：data与props有何不同呢？<br>data使用的是observe方法，创建一个Observer对象，Observer对象最终是执行了defineReactive方法。而props是遍历选项属性，执行defineReactive方法。中间可能就多了个Observer对象，那么这个Observer对象的作用到底在哪呢？经过实践props属性改变后界面也会改变。说明mvvm对props也是成立的。<br>另外，data和props有个不同的地方就是props是不建议改变的。详见<a href=\"https://cn.vuejs.org/v2/guide/components.html#单向数据流\" target=\"_blank\" rel=\"noopener\">单向数据流</a><br>小结：逻辑和data类似，都是监听数据。不同之处呢……再研究研究~</p>\n<h2 id=\"computed实现\"><a href=\"#computed实现\" class=\"headerlink\" title=\"computed实现\"></a>computed实现</h2><p>再来说说computed，找到初始化computed方法 <code>src/core/instance/state.js</code> 中的 <code>initComputed</code> 方法，去除非关键代码后看到其实主要有俩个行为，为 computed 属性创建 Watcher，然后执行 <code>defineComputed</code>方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function initComputed (vm: Component, computed: Object) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  for (const key in computed) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    if (!isSSR) &#123;</span><br><span class=\"line\">      watchers[key] = new Watcher(</span><br><span class=\"line\">        vm,</span><br><span class=\"line\">        getter || noop,</span><br><span class=\"line\">        noop,</span><br><span class=\"line\">        computedWatcherOptions</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!(key in vm)) &#123;</span><br><span class=\"line\">      defineComputed(vm, key, userDef)</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>defineComputed 做了两步行为：一是定义 sharedPropertyDefinition 的 getter 和 setter，二是将 sharedPropertyDefinition 的属性传给vm，即 <code>Object.defineProperty(target, key, sharedPropertyDefinition)</code>。自此，我们可以通过 <code>vm.computedValue</code> 来获取计算属性结果了。<br><strong>小结：computed其实也就是一个数据监听行为，与data和props不同之处就是在get函数中需要进行逻辑计算处理。</strong></p>\n<h2 id=\"methods实现\"><a href=\"#methods实现\" class=\"headerlink\" title=\"methods实现\"></a>methods实现</h2><p>继续在 <code>state.js</code> 中看到 <code>initMethods</code> 方法。顾名思义，这是初始化methods的方法。实现很简单，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function initMethods (vm: Component, methods: Object) &#123;</span><br><span class=\"line\">  const props = vm.$options.props</span><br><span class=\"line\">  for (const key in methods) &#123;</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      if (methods[key] == null) &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          `Method &quot;$&#123;key&#125;&quot; has an undefined value in the component definition. ` +</span><br><span class=\"line\">          `Did you reference the function correctly?`,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          `Method &quot;$&#123;key&#125;&quot; has already been defined as a prop.`,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if ((key in vm) &amp;&amp; isReserved(key)) &#123;</span><br><span class=\"line\">        warn(</span><br><span class=\"line\">          `Method &quot;$&#123;key&#125;&quot; conflicts with an existing Vue instance method. ` +</span><br><span class=\"line\">          `Avoid defining component methods that start with _ or $.`</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vm[key] = methods[key] == null ? noop : bind(methods[key], vm)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>重点在最后一句。前面都排除重名和空值错误的，最后将 methods 中的方法传给 vm，方法内容如果为空则方法什么都不做。否则调用 <code>bind</code> 方法执行该函数。<br>找到这个 <code>bind</code> 方法，位置在 <code>src/shared/util.js</code> 中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function bind (fn: Function, ctx: Object): Function &#123;</span><br><span class=\"line\">  function boundFn (a) &#123;</span><br><span class=\"line\">    const l: number = arguments.length</span><br><span class=\"line\">    return l</span><br><span class=\"line\">      ? l &gt; 1</span><br><span class=\"line\">        ? fn.apply(ctx, arguments)</span><br><span class=\"line\">        : fn.call(ctx, a)</span><br><span class=\"line\">      : fn.call(ctx)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // record original fn length</span><br><span class=\"line\">  boundFn._length = fn.length</span><br><span class=\"line\">  return boundFn</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>该方法返回一个执行 <code>methods</code> 中函数的方法（这种方法的执行方式比较快）。<br><strong>小结：将methods的方法用bind函数优化执行过程。然后将methods中的各个方法传给Vue实例对象。</strong></p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>本文纯属个人理解，如有任何问题，请及时指出，不胜感激~<br>最后提出一个看源码的小心得：</p>\n<blockquote>\n<p>我发现……看源码、跟流程，尽量将注意力集中在<strong>方法的执行</strong>和<strong>类的实例化</strong>行为上。对于变量的获取和赋值、测试环境警报提示，简略看下就行，避免逐行阅读代码拉低效率。</p>\n</blockquote>\n<p>至此，Vue中的几个数据选项都学习了一遍了。关键在于理解mvvm的过程。data 理解之后，props、watch、computed 都好理解了。methods 和 mvvm 无关……<br>通过四个早上的时间把文章写出来了~对 Vue 的理解深刻了一些，但是还是能感觉到有很多未知的知识点等着我去发掘。加油吧！今年专注于 Vue 前端学习，把 Vue 给弄懂！</p>\n<h1 id=\"Vue-js学习系列\"><a href=\"#Vue-js学习系列\" class=\"headerlink\" title=\"Vue.js学习系列\"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>\n<p><a href=\"http://www.jianshu.com/p/8013d8d37bd0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/d6f7e11f18af\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/8e5fb763c3d7\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href=\"http://www.jianshu.com/p/aef34acd111f\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href=\"http://www.jianshu.com/p/efb6fbed6fac\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href=\"http://www.jianshu.com/p/073d25a3bba0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href=\"https://www.jianshu.com/p/ba7466d7101a\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href=\"https://www.jianshu.com/p/15028f91226e\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>\n<h1 id=\"Vue-js学习系列项目地址\"><a href=\"#Vue-js学习系列项目地址\" class=\"headerlink\" title=\"Vue.js学习系列项目地址\"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack/VueStudyDemos</a></p>\n<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>\n<p>新浪微博： <a href=\"http://weibo.com/u/2640909603\" target=\"_blank\" rel=\"noopener\">http://weibo.com/u/2640909603</a><br>掘金：<a href=\"https://gold.xitu.io/user/571d953d39b0570068145cd1\" target=\"_blank\" rel=\"noopener\">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href=\"http://blog.csdn.net/violetjack0808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/violetjack0808</a><br>简书： <a href=\"http://www.jianshu.com/users/54ae4af3a98d/latest_articles\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href=\"https://github.com/violetjack\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack</a></p>\n"},{"title":"Vue.js学习系列六——Vue单元测试Karma+Mocha学习笔记","date":"2017-06-05T16:00:00.000Z","_content":"\n> 在使用vue-cli创建项目的时候，会提示要不要安装单元测试和e2e测试。既然官方推荐我们使用这两个测试框架，那么我们就动手去学习实践一下他们吧。\n\n# 简介\n### Karma\n**Karma**是一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。该工具在Vue中的主要作用是将项目运行在各种主流Web浏览器进行测试。\n换句话说，它是一个测试工具，能让你的代码在浏览器环境下测试。需要它的原因在于，你的代码可能是设计在浏览器端执行的，在node环境下测试可能有些bug暴露不出来；另外，浏览器有兼容问题，karma提供了手段让你的代码自动在多个浏览器（chrome，firefox，ie等）环境下运行。如果你的代码只会运行在node端，那么你不需要用karma。\n\n### Mocha\n**Mocha**是一个测试框架，在vue-cli中配合**chai断言库**实现单元测试。\nMocha的常用命令和用法不算太多，看阮一峰老师的[测试框架 Mocha 实例教程](http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html)就可以大致了解了。\n而Chai断言库可以看[Chai.js断言库API中文文档](http://www.jianshu.com/p/f200a75a15d2)，很简单，多查多用就能很快掌握。\n\n# 我对测试框架的理解\n### npm run unit 执行过程 \n\n1. 执行 `npm run unit` 命令\n2. 开启Karma运行环境\n3. 使用Mocha去逐个测试用Chai断言写的测试用例\n4. 在终端显示测试结果\n5. 如果测试成功，karma-coverage 会在 `./test/unit/coverage` 文件夹中生成测试覆盖率结果的网页。\n\n### Karma\n对于Karma，我只是了解了一下它的[配置选项](http://karma-runner.github.io/1.0/config/configuration-file.html)。\n下面是Vue的karma配置，简单注释了下：\n```\nvar webpackConfig = require('../../build/webpack.test.conf')\n\nmodule.exports = function (config) {\n  config.set({\n    // 浏览器\n    browsers: ['PhantomJS'],\n    // 测试框架\n    frameworks: ['mocha', 'sinon-chai', 'phantomjs-shim'],\n    // 测试报告\n    reporters: ['spec', 'coverage'],\n    // 测试入口文件\n    files: ['./index.js'],\n    // 预处理器 karma-webpack\n    preprocessors: {\n      './index.js': ['webpack', 'sourcemap']\n    },\n    // Webpack配置\n    webpack: webpackConfig,\n    // Webpack中间件\n    webpackMiddleware: {\n      noInfo: true\n    },\n    // 测试覆盖率报告\n    // https://github.com/karma-runner/karma-coverage/blob/master/docs/configuration.md\n    coverageReporter: {\n      dir: './coverage',\n      reporters: [\n        { type: 'lcov', subdir: '.' },\n        { type: 'text-summary' }\n      ]\n    }\n  })\n}\n\n```\n### Mocha和chai\n我们看下官方的例子（都用注释来解释代码意思了）：\n```\nimport Vue from 'vue' // 导入Vue用于生成Vue实例\nimport Hello from '@/components/Hello' // 导入组件\n// 测试脚本里面应该包括一个或多个describe块，称为测试套件（test suite）\ndescribe('Hello.vue', () => {\n  // 每个describe块应该包括一个或多个it块，称为测试用例（test case）\n  it('should render correct contents', () => {\n    const Constructor = Vue.extend(Hello) // 获得Hello组件实例\n    const vm = new Constructor().$mount() // 将组件挂在到DOM上\n    //断言：DOM中class为hello的元素中的h1元素的文本内容为Welcome to Your Vue.js App\n    expect(vm.$el.querySelector('.hello h1').textContent)\n      .to.equal('Welcome to Your Vue.js App')  \n  })\n})\n\n```\n**需要知道的知识点：**\n* 测试脚本都要放在 `test/unit/specs/` 目录下。\n* 脚本命名方式为  `[组件名].spec.js`。\n* 所谓断言，就是对组件做一些操作，并预言产生的结果。如果测试结果与断言相同则测试通过。\n* 单元测试默认测试 `src` 目录下除了 `main.js` 之外的所有文件，可在 `test/unit/index.js` 文件中修改。\n* Chai断言库中，`to be been is that which and has have with at of same` 这些语言链是没有意义的，只是便于理解而已。\n* 测试脚本由多个  `descibe` 组成，每个 `describe` 由多个 `it` 组成。\n* 了解异步测试\n```\nit('异步请求应该返回一个对象', done => {\n    request\n    .get('https://api.github.com')\n    .end(function(err, res){\n      expect(res).to.be.an('object');\n      done();\n    });\n});\n```\n* 了解一下 `describe` 的钩子（生命周期）\n```\ndescribe('hooks', function() {\n\n  before(function() {\n    // 在本区块的所有测试用例之前执行\n  });\n\n  after(function() {\n    // 在本区块的所有测试用例之后执行\n  });\n\n  beforeEach(function() {\n    // 在本区块的每个测试用例之前执行\n  });\n\n  afterEach(function() {\n    // 在本区块的每个测试用例之后执行\n  });\n\n  // test cases\n});\n```\n\n# 实践\n上面简单介绍了单元测试的用法，下面来动手在Vue中进行单元测试！\n### util.js\n从Vue官方的demo可以看出，对于Vue的单元测试我们需要将组件实例化为一个Vue实例，有时还需要挂载到DOM上。\n```\n const Constructor = Vue.extend(Hello) // 获得Hello组件实例\n const vm = new Constructor().$mount() // 将组件挂载到DOM上\n```\n以上写法只是简单的获取组件，有时候我们需要传递props属性、自定义方法等，还有可能我们需要用到第三方UI框架。所以以上写法非常麻烦。\n这里推荐Element的[单元测试工具脚本Util.js](https://github.com/ElemeFE/element/blob/dev/test/unit/util.js)，它封装了Vue单元测试中常用的方法。下面demo也是根据该 `Util.js`来写的。\n这里简单注释了下各方法的用途。\n```\n/**\n * 回收 vm，一般在每个测试脚本测试完成后执行回收vm。\n * @param  {Object} vm\n */\nexports.destroyVM = function (vm) {}\n\n/**\n * 创建一个 Vue 的实例对象\n * @param  {Object|String}  Compo     - 组件配置，可直接传 template\n * @param  {Boolean=false}  mounted   - 是否添加到 DOM 上\n * @return {Object} vm\n */\nexports.createVue = function (Compo, mounted = false) {}\n\n/**\n * 创建一个测试组件实例\n * @param  {Object}  Compo          - 组件对象\n * @param  {Object}  propsData      - props 数据\n * @param  {Boolean=false} mounted  - 是否添加到 DOM 上\n * @return {Object} vm\n */\nexports.createTest = function (Compo, propsData = {}, mounted = false) {}\n\n/**\n * 触发一个事件\n * 注： 一般在触发事件后使用 vm.$nextTick 方法确定事件触发完成。\n * mouseenter, mouseleave, mouseover, keyup, change, click 等\n * @param  {Element} elm      - 元素\n * @param  {String} name      - 事件名称\n * @param  {*} opts           - 配置项\n */\nexports.triggerEvent = function (elm, name, ...opts) {}\n\n/**\n * 触发 “mouseup” 和 “mousedown” 事件，既触发点击事件。\n * @param {Element} elm     - 元素\n * @param {*} opts          - 配置选项\n */\nexports.triggerClick = function (elm, ...opts) {}\n```\n### 示例一\n示例一中我们测试了 `Hello` 组件的各种元素的数据，学习  `util.js` 的 `destroyVM` 和 `createTest` 方法的用法以及如何获取目标元素进行测试。获取DOM元素的方式可查看[DOM 对象](http://www.runoob.com/jsref/dom-obj-document.html)教程。\n**Hello.vue**\n```\n<template>\n  <div class=\"hello\">\n    <h1 class=\"hello-title\">{{ msg }}</h1>\n    <h2 class=\"hello-content\">{{ content }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'hello',\n  props: {\n    content: String\n  },\n  data () {\n    return {\n      msg: 'Welcome!'\n    }\n  }\n}\n</script>\n```\n**Hello.spec.js**\n```\nimport { destroyVM, createTest } from '../util'\nimport Hello from '@/components/Hello'\n\ndescribe('Hello.vue', () => {\n  let vm\n\n  afterEach(() => {\n    destroyVM(vm)\n  })\n\n  it('测试获取元素内容', () => {\n    vm = createTest(Hello, { content: 'Hello World' }, true)\n    expect(vm.$el.querySelector('.hello h1').textContent).to.equal('Welcome!')\n    expect(vm.$el.querySelector('.hello h2').textContent).to.have.be.equal('Hello World')\n  })\n\n  it('测试获取Vue对象中数据', () => {\n    vm = createTest(Hello, { content: 'Hello World' }, true)\n    expect(vm.msg).to.equal('Welcome!')\n    // Chai的语言链是无意义的，可以随便写。如下：\n    expect(vm.content).which.have.to.be.that.equal('Hello World') \n  })\n\n  it('测试获取DOM中是否存在某个class', () => {\n    vm = createTest(Hello, { content: 'Hello World' }, true)\n    expect(vm.$el.classList.contains('hello')).to.be.true\n    const title = vm.$el.querySelector('.hello h1')\n    expect(title.classList.contains('hello-title')).to.be.true\n    const content = vm.$el.querySelector('.hello-content')\n    expect(content.classList.contains('hello-content')).to.be.true\n  })\n})\n```\n**输出结果**\n```\nHello.vue\n  √ 测试获取元素内容\n  √ 测试获取Vue对象中数据\n  √ 测试获取DOM中是否存在某个class\n```\n### 示例二\n示例二中我们使用 `createTest` 创建测试组件测试点击事件，用 `createVue` 创建Vue示例对象测试组件 `Click` 的使用。这里主要可以看下到 `createVue` 方法的使用。\n**Click.vue**\n```\n<template>\n  <div>\n    <span class=\"init-num\">初始值为{{ InitNum }}</span><br>\n    <span class=\"click-num\">点击了{{ ClickNum }}次</span><br>\n    <span class=\"result-num\">最终结果为{{ ResultNum }}</span><br>\n    <button @click=\"add\">累加{{ AddNum }}</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'Click',\n  props: {\n    AddNum: {\n      type: Number,\n      default: 1\n    },\n    InitNum: {\n      type: Number,\n      default: 1\n    }\n  },\n  data () {\n    return {\n      ClickNum: 0,\n      ResultNum: 0\n    }\n  },\n  mounted () {\n    this.ResultNum = this.InitNum\n  },\n  methods: {\n    add () {\n      this.ResultNum += this.AddNum\n      this.ClickNum++\n      this.$emit('result', {\n        ClickNum: this.ClickNum,\n        ResultNum: this.ResultNum\n      })\n    }\n  }\n}\n</script>\n\n```\n**Click.spec.js**\n```\nimport { destroyVM, createTest, createVue } from '../util'\nimport Click from '@/components/Click'\n\ndescribe('click.vue', () => {\n  let vm\n\n  afterEach(() => {\n    destroyVM(vm)\n  })\n\n  it('测试按钮点击事件', () => {\n    vm = createTest(Click, {\n      AddNum: 10,\n      InitNum: 11\n    }, true)\n    let buttonElm = vm.$el.querySelector('button')\n    buttonElm.click()\n    buttonElm.click()\n    buttonElm.click()\n    // setTimeout 的原因\n    // 在数据改变之后，界面的变化会有一定延时。不用timeout有时候会发现界面没有变化\n    setTimeout(done => {\n      expect(vm.ResultNum).to.equal(41)\n      expect(vm.$el.querySelector('.init-num').textContent).to.equal('初始值为11')\n      expect(vm.$el.querySelector('.click-num').textContent).to.equal('点击了3次')\n      expect(vm.$el.querySelector('.result-num').textContent).to.equal('最终结果为41')\n      done()\n    }, 100)\n  })\n\n  it('测试创建Vue对象', () => {\n    let result\n    vm = createVue({\n      template: `\n        <click @click=\"handleClick\"></click>\n      `,\n      props: {\n        AddNum: 10,\n        InitNum: 11\n      },\n      methods: {\n        handleClick (obj) {\n          result = obj\n        }\n      },\n      components: {\n        Click\n      }\n    }, true)\n    vm.$el.click()\n    vm.$nextTick(done => {\n      expect(result).to.be.exist\n      expect(result.ClickNum).to.equal(1)\n      expect(result.ResultNum).to.be.equal(21)\n      done()\n    })\n})\n```\n**输出结果**\n```\nclick.vue\n  √ 测试按钮点击事件\n  √ 测试创建Vue对象\n```\n### 其他\n所有示例代码都放[Github仓库](https://github.com/violetjack/VueStudyDemos/tree/master/VueTestDemo)中便于查看。如果想查看更多好的测试用例，建议配合 `Util.js` 看一下 [Element 的单元测试脚本的写法](https://github.com/ElemeFE/element/tree/dev/test/unit)，里面有很多测试脚本可以供我们学习。作为被广大Vue用户使用的UI组件库，测试脚本肯定也写很很不错的~甚至可以将这些脚本照抄一遍，相信这会对学习Vue组件的单元测试有很大帮助。\n\n下面是本人看Element单元测试的笔记，供参考。\n\n* Util.js 方法包含了大多数Vue组件化的测试需求。\n* `vm.$el` `vm.$nextTick` 和 `vm.$ref` 都是在测试过程中比较常用的一些Vue语法糖。\n* 需要注意： vm.$nextTick 方法是异步的，所以需要在里面使用done方法。\n* 异步断言，方法参数需要是 `_` 或者 `done`\n* 大多数时候查询元素通过 `querySelector` 方法查询class获得\n  * vm.$el.querySelector('.el-breadcrumb').innerText\n* 大多数情况下查询是否存在某个Class通过 `classList.contains` 方法获得，查找的结果为 true 或 false\n  * vm.$el .classList.contains('el-button--primary')\n* 异步测试必须以 `done()` 方法结尾。`setTimeout` 和 `vm.$nextTick` 是常用的异步测试。\n* 实现按钮点击：通过获取按钮元素 `btn`，执行 `btn.click()` 方法实现。\n*  由于 Vue 进行 [异步更新DOM](http://cn.vuejs.org/v2/guide/reactivity.html#Async-Update-Queue) 的情况，一些依赖DOM更新结果的断言必须在 `Vue.nextTick` 回调中进行。\n```\ntriggerEvent(vm.$refs.cascader.$el, 'mouseenter');\nvm.$nextTick(_ => {\n     vm.$refs.cascader.$el.querySelector('.el-cascader__clearIcon').click();\n     vm.$nextTick(_ => {\n        expect(vm.selectedOptions.length).to.be.equal(0);\n        done();\n     });\n});\n```\n\n# 参考资料\n* [单元测试](http://cn.vuejs.org/v2/guide/unit-testing.html)\n* [Chai.js断言库API中文文档](http://www.jianshu.com/p/f200a75a15d2)\n* [Element](https://github.com/ElemeFE/element/tree/dev/test/unit)\n* [前端单元测试之Karma环境搭建](https://segmentfault.com/a/1190000006895064)\n* [前端自动化测试是干嘛的？](https://segmentfault.com/q/1010000009527765)\n* [测试框架 Mocha 实例教程](http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html)\n* [Karma官网](http://karma-runner.github.io/1.0/index.html)\n\n# Vue.js学习系列\n鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。\n\n[Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）](http://www.jianshu.com/p/8013d8d37bd0)\n[Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）](http://www.jianshu.com/p/d6f7e11f18af)\n[Vue.js学习系列三 —— axios和网络传输相关知识的学习实践](http://www.jianshu.com/p/8e5fb763c3d7)\n[Vue.js学习系列四 —— Webpack打包工具的使用](http://www.jianshu.com/p/aef34acd111f)\n[Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint](http://www.jianshu.com/p/efb6fbed6fac)\n[Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记](http://www.jianshu.com/p/073d25a3bba0)\n[Vue.js学习系列七 —— Vue服务器渲染Nuxt学习](https://www.jianshu.com/p/ba7466d7101a)\n[Vue.js学习系列八 —— Vue源码学习之State学习](https://www.jianshu.com/p/15028f91226e)\n\n# Vue.js学习系列项目地址\n本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。\n[https://github.com/violetjack/VueStudyDemos](https://github.com/violetjack/VueStudyDemos)\n\n# 关于作者\nVioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。\n欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。\n\n新浪微博： http://weibo.com/u/2640909603\n掘金：https://gold.xitu.io/user/571d953d39b0570068145cd1\nCSDN: http://blog.csdn.net/violetjack0808\n简书： http://www.jianshu.com/users/54ae4af3a98d/latest_articles\nGithub： https://github.com/violetjack","source":"_posts/Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记.md","raw":"---\ntitle: Vue.js学习系列六——Vue单元测试Karma+Mocha学习笔记\ndate: 2017-06-06\n---\n\n> 在使用vue-cli创建项目的时候，会提示要不要安装单元测试和e2e测试。既然官方推荐我们使用这两个测试框架，那么我们就动手去学习实践一下他们吧。\n\n# 简介\n### Karma\n**Karma**是一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。该工具在Vue中的主要作用是将项目运行在各种主流Web浏览器进行测试。\n换句话说，它是一个测试工具，能让你的代码在浏览器环境下测试。需要它的原因在于，你的代码可能是设计在浏览器端执行的，在node环境下测试可能有些bug暴露不出来；另外，浏览器有兼容问题，karma提供了手段让你的代码自动在多个浏览器（chrome，firefox，ie等）环境下运行。如果你的代码只会运行在node端，那么你不需要用karma。\n\n### Mocha\n**Mocha**是一个测试框架，在vue-cli中配合**chai断言库**实现单元测试。\nMocha的常用命令和用法不算太多，看阮一峰老师的[测试框架 Mocha 实例教程](http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html)就可以大致了解了。\n而Chai断言库可以看[Chai.js断言库API中文文档](http://www.jianshu.com/p/f200a75a15d2)，很简单，多查多用就能很快掌握。\n\n# 我对测试框架的理解\n### npm run unit 执行过程 \n\n1. 执行 `npm run unit` 命令\n2. 开启Karma运行环境\n3. 使用Mocha去逐个测试用Chai断言写的测试用例\n4. 在终端显示测试结果\n5. 如果测试成功，karma-coverage 会在 `./test/unit/coverage` 文件夹中生成测试覆盖率结果的网页。\n\n### Karma\n对于Karma，我只是了解了一下它的[配置选项](http://karma-runner.github.io/1.0/config/configuration-file.html)。\n下面是Vue的karma配置，简单注释了下：\n```\nvar webpackConfig = require('../../build/webpack.test.conf')\n\nmodule.exports = function (config) {\n  config.set({\n    // 浏览器\n    browsers: ['PhantomJS'],\n    // 测试框架\n    frameworks: ['mocha', 'sinon-chai', 'phantomjs-shim'],\n    // 测试报告\n    reporters: ['spec', 'coverage'],\n    // 测试入口文件\n    files: ['./index.js'],\n    // 预处理器 karma-webpack\n    preprocessors: {\n      './index.js': ['webpack', 'sourcemap']\n    },\n    // Webpack配置\n    webpack: webpackConfig,\n    // Webpack中间件\n    webpackMiddleware: {\n      noInfo: true\n    },\n    // 测试覆盖率报告\n    // https://github.com/karma-runner/karma-coverage/blob/master/docs/configuration.md\n    coverageReporter: {\n      dir: './coverage',\n      reporters: [\n        { type: 'lcov', subdir: '.' },\n        { type: 'text-summary' }\n      ]\n    }\n  })\n}\n\n```\n### Mocha和chai\n我们看下官方的例子（都用注释来解释代码意思了）：\n```\nimport Vue from 'vue' // 导入Vue用于生成Vue实例\nimport Hello from '@/components/Hello' // 导入组件\n// 测试脚本里面应该包括一个或多个describe块，称为测试套件（test suite）\ndescribe('Hello.vue', () => {\n  // 每个describe块应该包括一个或多个it块，称为测试用例（test case）\n  it('should render correct contents', () => {\n    const Constructor = Vue.extend(Hello) // 获得Hello组件实例\n    const vm = new Constructor().$mount() // 将组件挂在到DOM上\n    //断言：DOM中class为hello的元素中的h1元素的文本内容为Welcome to Your Vue.js App\n    expect(vm.$el.querySelector('.hello h1').textContent)\n      .to.equal('Welcome to Your Vue.js App')  \n  })\n})\n\n```\n**需要知道的知识点：**\n* 测试脚本都要放在 `test/unit/specs/` 目录下。\n* 脚本命名方式为  `[组件名].spec.js`。\n* 所谓断言，就是对组件做一些操作，并预言产生的结果。如果测试结果与断言相同则测试通过。\n* 单元测试默认测试 `src` 目录下除了 `main.js` 之外的所有文件，可在 `test/unit/index.js` 文件中修改。\n* Chai断言库中，`to be been is that which and has have with at of same` 这些语言链是没有意义的，只是便于理解而已。\n* 测试脚本由多个  `descibe` 组成，每个 `describe` 由多个 `it` 组成。\n* 了解异步测试\n```\nit('异步请求应该返回一个对象', done => {\n    request\n    .get('https://api.github.com')\n    .end(function(err, res){\n      expect(res).to.be.an('object');\n      done();\n    });\n});\n```\n* 了解一下 `describe` 的钩子（生命周期）\n```\ndescribe('hooks', function() {\n\n  before(function() {\n    // 在本区块的所有测试用例之前执行\n  });\n\n  after(function() {\n    // 在本区块的所有测试用例之后执行\n  });\n\n  beforeEach(function() {\n    // 在本区块的每个测试用例之前执行\n  });\n\n  afterEach(function() {\n    // 在本区块的每个测试用例之后执行\n  });\n\n  // test cases\n});\n```\n\n# 实践\n上面简单介绍了单元测试的用法，下面来动手在Vue中进行单元测试！\n### util.js\n从Vue官方的demo可以看出，对于Vue的单元测试我们需要将组件实例化为一个Vue实例，有时还需要挂载到DOM上。\n```\n const Constructor = Vue.extend(Hello) // 获得Hello组件实例\n const vm = new Constructor().$mount() // 将组件挂载到DOM上\n```\n以上写法只是简单的获取组件，有时候我们需要传递props属性、自定义方法等，还有可能我们需要用到第三方UI框架。所以以上写法非常麻烦。\n这里推荐Element的[单元测试工具脚本Util.js](https://github.com/ElemeFE/element/blob/dev/test/unit/util.js)，它封装了Vue单元测试中常用的方法。下面demo也是根据该 `Util.js`来写的。\n这里简单注释了下各方法的用途。\n```\n/**\n * 回收 vm，一般在每个测试脚本测试完成后执行回收vm。\n * @param  {Object} vm\n */\nexports.destroyVM = function (vm) {}\n\n/**\n * 创建一个 Vue 的实例对象\n * @param  {Object|String}  Compo     - 组件配置，可直接传 template\n * @param  {Boolean=false}  mounted   - 是否添加到 DOM 上\n * @return {Object} vm\n */\nexports.createVue = function (Compo, mounted = false) {}\n\n/**\n * 创建一个测试组件实例\n * @param  {Object}  Compo          - 组件对象\n * @param  {Object}  propsData      - props 数据\n * @param  {Boolean=false} mounted  - 是否添加到 DOM 上\n * @return {Object} vm\n */\nexports.createTest = function (Compo, propsData = {}, mounted = false) {}\n\n/**\n * 触发一个事件\n * 注： 一般在触发事件后使用 vm.$nextTick 方法确定事件触发完成。\n * mouseenter, mouseleave, mouseover, keyup, change, click 等\n * @param  {Element} elm      - 元素\n * @param  {String} name      - 事件名称\n * @param  {*} opts           - 配置项\n */\nexports.triggerEvent = function (elm, name, ...opts) {}\n\n/**\n * 触发 “mouseup” 和 “mousedown” 事件，既触发点击事件。\n * @param {Element} elm     - 元素\n * @param {*} opts          - 配置选项\n */\nexports.triggerClick = function (elm, ...opts) {}\n```\n### 示例一\n示例一中我们测试了 `Hello` 组件的各种元素的数据，学习  `util.js` 的 `destroyVM` 和 `createTest` 方法的用法以及如何获取目标元素进行测试。获取DOM元素的方式可查看[DOM 对象](http://www.runoob.com/jsref/dom-obj-document.html)教程。\n**Hello.vue**\n```\n<template>\n  <div class=\"hello\">\n    <h1 class=\"hello-title\">{{ msg }}</h1>\n    <h2 class=\"hello-content\">{{ content }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'hello',\n  props: {\n    content: String\n  },\n  data () {\n    return {\n      msg: 'Welcome!'\n    }\n  }\n}\n</script>\n```\n**Hello.spec.js**\n```\nimport { destroyVM, createTest } from '../util'\nimport Hello from '@/components/Hello'\n\ndescribe('Hello.vue', () => {\n  let vm\n\n  afterEach(() => {\n    destroyVM(vm)\n  })\n\n  it('测试获取元素内容', () => {\n    vm = createTest(Hello, { content: 'Hello World' }, true)\n    expect(vm.$el.querySelector('.hello h1').textContent).to.equal('Welcome!')\n    expect(vm.$el.querySelector('.hello h2').textContent).to.have.be.equal('Hello World')\n  })\n\n  it('测试获取Vue对象中数据', () => {\n    vm = createTest(Hello, { content: 'Hello World' }, true)\n    expect(vm.msg).to.equal('Welcome!')\n    // Chai的语言链是无意义的，可以随便写。如下：\n    expect(vm.content).which.have.to.be.that.equal('Hello World') \n  })\n\n  it('测试获取DOM中是否存在某个class', () => {\n    vm = createTest(Hello, { content: 'Hello World' }, true)\n    expect(vm.$el.classList.contains('hello')).to.be.true\n    const title = vm.$el.querySelector('.hello h1')\n    expect(title.classList.contains('hello-title')).to.be.true\n    const content = vm.$el.querySelector('.hello-content')\n    expect(content.classList.contains('hello-content')).to.be.true\n  })\n})\n```\n**输出结果**\n```\nHello.vue\n  √ 测试获取元素内容\n  √ 测试获取Vue对象中数据\n  √ 测试获取DOM中是否存在某个class\n```\n### 示例二\n示例二中我们使用 `createTest` 创建测试组件测试点击事件，用 `createVue` 创建Vue示例对象测试组件 `Click` 的使用。这里主要可以看下到 `createVue` 方法的使用。\n**Click.vue**\n```\n<template>\n  <div>\n    <span class=\"init-num\">初始值为{{ InitNum }}</span><br>\n    <span class=\"click-num\">点击了{{ ClickNum }}次</span><br>\n    <span class=\"result-num\">最终结果为{{ ResultNum }}</span><br>\n    <button @click=\"add\">累加{{ AddNum }}</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'Click',\n  props: {\n    AddNum: {\n      type: Number,\n      default: 1\n    },\n    InitNum: {\n      type: Number,\n      default: 1\n    }\n  },\n  data () {\n    return {\n      ClickNum: 0,\n      ResultNum: 0\n    }\n  },\n  mounted () {\n    this.ResultNum = this.InitNum\n  },\n  methods: {\n    add () {\n      this.ResultNum += this.AddNum\n      this.ClickNum++\n      this.$emit('result', {\n        ClickNum: this.ClickNum,\n        ResultNum: this.ResultNum\n      })\n    }\n  }\n}\n</script>\n\n```\n**Click.spec.js**\n```\nimport { destroyVM, createTest, createVue } from '../util'\nimport Click from '@/components/Click'\n\ndescribe('click.vue', () => {\n  let vm\n\n  afterEach(() => {\n    destroyVM(vm)\n  })\n\n  it('测试按钮点击事件', () => {\n    vm = createTest(Click, {\n      AddNum: 10,\n      InitNum: 11\n    }, true)\n    let buttonElm = vm.$el.querySelector('button')\n    buttonElm.click()\n    buttonElm.click()\n    buttonElm.click()\n    // setTimeout 的原因\n    // 在数据改变之后，界面的变化会有一定延时。不用timeout有时候会发现界面没有变化\n    setTimeout(done => {\n      expect(vm.ResultNum).to.equal(41)\n      expect(vm.$el.querySelector('.init-num').textContent).to.equal('初始值为11')\n      expect(vm.$el.querySelector('.click-num').textContent).to.equal('点击了3次')\n      expect(vm.$el.querySelector('.result-num').textContent).to.equal('最终结果为41')\n      done()\n    }, 100)\n  })\n\n  it('测试创建Vue对象', () => {\n    let result\n    vm = createVue({\n      template: `\n        <click @click=\"handleClick\"></click>\n      `,\n      props: {\n        AddNum: 10,\n        InitNum: 11\n      },\n      methods: {\n        handleClick (obj) {\n          result = obj\n        }\n      },\n      components: {\n        Click\n      }\n    }, true)\n    vm.$el.click()\n    vm.$nextTick(done => {\n      expect(result).to.be.exist\n      expect(result.ClickNum).to.equal(1)\n      expect(result.ResultNum).to.be.equal(21)\n      done()\n    })\n})\n```\n**输出结果**\n```\nclick.vue\n  √ 测试按钮点击事件\n  √ 测试创建Vue对象\n```\n### 其他\n所有示例代码都放[Github仓库](https://github.com/violetjack/VueStudyDemos/tree/master/VueTestDemo)中便于查看。如果想查看更多好的测试用例，建议配合 `Util.js` 看一下 [Element 的单元测试脚本的写法](https://github.com/ElemeFE/element/tree/dev/test/unit)，里面有很多测试脚本可以供我们学习。作为被广大Vue用户使用的UI组件库，测试脚本肯定也写很很不错的~甚至可以将这些脚本照抄一遍，相信这会对学习Vue组件的单元测试有很大帮助。\n\n下面是本人看Element单元测试的笔记，供参考。\n\n* Util.js 方法包含了大多数Vue组件化的测试需求。\n* `vm.$el` `vm.$nextTick` 和 `vm.$ref` 都是在测试过程中比较常用的一些Vue语法糖。\n* 需要注意： vm.$nextTick 方法是异步的，所以需要在里面使用done方法。\n* 异步断言，方法参数需要是 `_` 或者 `done`\n* 大多数时候查询元素通过 `querySelector` 方法查询class获得\n  * vm.$el.querySelector('.el-breadcrumb').innerText\n* 大多数情况下查询是否存在某个Class通过 `classList.contains` 方法获得，查找的结果为 true 或 false\n  * vm.$el .classList.contains('el-button--primary')\n* 异步测试必须以 `done()` 方法结尾。`setTimeout` 和 `vm.$nextTick` 是常用的异步测试。\n* 实现按钮点击：通过获取按钮元素 `btn`，执行 `btn.click()` 方法实现。\n*  由于 Vue 进行 [异步更新DOM](http://cn.vuejs.org/v2/guide/reactivity.html#Async-Update-Queue) 的情况，一些依赖DOM更新结果的断言必须在 `Vue.nextTick` 回调中进行。\n```\ntriggerEvent(vm.$refs.cascader.$el, 'mouseenter');\nvm.$nextTick(_ => {\n     vm.$refs.cascader.$el.querySelector('.el-cascader__clearIcon').click();\n     vm.$nextTick(_ => {\n        expect(vm.selectedOptions.length).to.be.equal(0);\n        done();\n     });\n});\n```\n\n# 参考资料\n* [单元测试](http://cn.vuejs.org/v2/guide/unit-testing.html)\n* [Chai.js断言库API中文文档](http://www.jianshu.com/p/f200a75a15d2)\n* [Element](https://github.com/ElemeFE/element/tree/dev/test/unit)\n* [前端单元测试之Karma环境搭建](https://segmentfault.com/a/1190000006895064)\n* [前端自动化测试是干嘛的？](https://segmentfault.com/q/1010000009527765)\n* [测试框架 Mocha 实例教程](http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html)\n* [Karma官网](http://karma-runner.github.io/1.0/index.html)\n\n# Vue.js学习系列\n鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。\n\n[Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）](http://www.jianshu.com/p/8013d8d37bd0)\n[Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）](http://www.jianshu.com/p/d6f7e11f18af)\n[Vue.js学习系列三 —— axios和网络传输相关知识的学习实践](http://www.jianshu.com/p/8e5fb763c3d7)\n[Vue.js学习系列四 —— Webpack打包工具的使用](http://www.jianshu.com/p/aef34acd111f)\n[Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint](http://www.jianshu.com/p/efb6fbed6fac)\n[Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记](http://www.jianshu.com/p/073d25a3bba0)\n[Vue.js学习系列七 —— Vue服务器渲染Nuxt学习](https://www.jianshu.com/p/ba7466d7101a)\n[Vue.js学习系列八 —— Vue源码学习之State学习](https://www.jianshu.com/p/15028f91226e)\n\n# Vue.js学习系列项目地址\n本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。\n[https://github.com/violetjack/VueStudyDemos](https://github.com/violetjack/VueStudyDemos)\n\n# 关于作者\nVioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。\n欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。\n\n新浪微博： http://weibo.com/u/2640909603\n掘金：https://gold.xitu.io/user/571d953d39b0570068145cd1\nCSDN: http://blog.csdn.net/violetjack0808\n简书： http://www.jianshu.com/users/54ae4af3a98d/latest_articles\nGithub： https://github.com/violetjack","slug":"Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记","published":1,"updated":"2018-02-07T02:29:31.765Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjddwxbm90009i8bt2r3m83n5","content":"<blockquote>\n<p>在使用vue-cli创建项目的时候，会提示要不要安装单元测试和e2e测试。既然官方推荐我们使用这两个测试框架，那么我们就动手去学习实践一下他们吧。</p>\n</blockquote>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><h3 id=\"Karma\"><a href=\"#Karma\" class=\"headerlink\" title=\"Karma\"></a>Karma</h3><p><strong>Karma</strong>是一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。该工具在Vue中的主要作用是将项目运行在各种主流Web浏览器进行测试。<br>换句话说，它是一个测试工具，能让你的代码在浏览器环境下测试。需要它的原因在于，你的代码可能是设计在浏览器端执行的，在node环境下测试可能有些bug暴露不出来；另外，浏览器有兼容问题，karma提供了手段让你的代码自动在多个浏览器（chrome，firefox，ie等）环境下运行。如果你的代码只会运行在node端，那么你不需要用karma。</p>\n<h3 id=\"Mocha\"><a href=\"#Mocha\" class=\"headerlink\" title=\"Mocha\"></a>Mocha</h3><p><strong>Mocha</strong>是一个测试框架，在vue-cli中配合<strong>chai断言库</strong>实现单元测试。<br>Mocha的常用命令和用法不算太多，看阮一峰老师的<a href=\"http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html\" target=\"_blank\" rel=\"noopener\">测试框架 Mocha 实例教程</a>就可以大致了解了。<br>而Chai断言库可以看<a href=\"http://www.jianshu.com/p/f200a75a15d2\" target=\"_blank\" rel=\"noopener\">Chai.js断言库API中文文档</a>，很简单，多查多用就能很快掌握。</p>\n<h1 id=\"我对测试框架的理解\"><a href=\"#我对测试框架的理解\" class=\"headerlink\" title=\"我对测试框架的理解\"></a>我对测试框架的理解</h1><h3 id=\"npm-run-unit-执行过程\"><a href=\"#npm-run-unit-执行过程\" class=\"headerlink\" title=\"npm run unit 执行过程\"></a>npm run unit 执行过程</h3><ol>\n<li>执行 <code>npm run unit</code> 命令</li>\n<li>开启Karma运行环境</li>\n<li>使用Mocha去逐个测试用Chai断言写的测试用例</li>\n<li>在终端显示测试结果</li>\n<li>如果测试成功，karma-coverage 会在 <code>./test/unit/coverage</code> 文件夹中生成测试覆盖率结果的网页。</li>\n</ol>\n<h3 id=\"Karma-1\"><a href=\"#Karma-1\" class=\"headerlink\" title=\"Karma\"></a>Karma</h3><p>对于Karma，我只是了解了一下它的<a href=\"http://karma-runner.github.io/1.0/config/configuration-file.html\" target=\"_blank\" rel=\"noopener\">配置选项</a>。<br>下面是Vue的karma配置，简单注释了下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var webpackConfig = require(&apos;../../build/webpack.test.conf&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = function (config) &#123;</span><br><span class=\"line\">  config.set(&#123;</span><br><span class=\"line\">    // 浏览器</span><br><span class=\"line\">    browsers: [&apos;PhantomJS&apos;],</span><br><span class=\"line\">    // 测试框架</span><br><span class=\"line\">    frameworks: [&apos;mocha&apos;, &apos;sinon-chai&apos;, &apos;phantomjs-shim&apos;],</span><br><span class=\"line\">    // 测试报告</span><br><span class=\"line\">    reporters: [&apos;spec&apos;, &apos;coverage&apos;],</span><br><span class=\"line\">    // 测试入口文件</span><br><span class=\"line\">    files: [&apos;./index.js&apos;],</span><br><span class=\"line\">    // 预处理器 karma-webpack</span><br><span class=\"line\">    preprocessors: &#123;</span><br><span class=\"line\">      &apos;./index.js&apos;: [&apos;webpack&apos;, &apos;sourcemap&apos;]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // Webpack配置</span><br><span class=\"line\">    webpack: webpackConfig,</span><br><span class=\"line\">    // Webpack中间件</span><br><span class=\"line\">    webpackMiddleware: &#123;</span><br><span class=\"line\">      noInfo: true</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 测试覆盖率报告</span><br><span class=\"line\">    // https://github.com/karma-runner/karma-coverage/blob/master/docs/configuration.md</span><br><span class=\"line\">    coverageReporter: &#123;</span><br><span class=\"line\">      dir: &apos;./coverage&apos;,</span><br><span class=\"line\">      reporters: [</span><br><span class=\"line\">        &#123; type: &apos;lcov&apos;, subdir: &apos;.&apos; &#125;,</span><br><span class=\"line\">        &#123; type: &apos;text-summary&apos; &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Mocha和chai\"><a href=\"#Mocha和chai\" class=\"headerlink\" title=\"Mocha和chai\"></a>Mocha和chai</h3><p>我们看下官方的例子（都用注释来解释代码意思了）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;vue&apos; // 导入Vue用于生成Vue实例</span><br><span class=\"line\">import Hello from &apos;@/components/Hello&apos; // 导入组件</span><br><span class=\"line\">// 测试脚本里面应该包括一个或多个describe块，称为测试套件（test suite）</span><br><span class=\"line\">describe(&apos;Hello.vue&apos;, () =&gt; &#123;</span><br><span class=\"line\">  // 每个describe块应该包括一个或多个it块，称为测试用例（test case）</span><br><span class=\"line\">  it(&apos;should render correct contents&apos;, () =&gt; &#123;</span><br><span class=\"line\">    const Constructor = Vue.extend(Hello) // 获得Hello组件实例</span><br><span class=\"line\">    const vm = new Constructor().$mount() // 将组件挂在到DOM上</span><br><span class=\"line\">    //断言：DOM中class为hello的元素中的h1元素的文本内容为Welcome to Your Vue.js App</span><br><span class=\"line\">    expect(vm.$el.querySelector(&apos;.hello h1&apos;).textContent)</span><br><span class=\"line\">      .to.equal(&apos;Welcome to Your Vue.js App&apos;)  </span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>需要知道的知识点：</strong></p>\n<ul>\n<li>测试脚本都要放在 <code>test/unit/specs/</code> 目录下。</li>\n<li>脚本命名方式为  <code>[组件名].spec.js</code>。</li>\n<li>所谓断言，就是对组件做一些操作，并预言产生的结果。如果测试结果与断言相同则测试通过。</li>\n<li>单元测试默认测试 <code>src</code> 目录下除了 <code>main.js</code> 之外的所有文件，可在 <code>test/unit/index.js</code> 文件中修改。</li>\n<li>Chai断言库中，<code>to be been is that which and has have with at of same</code> 这些语言链是没有意义的，只是便于理解而已。</li>\n<li>测试脚本由多个  <code>descibe</code> 组成，每个 <code>describe</code> 由多个 <code>it</code> 组成。</li>\n<li><p>了解异步测试</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(&apos;异步请求应该返回一个对象&apos;, done =&gt; &#123;</span><br><span class=\"line\">    request</span><br><span class=\"line\">    .get(&apos;https://api.github.com&apos;)</span><br><span class=\"line\">    .end(function(err, res)&#123;</span><br><span class=\"line\">      expect(res).to.be.an(&apos;object&apos;);</span><br><span class=\"line\">      done();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>了解一下 <code>describe</code> 的钩子（生命周期）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(&apos;hooks&apos;, function() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  before(function() &#123;</span><br><span class=\"line\">    // 在本区块的所有测试用例之前执行</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  after(function() &#123;</span><br><span class=\"line\">    // 在本区块的所有测试用例之后执行</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  beforeEach(function() &#123;</span><br><span class=\"line\">    // 在本区块的每个测试用例之前执行</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  afterEach(function() &#123;</span><br><span class=\"line\">    // 在本区块的每个测试用例之后执行</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // test cases</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h1><p>上面简单介绍了单元测试的用法，下面来动手在Vue中进行单元测试！</p>\n<h3 id=\"util-js\"><a href=\"#util-js\" class=\"headerlink\" title=\"util.js\"></a>util.js</h3><p>从Vue官方的demo可以看出，对于Vue的单元测试我们需要将组件实例化为一个Vue实例，有时还需要挂载到DOM上。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Constructor = Vue.extend(Hello) // 获得Hello组件实例</span><br><span class=\"line\">const vm = new Constructor().$mount() // 将组件挂载到DOM上</span><br></pre></td></tr></table></figure></p>\n<p>以上写法只是简单的获取组件，有时候我们需要传递props属性、自定义方法等，还有可能我们需要用到第三方UI框架。所以以上写法非常麻烦。<br>这里推荐Element的<a href=\"https://github.com/ElemeFE/element/blob/dev/test/unit/util.js\" target=\"_blank\" rel=\"noopener\">单元测试工具脚本Util.js</a>，它封装了Vue单元测试中常用的方法。下面demo也是根据该 <code>Util.js</code>来写的。<br>这里简单注释了下各方法的用途。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 回收 vm，一般在每个测试脚本测试完成后执行回收vm。</span><br><span class=\"line\"> * @param  &#123;Object&#125; vm</span><br><span class=\"line\"> */</span><br><span class=\"line\">exports.destroyVM = function (vm) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 创建一个 Vue 的实例对象</span><br><span class=\"line\"> * @param  &#123;Object|String&#125;  Compo     - 组件配置，可直接传 template</span><br><span class=\"line\"> * @param  &#123;Boolean=false&#125;  mounted   - 是否添加到 DOM 上</span><br><span class=\"line\"> * @return &#123;Object&#125; vm</span><br><span class=\"line\"> */</span><br><span class=\"line\">exports.createVue = function (Compo, mounted = false) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 创建一个测试组件实例</span><br><span class=\"line\"> * @param  &#123;Object&#125;  Compo          - 组件对象</span><br><span class=\"line\"> * @param  &#123;Object&#125;  propsData      - props 数据</span><br><span class=\"line\"> * @param  &#123;Boolean=false&#125; mounted  - 是否添加到 DOM 上</span><br><span class=\"line\"> * @return &#123;Object&#125; vm</span><br><span class=\"line\"> */</span><br><span class=\"line\">exports.createTest = function (Compo, propsData = &#123;&#125;, mounted = false) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 触发一个事件</span><br><span class=\"line\"> * 注： 一般在触发事件后使用 vm.$nextTick 方法确定事件触发完成。</span><br><span class=\"line\"> * mouseenter, mouseleave, mouseover, keyup, change, click 等</span><br><span class=\"line\"> * @param  &#123;Element&#125; elm      - 元素</span><br><span class=\"line\"> * @param  &#123;String&#125; name      - 事件名称</span><br><span class=\"line\"> * @param  &#123;*&#125; opts           - 配置项</span><br><span class=\"line\"> */</span><br><span class=\"line\">exports.triggerEvent = function (elm, name, ...opts) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 触发 “mouseup” 和 “mousedown” 事件，既触发点击事件。</span><br><span class=\"line\"> * @param &#123;Element&#125; elm     - 元素</span><br><span class=\"line\"> * @param &#123;*&#125; opts          - 配置选项</span><br><span class=\"line\"> */</span><br><span class=\"line\">exports.triggerClick = function (elm, ...opts) &#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"示例一\"><a href=\"#示例一\" class=\"headerlink\" title=\"示例一\"></a>示例一</h3><p>示例一中我们测试了 <code>Hello</code> 组件的各种元素的数据，学习  <code>util.js</code> 的 <code>destroyVM</code> 和 <code>createTest</code> 方法的用法以及如何获取目标元素进行测试。获取DOM元素的方式可查看<a href=\"http://www.runoob.com/jsref/dom-obj-document.html\" target=\"_blank\" rel=\"noopener\">DOM 对象</a>教程。<br><strong>Hello.vue</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class=\"line\">    &lt;h1 class=&quot;hello-title&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class=\"line\">    &lt;h2 class=&quot;hello-content&quot;&gt;&#123;&#123; content &#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;hello&apos;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    content: String</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      msg: &apos;Welcome!&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Hello.spec.js</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; destroyVM, createTest &#125; from &apos;../util&apos;</span><br><span class=\"line\">import Hello from &apos;@/components/Hello&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(&apos;Hello.vue&apos;, () =&gt; &#123;</span><br><span class=\"line\">  let vm</span><br><span class=\"line\"></span><br><span class=\"line\">  afterEach(() =&gt; &#123;</span><br><span class=\"line\">    destroyVM(vm)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&apos;测试获取元素内容&apos;, () =&gt; &#123;</span><br><span class=\"line\">    vm = createTest(Hello, &#123; content: &apos;Hello World&apos; &#125;, true)</span><br><span class=\"line\">    expect(vm.$el.querySelector(&apos;.hello h1&apos;).textContent).to.equal(&apos;Welcome!&apos;)</span><br><span class=\"line\">    expect(vm.$el.querySelector(&apos;.hello h2&apos;).textContent).to.have.be.equal(&apos;Hello World&apos;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&apos;测试获取Vue对象中数据&apos;, () =&gt; &#123;</span><br><span class=\"line\">    vm = createTest(Hello, &#123; content: &apos;Hello World&apos; &#125;, true)</span><br><span class=\"line\">    expect(vm.msg).to.equal(&apos;Welcome!&apos;)</span><br><span class=\"line\">    // Chai的语言链是无意义的，可以随便写。如下：</span><br><span class=\"line\">    expect(vm.content).which.have.to.be.that.equal(&apos;Hello World&apos;) </span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&apos;测试获取DOM中是否存在某个class&apos;, () =&gt; &#123;</span><br><span class=\"line\">    vm = createTest(Hello, &#123; content: &apos;Hello World&apos; &#125;, true)</span><br><span class=\"line\">    expect(vm.$el.classList.contains(&apos;hello&apos;)).to.be.true</span><br><span class=\"line\">    const title = vm.$el.querySelector(&apos;.hello h1&apos;)</span><br><span class=\"line\">    expect(title.classList.contains(&apos;hello-title&apos;)).to.be.true</span><br><span class=\"line\">    const content = vm.$el.querySelector(&apos;.hello-content&apos;)</span><br><span class=\"line\">    expect(content.classList.contains(&apos;hello-content&apos;)).to.be.true</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>输出结果</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello.vue</span><br><span class=\"line\">  √ 测试获取元素内容</span><br><span class=\"line\">  √ 测试获取Vue对象中数据</span><br><span class=\"line\">  √ 测试获取DOM中是否存在某个class</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"示例二\"><a href=\"#示例二\" class=\"headerlink\" title=\"示例二\"></a>示例二</h3><p>示例二中我们使用 <code>createTest</code> 创建测试组件测试点击事件，用 <code>createVue</code> 创建Vue示例对象测试组件 <code>Click</code> 的使用。这里主要可以看下到 <code>createVue</code> 方法的使用。<br><strong>Click.vue</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;span class=&quot;init-num&quot;&gt;初始值为&#123;&#123; InitNum &#125;&#125;&lt;/span&gt;&lt;br&gt;</span><br><span class=\"line\">    &lt;span class=&quot;click-num&quot;&gt;点击了&#123;&#123; ClickNum &#125;&#125;次&lt;/span&gt;&lt;br&gt;</span><br><span class=\"line\">    &lt;span class=&quot;result-num&quot;&gt;最终结果为&#123;&#123; ResultNum &#125;&#125;&lt;/span&gt;&lt;br&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;add&quot;&gt;累加&#123;&#123; AddNum &#125;&#125;&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;Click&apos;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    AddNum: &#123;</span><br><span class=\"line\">      type: Number,</span><br><span class=\"line\">      default: 1</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    InitNum: &#123;</span><br><span class=\"line\">      type: Number,</span><br><span class=\"line\">      default: 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      ClickNum: 0,</span><br><span class=\"line\">      ResultNum: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted () &#123;</span><br><span class=\"line\">    this.ResultNum = this.InitNum</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    add () &#123;</span><br><span class=\"line\">      this.ResultNum += this.AddNum</span><br><span class=\"line\">      this.ClickNum++</span><br><span class=\"line\">      this.$emit(&apos;result&apos;, &#123;</span><br><span class=\"line\">        ClickNum: this.ClickNum,</span><br><span class=\"line\">        ResultNum: this.ResultNum</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Click.spec.js</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; destroyVM, createTest, createVue &#125; from &apos;../util&apos;</span><br><span class=\"line\">import Click from &apos;@/components/Click&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(&apos;click.vue&apos;, () =&gt; &#123;</span><br><span class=\"line\">  let vm</span><br><span class=\"line\"></span><br><span class=\"line\">  afterEach(() =&gt; &#123;</span><br><span class=\"line\">    destroyVM(vm)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&apos;测试按钮点击事件&apos;, () =&gt; &#123;</span><br><span class=\"line\">    vm = createTest(Click, &#123;</span><br><span class=\"line\">      AddNum: 10,</span><br><span class=\"line\">      InitNum: 11</span><br><span class=\"line\">    &#125;, true)</span><br><span class=\"line\">    let buttonElm = vm.$el.querySelector(&apos;button&apos;)</span><br><span class=\"line\">    buttonElm.click()</span><br><span class=\"line\">    buttonElm.click()</span><br><span class=\"line\">    buttonElm.click()</span><br><span class=\"line\">    // setTimeout 的原因</span><br><span class=\"line\">    // 在数据改变之后，界面的变化会有一定延时。不用timeout有时候会发现界面没有变化</span><br><span class=\"line\">    setTimeout(done =&gt; &#123;</span><br><span class=\"line\">      expect(vm.ResultNum).to.equal(41)</span><br><span class=\"line\">      expect(vm.$el.querySelector(&apos;.init-num&apos;).textContent).to.equal(&apos;初始值为11&apos;)</span><br><span class=\"line\">      expect(vm.$el.querySelector(&apos;.click-num&apos;).textContent).to.equal(&apos;点击了3次&apos;)</span><br><span class=\"line\">      expect(vm.$el.querySelector(&apos;.result-num&apos;).textContent).to.equal(&apos;最终结果为41&apos;)</span><br><span class=\"line\">      done()</span><br><span class=\"line\">    &#125;, 100)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&apos;测试创建Vue对象&apos;, () =&gt; &#123;</span><br><span class=\"line\">    let result</span><br><span class=\"line\">    vm = createVue(&#123;</span><br><span class=\"line\">      template: `</span><br><span class=\"line\">        &lt;click @click=&quot;handleClick&quot;&gt;&lt;/click&gt;</span><br><span class=\"line\">      `,</span><br><span class=\"line\">      props: &#123;</span><br><span class=\"line\">        AddNum: 10,</span><br><span class=\"line\">        InitNum: 11</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      methods: &#123;</span><br><span class=\"line\">        handleClick (obj) &#123;</span><br><span class=\"line\">          result = obj</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      components: &#123;</span><br><span class=\"line\">        Click</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, true)</span><br><span class=\"line\">    vm.$el.click()</span><br><span class=\"line\">    vm.$nextTick(done =&gt; &#123;</span><br><span class=\"line\">      expect(result).to.be.exist</span><br><span class=\"line\">      expect(result.ClickNum).to.equal(1)</span><br><span class=\"line\">      expect(result.ResultNum).to.be.equal(21)</span><br><span class=\"line\">      done()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>输出结果</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">click.vue</span><br><span class=\"line\">  √ 测试按钮点击事件</span><br><span class=\"line\">  √ 测试创建Vue对象</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>所有示例代码都放<a href=\"https://github.com/violetjack/VueStudyDemos/tree/master/VueTestDemo\" target=\"_blank\" rel=\"noopener\">Github仓库</a>中便于查看。如果想查看更多好的测试用例，建议配合 <code>Util.js</code> 看一下 <a href=\"https://github.com/ElemeFE/element/tree/dev/test/unit\" target=\"_blank\" rel=\"noopener\">Element 的单元测试脚本的写法</a>，里面有很多测试脚本可以供我们学习。作为被广大Vue用户使用的UI组件库，测试脚本肯定也写很很不错的~甚至可以将这些脚本照抄一遍，相信这会对学习Vue组件的单元测试有很大帮助。</p>\n<p>下面是本人看Element单元测试的笔记，供参考。</p>\n<ul>\n<li>Util.js 方法包含了大多数Vue组件化的测试需求。</li>\n<li><code>vm.$el</code> <code>vm.$nextTick</code> 和 <code>vm.$ref</code> 都是在测试过程中比较常用的一些Vue语法糖。</li>\n<li>需要注意： vm.$nextTick 方法是异步的，所以需要在里面使用done方法。</li>\n<li>异步断言，方法参数需要是 <code>_</code> 或者 <code>done</code></li>\n<li>大多数时候查询元素通过 <code>querySelector</code> 方法查询class获得<ul>\n<li>vm.$el.querySelector(‘.el-breadcrumb’).innerText</li>\n</ul>\n</li>\n<li>大多数情况下查询是否存在某个Class通过 <code>classList.contains</code> 方法获得，查找的结果为 true 或 false<ul>\n<li>vm.$el .classList.contains(‘el-button–primary’)</li>\n</ul>\n</li>\n<li>异步测试必须以 <code>done()</code> 方法结尾。<code>setTimeout</code> 和 <code>vm.$nextTick</code> 是常用的异步测试。</li>\n<li>实现按钮点击：通过获取按钮元素 <code>btn</code>，执行 <code>btn.click()</code> 方法实现。</li>\n<li>由于 Vue 进行 <a href=\"http://cn.vuejs.org/v2/guide/reactivity.html#Async-Update-Queue\" target=\"_blank\" rel=\"noopener\">异步更新DOM</a> 的情况，一些依赖DOM更新结果的断言必须在 <code>Vue.nextTick</code> 回调中进行。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">triggerEvent(vm.$refs.cascader.$el, &apos;mouseenter&apos;);</span><br><span class=\"line\">vm.$nextTick(_ =&gt; &#123;</span><br><span class=\"line\">     vm.$refs.cascader.$el.querySelector(&apos;.el-cascader__clearIcon&apos;).click();</span><br><span class=\"line\">     vm.$nextTick(_ =&gt; &#123;</span><br><span class=\"line\">        expect(vm.selectedOptions.length).to.be.equal(0);</span><br><span class=\"line\">        done();</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li><a href=\"http://cn.vuejs.org/v2/guide/unit-testing.html\" target=\"_blank\" rel=\"noopener\">单元测试</a></li>\n<li><a href=\"http://www.jianshu.com/p/f200a75a15d2\" target=\"_blank\" rel=\"noopener\">Chai.js断言库API中文文档</a></li>\n<li><a href=\"https://github.com/ElemeFE/element/tree/dev/test/unit\" target=\"_blank\" rel=\"noopener\">Element</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006895064\" target=\"_blank\" rel=\"noopener\">前端单元测试之Karma环境搭建</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000009527765\" target=\"_blank\" rel=\"noopener\">前端自动化测试是干嘛的？</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html\" target=\"_blank\" rel=\"noopener\">测试框架 Mocha 实例教程</a></li>\n<li><a href=\"http://karma-runner.github.io/1.0/index.html\" target=\"_blank\" rel=\"noopener\">Karma官网</a></li>\n</ul>\n<h1 id=\"Vue-js学习系列\"><a href=\"#Vue-js学习系列\" class=\"headerlink\" title=\"Vue.js学习系列\"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>\n<p><a href=\"http://www.jianshu.com/p/8013d8d37bd0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/d6f7e11f18af\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/8e5fb763c3d7\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href=\"http://www.jianshu.com/p/aef34acd111f\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href=\"http://www.jianshu.com/p/efb6fbed6fac\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href=\"http://www.jianshu.com/p/073d25a3bba0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href=\"https://www.jianshu.com/p/ba7466d7101a\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href=\"https://www.jianshu.com/p/15028f91226e\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>\n<h1 id=\"Vue-js学习系列项目地址\"><a href=\"#Vue-js学习系列项目地址\" class=\"headerlink\" title=\"Vue.js学习系列项目地址\"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack/VueStudyDemos</a></p>\n<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>\n<p>新浪微博： <a href=\"http://weibo.com/u/2640909603\" target=\"_blank\" rel=\"noopener\">http://weibo.com/u/2640909603</a><br>掘金：<a href=\"https://gold.xitu.io/user/571d953d39b0570068145cd1\" target=\"_blank\" rel=\"noopener\">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href=\"http://blog.csdn.net/violetjack0808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/violetjack0808</a><br>简书： <a href=\"http://www.jianshu.com/users/54ae4af3a98d/latest_articles\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href=\"https://github.com/violetjack\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在使用vue-cli创建项目的时候，会提示要不要安装单元测试和e2e测试。既然官方推荐我们使用这两个测试框架，那么我们就动手去学习实践一下他们吧。</p>\n</blockquote>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><h3 id=\"Karma\"><a href=\"#Karma\" class=\"headerlink\" title=\"Karma\"></a>Karma</h3><p><strong>Karma</strong>是一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。该工具在Vue中的主要作用是将项目运行在各种主流Web浏览器进行测试。<br>换句话说，它是一个测试工具，能让你的代码在浏览器环境下测试。需要它的原因在于，你的代码可能是设计在浏览器端执行的，在node环境下测试可能有些bug暴露不出来；另外，浏览器有兼容问题，karma提供了手段让你的代码自动在多个浏览器（chrome，firefox，ie等）环境下运行。如果你的代码只会运行在node端，那么你不需要用karma。</p>\n<h3 id=\"Mocha\"><a href=\"#Mocha\" class=\"headerlink\" title=\"Mocha\"></a>Mocha</h3><p><strong>Mocha</strong>是一个测试框架，在vue-cli中配合<strong>chai断言库</strong>实现单元测试。<br>Mocha的常用命令和用法不算太多，看阮一峰老师的<a href=\"http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html\" target=\"_blank\" rel=\"noopener\">测试框架 Mocha 实例教程</a>就可以大致了解了。<br>而Chai断言库可以看<a href=\"http://www.jianshu.com/p/f200a75a15d2\" target=\"_blank\" rel=\"noopener\">Chai.js断言库API中文文档</a>，很简单，多查多用就能很快掌握。</p>\n<h1 id=\"我对测试框架的理解\"><a href=\"#我对测试框架的理解\" class=\"headerlink\" title=\"我对测试框架的理解\"></a>我对测试框架的理解</h1><h3 id=\"npm-run-unit-执行过程\"><a href=\"#npm-run-unit-执行过程\" class=\"headerlink\" title=\"npm run unit 执行过程\"></a>npm run unit 执行过程</h3><ol>\n<li>执行 <code>npm run unit</code> 命令</li>\n<li>开启Karma运行环境</li>\n<li>使用Mocha去逐个测试用Chai断言写的测试用例</li>\n<li>在终端显示测试结果</li>\n<li>如果测试成功，karma-coverage 会在 <code>./test/unit/coverage</code> 文件夹中生成测试覆盖率结果的网页。</li>\n</ol>\n<h3 id=\"Karma-1\"><a href=\"#Karma-1\" class=\"headerlink\" title=\"Karma\"></a>Karma</h3><p>对于Karma，我只是了解了一下它的<a href=\"http://karma-runner.github.io/1.0/config/configuration-file.html\" target=\"_blank\" rel=\"noopener\">配置选项</a>。<br>下面是Vue的karma配置，简单注释了下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var webpackConfig = require(&apos;../../build/webpack.test.conf&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = function (config) &#123;</span><br><span class=\"line\">  config.set(&#123;</span><br><span class=\"line\">    // 浏览器</span><br><span class=\"line\">    browsers: [&apos;PhantomJS&apos;],</span><br><span class=\"line\">    // 测试框架</span><br><span class=\"line\">    frameworks: [&apos;mocha&apos;, &apos;sinon-chai&apos;, &apos;phantomjs-shim&apos;],</span><br><span class=\"line\">    // 测试报告</span><br><span class=\"line\">    reporters: [&apos;spec&apos;, &apos;coverage&apos;],</span><br><span class=\"line\">    // 测试入口文件</span><br><span class=\"line\">    files: [&apos;./index.js&apos;],</span><br><span class=\"line\">    // 预处理器 karma-webpack</span><br><span class=\"line\">    preprocessors: &#123;</span><br><span class=\"line\">      &apos;./index.js&apos;: [&apos;webpack&apos;, &apos;sourcemap&apos;]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // Webpack配置</span><br><span class=\"line\">    webpack: webpackConfig,</span><br><span class=\"line\">    // Webpack中间件</span><br><span class=\"line\">    webpackMiddleware: &#123;</span><br><span class=\"line\">      noInfo: true</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    // 测试覆盖率报告</span><br><span class=\"line\">    // https://github.com/karma-runner/karma-coverage/blob/master/docs/configuration.md</span><br><span class=\"line\">    coverageReporter: &#123;</span><br><span class=\"line\">      dir: &apos;./coverage&apos;,</span><br><span class=\"line\">      reporters: [</span><br><span class=\"line\">        &#123; type: &apos;lcov&apos;, subdir: &apos;.&apos; &#125;,</span><br><span class=\"line\">        &#123; type: &apos;text-summary&apos; &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Mocha和chai\"><a href=\"#Mocha和chai\" class=\"headerlink\" title=\"Mocha和chai\"></a>Mocha和chai</h3><p>我们看下官方的例子（都用注释来解释代码意思了）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;vue&apos; // 导入Vue用于生成Vue实例</span><br><span class=\"line\">import Hello from &apos;@/components/Hello&apos; // 导入组件</span><br><span class=\"line\">// 测试脚本里面应该包括一个或多个describe块，称为测试套件（test suite）</span><br><span class=\"line\">describe(&apos;Hello.vue&apos;, () =&gt; &#123;</span><br><span class=\"line\">  // 每个describe块应该包括一个或多个it块，称为测试用例（test case）</span><br><span class=\"line\">  it(&apos;should render correct contents&apos;, () =&gt; &#123;</span><br><span class=\"line\">    const Constructor = Vue.extend(Hello) // 获得Hello组件实例</span><br><span class=\"line\">    const vm = new Constructor().$mount() // 将组件挂在到DOM上</span><br><span class=\"line\">    //断言：DOM中class为hello的元素中的h1元素的文本内容为Welcome to Your Vue.js App</span><br><span class=\"line\">    expect(vm.$el.querySelector(&apos;.hello h1&apos;).textContent)</span><br><span class=\"line\">      .to.equal(&apos;Welcome to Your Vue.js App&apos;)  </span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>需要知道的知识点：</strong></p>\n<ul>\n<li>测试脚本都要放在 <code>test/unit/specs/</code> 目录下。</li>\n<li>脚本命名方式为  <code>[组件名].spec.js</code>。</li>\n<li>所谓断言，就是对组件做一些操作，并预言产生的结果。如果测试结果与断言相同则测试通过。</li>\n<li>单元测试默认测试 <code>src</code> 目录下除了 <code>main.js</code> 之外的所有文件，可在 <code>test/unit/index.js</code> 文件中修改。</li>\n<li>Chai断言库中，<code>to be been is that which and has have with at of same</code> 这些语言链是没有意义的，只是便于理解而已。</li>\n<li>测试脚本由多个  <code>descibe</code> 组成，每个 <code>describe</code> 由多个 <code>it</code> 组成。</li>\n<li><p>了解异步测试</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(&apos;异步请求应该返回一个对象&apos;, done =&gt; &#123;</span><br><span class=\"line\">    request</span><br><span class=\"line\">    .get(&apos;https://api.github.com&apos;)</span><br><span class=\"line\">    .end(function(err, res)&#123;</span><br><span class=\"line\">      expect(res).to.be.an(&apos;object&apos;);</span><br><span class=\"line\">      done();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>了解一下 <code>describe</code> 的钩子（生命周期）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(&apos;hooks&apos;, function() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  before(function() &#123;</span><br><span class=\"line\">    // 在本区块的所有测试用例之前执行</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  after(function() &#123;</span><br><span class=\"line\">    // 在本区块的所有测试用例之后执行</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  beforeEach(function() &#123;</span><br><span class=\"line\">    // 在本区块的每个测试用例之前执行</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  afterEach(function() &#123;</span><br><span class=\"line\">    // 在本区块的每个测试用例之后执行</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  // test cases</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h1><p>上面简单介绍了单元测试的用法，下面来动手在Vue中进行单元测试！</p>\n<h3 id=\"util-js\"><a href=\"#util-js\" class=\"headerlink\" title=\"util.js\"></a>util.js</h3><p>从Vue官方的demo可以看出，对于Vue的单元测试我们需要将组件实例化为一个Vue实例，有时还需要挂载到DOM上。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Constructor = Vue.extend(Hello) // 获得Hello组件实例</span><br><span class=\"line\">const vm = new Constructor().$mount() // 将组件挂载到DOM上</span><br></pre></td></tr></table></figure></p>\n<p>以上写法只是简单的获取组件，有时候我们需要传递props属性、自定义方法等，还有可能我们需要用到第三方UI框架。所以以上写法非常麻烦。<br>这里推荐Element的<a href=\"https://github.com/ElemeFE/element/blob/dev/test/unit/util.js\" target=\"_blank\" rel=\"noopener\">单元测试工具脚本Util.js</a>，它封装了Vue单元测试中常用的方法。下面demo也是根据该 <code>Util.js</code>来写的。<br>这里简单注释了下各方法的用途。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 回收 vm，一般在每个测试脚本测试完成后执行回收vm。</span><br><span class=\"line\"> * @param  &#123;Object&#125; vm</span><br><span class=\"line\"> */</span><br><span class=\"line\">exports.destroyVM = function (vm) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 创建一个 Vue 的实例对象</span><br><span class=\"line\"> * @param  &#123;Object|String&#125;  Compo     - 组件配置，可直接传 template</span><br><span class=\"line\"> * @param  &#123;Boolean=false&#125;  mounted   - 是否添加到 DOM 上</span><br><span class=\"line\"> * @return &#123;Object&#125; vm</span><br><span class=\"line\"> */</span><br><span class=\"line\">exports.createVue = function (Compo, mounted = false) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 创建一个测试组件实例</span><br><span class=\"line\"> * @param  &#123;Object&#125;  Compo          - 组件对象</span><br><span class=\"line\"> * @param  &#123;Object&#125;  propsData      - props 数据</span><br><span class=\"line\"> * @param  &#123;Boolean=false&#125; mounted  - 是否添加到 DOM 上</span><br><span class=\"line\"> * @return &#123;Object&#125; vm</span><br><span class=\"line\"> */</span><br><span class=\"line\">exports.createTest = function (Compo, propsData = &#123;&#125;, mounted = false) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 触发一个事件</span><br><span class=\"line\"> * 注： 一般在触发事件后使用 vm.$nextTick 方法确定事件触发完成。</span><br><span class=\"line\"> * mouseenter, mouseleave, mouseover, keyup, change, click 等</span><br><span class=\"line\"> * @param  &#123;Element&#125; elm      - 元素</span><br><span class=\"line\"> * @param  &#123;String&#125; name      - 事件名称</span><br><span class=\"line\"> * @param  &#123;*&#125; opts           - 配置项</span><br><span class=\"line\"> */</span><br><span class=\"line\">exports.triggerEvent = function (elm, name, ...opts) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 触发 “mouseup” 和 “mousedown” 事件，既触发点击事件。</span><br><span class=\"line\"> * @param &#123;Element&#125; elm     - 元素</span><br><span class=\"line\"> * @param &#123;*&#125; opts          - 配置选项</span><br><span class=\"line\"> */</span><br><span class=\"line\">exports.triggerClick = function (elm, ...opts) &#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"示例一\"><a href=\"#示例一\" class=\"headerlink\" title=\"示例一\"></a>示例一</h3><p>示例一中我们测试了 <code>Hello</code> 组件的各种元素的数据，学习  <code>util.js</code> 的 <code>destroyVM</code> 和 <code>createTest</code> 方法的用法以及如何获取目标元素进行测试。获取DOM元素的方式可查看<a href=\"http://www.runoob.com/jsref/dom-obj-document.html\" target=\"_blank\" rel=\"noopener\">DOM 对象</a>教程。<br><strong>Hello.vue</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class=\"line\">    &lt;h1 class=&quot;hello-title&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class=\"line\">    &lt;h2 class=&quot;hello-content&quot;&gt;&#123;&#123; content &#125;&#125;&lt;/h2&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;hello&apos;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    content: String</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      msg: &apos;Welcome!&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Hello.spec.js</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; destroyVM, createTest &#125; from &apos;../util&apos;</span><br><span class=\"line\">import Hello from &apos;@/components/Hello&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(&apos;Hello.vue&apos;, () =&gt; &#123;</span><br><span class=\"line\">  let vm</span><br><span class=\"line\"></span><br><span class=\"line\">  afterEach(() =&gt; &#123;</span><br><span class=\"line\">    destroyVM(vm)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&apos;测试获取元素内容&apos;, () =&gt; &#123;</span><br><span class=\"line\">    vm = createTest(Hello, &#123; content: &apos;Hello World&apos; &#125;, true)</span><br><span class=\"line\">    expect(vm.$el.querySelector(&apos;.hello h1&apos;).textContent).to.equal(&apos;Welcome!&apos;)</span><br><span class=\"line\">    expect(vm.$el.querySelector(&apos;.hello h2&apos;).textContent).to.have.be.equal(&apos;Hello World&apos;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&apos;测试获取Vue对象中数据&apos;, () =&gt; &#123;</span><br><span class=\"line\">    vm = createTest(Hello, &#123; content: &apos;Hello World&apos; &#125;, true)</span><br><span class=\"line\">    expect(vm.msg).to.equal(&apos;Welcome!&apos;)</span><br><span class=\"line\">    // Chai的语言链是无意义的，可以随便写。如下：</span><br><span class=\"line\">    expect(vm.content).which.have.to.be.that.equal(&apos;Hello World&apos;) </span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&apos;测试获取DOM中是否存在某个class&apos;, () =&gt; &#123;</span><br><span class=\"line\">    vm = createTest(Hello, &#123; content: &apos;Hello World&apos; &#125;, true)</span><br><span class=\"line\">    expect(vm.$el.classList.contains(&apos;hello&apos;)).to.be.true</span><br><span class=\"line\">    const title = vm.$el.querySelector(&apos;.hello h1&apos;)</span><br><span class=\"line\">    expect(title.classList.contains(&apos;hello-title&apos;)).to.be.true</span><br><span class=\"line\">    const content = vm.$el.querySelector(&apos;.hello-content&apos;)</span><br><span class=\"line\">    expect(content.classList.contains(&apos;hello-content&apos;)).to.be.true</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>输出结果</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello.vue</span><br><span class=\"line\">  √ 测试获取元素内容</span><br><span class=\"line\">  √ 测试获取Vue对象中数据</span><br><span class=\"line\">  √ 测试获取DOM中是否存在某个class</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"示例二\"><a href=\"#示例二\" class=\"headerlink\" title=\"示例二\"></a>示例二</h3><p>示例二中我们使用 <code>createTest</code> 创建测试组件测试点击事件，用 <code>createVue</code> 创建Vue示例对象测试组件 <code>Click</code> 的使用。这里主要可以看下到 <code>createVue</code> 方法的使用。<br><strong>Click.vue</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;span class=&quot;init-num&quot;&gt;初始值为&#123;&#123; InitNum &#125;&#125;&lt;/span&gt;&lt;br&gt;</span><br><span class=\"line\">    &lt;span class=&quot;click-num&quot;&gt;点击了&#123;&#123; ClickNum &#125;&#125;次&lt;/span&gt;&lt;br&gt;</span><br><span class=\"line\">    &lt;span class=&quot;result-num&quot;&gt;最终结果为&#123;&#123; ResultNum &#125;&#125;&lt;/span&gt;&lt;br&gt;</span><br><span class=\"line\">    &lt;button @click=&quot;add&quot;&gt;累加&#123;&#123; AddNum &#125;&#125;&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;Click&apos;,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    AddNum: &#123;</span><br><span class=\"line\">      type: Number,</span><br><span class=\"line\">      default: 1</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    InitNum: &#123;</span><br><span class=\"line\">      type: Number,</span><br><span class=\"line\">      default: 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      ClickNum: 0,</span><br><span class=\"line\">      ResultNum: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted () &#123;</span><br><span class=\"line\">    this.ResultNum = this.InitNum</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    add () &#123;</span><br><span class=\"line\">      this.ResultNum += this.AddNum</span><br><span class=\"line\">      this.ClickNum++</span><br><span class=\"line\">      this.$emit(&apos;result&apos;, &#123;</span><br><span class=\"line\">        ClickNum: this.ClickNum,</span><br><span class=\"line\">        ResultNum: this.ResultNum</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Click.spec.js</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; destroyVM, createTest, createVue &#125; from &apos;../util&apos;</span><br><span class=\"line\">import Click from &apos;@/components/Click&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(&apos;click.vue&apos;, () =&gt; &#123;</span><br><span class=\"line\">  let vm</span><br><span class=\"line\"></span><br><span class=\"line\">  afterEach(() =&gt; &#123;</span><br><span class=\"line\">    destroyVM(vm)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&apos;测试按钮点击事件&apos;, () =&gt; &#123;</span><br><span class=\"line\">    vm = createTest(Click, &#123;</span><br><span class=\"line\">      AddNum: 10,</span><br><span class=\"line\">      InitNum: 11</span><br><span class=\"line\">    &#125;, true)</span><br><span class=\"line\">    let buttonElm = vm.$el.querySelector(&apos;button&apos;)</span><br><span class=\"line\">    buttonElm.click()</span><br><span class=\"line\">    buttonElm.click()</span><br><span class=\"line\">    buttonElm.click()</span><br><span class=\"line\">    // setTimeout 的原因</span><br><span class=\"line\">    // 在数据改变之后，界面的变化会有一定延时。不用timeout有时候会发现界面没有变化</span><br><span class=\"line\">    setTimeout(done =&gt; &#123;</span><br><span class=\"line\">      expect(vm.ResultNum).to.equal(41)</span><br><span class=\"line\">      expect(vm.$el.querySelector(&apos;.init-num&apos;).textContent).to.equal(&apos;初始值为11&apos;)</span><br><span class=\"line\">      expect(vm.$el.querySelector(&apos;.click-num&apos;).textContent).to.equal(&apos;点击了3次&apos;)</span><br><span class=\"line\">      expect(vm.$el.querySelector(&apos;.result-num&apos;).textContent).to.equal(&apos;最终结果为41&apos;)</span><br><span class=\"line\">      done()</span><br><span class=\"line\">    &#125;, 100)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&apos;测试创建Vue对象&apos;, () =&gt; &#123;</span><br><span class=\"line\">    let result</span><br><span class=\"line\">    vm = createVue(&#123;</span><br><span class=\"line\">      template: `</span><br><span class=\"line\">        &lt;click @click=&quot;handleClick&quot;&gt;&lt;/click&gt;</span><br><span class=\"line\">      `,</span><br><span class=\"line\">      props: &#123;</span><br><span class=\"line\">        AddNum: 10,</span><br><span class=\"line\">        InitNum: 11</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      methods: &#123;</span><br><span class=\"line\">        handleClick (obj) &#123;</span><br><span class=\"line\">          result = obj</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      components: &#123;</span><br><span class=\"line\">        Click</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, true)</span><br><span class=\"line\">    vm.$el.click()</span><br><span class=\"line\">    vm.$nextTick(done =&gt; &#123;</span><br><span class=\"line\">      expect(result).to.be.exist</span><br><span class=\"line\">      expect(result.ClickNum).to.equal(1)</span><br><span class=\"line\">      expect(result.ResultNum).to.be.equal(21)</span><br><span class=\"line\">      done()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>输出结果</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">click.vue</span><br><span class=\"line\">  √ 测试按钮点击事件</span><br><span class=\"line\">  √ 测试创建Vue对象</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>所有示例代码都放<a href=\"https://github.com/violetjack/VueStudyDemos/tree/master/VueTestDemo\" target=\"_blank\" rel=\"noopener\">Github仓库</a>中便于查看。如果想查看更多好的测试用例，建议配合 <code>Util.js</code> 看一下 <a href=\"https://github.com/ElemeFE/element/tree/dev/test/unit\" target=\"_blank\" rel=\"noopener\">Element 的单元测试脚本的写法</a>，里面有很多测试脚本可以供我们学习。作为被广大Vue用户使用的UI组件库，测试脚本肯定也写很很不错的~甚至可以将这些脚本照抄一遍，相信这会对学习Vue组件的单元测试有很大帮助。</p>\n<p>下面是本人看Element单元测试的笔记，供参考。</p>\n<ul>\n<li>Util.js 方法包含了大多数Vue组件化的测试需求。</li>\n<li><code>vm.$el</code> <code>vm.$nextTick</code> 和 <code>vm.$ref</code> 都是在测试过程中比较常用的一些Vue语法糖。</li>\n<li>需要注意： vm.$nextTick 方法是异步的，所以需要在里面使用done方法。</li>\n<li>异步断言，方法参数需要是 <code>_</code> 或者 <code>done</code></li>\n<li>大多数时候查询元素通过 <code>querySelector</code> 方法查询class获得<ul>\n<li>vm.$el.querySelector(‘.el-breadcrumb’).innerText</li>\n</ul>\n</li>\n<li>大多数情况下查询是否存在某个Class通过 <code>classList.contains</code> 方法获得，查找的结果为 true 或 false<ul>\n<li>vm.$el .classList.contains(‘el-button–primary’)</li>\n</ul>\n</li>\n<li>异步测试必须以 <code>done()</code> 方法结尾。<code>setTimeout</code> 和 <code>vm.$nextTick</code> 是常用的异步测试。</li>\n<li>实现按钮点击：通过获取按钮元素 <code>btn</code>，执行 <code>btn.click()</code> 方法实现。</li>\n<li>由于 Vue 进行 <a href=\"http://cn.vuejs.org/v2/guide/reactivity.html#Async-Update-Queue\" target=\"_blank\" rel=\"noopener\">异步更新DOM</a> 的情况，一些依赖DOM更新结果的断言必须在 <code>Vue.nextTick</code> 回调中进行。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">triggerEvent(vm.$refs.cascader.$el, &apos;mouseenter&apos;);</span><br><span class=\"line\">vm.$nextTick(_ =&gt; &#123;</span><br><span class=\"line\">     vm.$refs.cascader.$el.querySelector(&apos;.el-cascader__clearIcon&apos;).click();</span><br><span class=\"line\">     vm.$nextTick(_ =&gt; &#123;</span><br><span class=\"line\">        expect(vm.selectedOptions.length).to.be.equal(0);</span><br><span class=\"line\">        done();</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li><a href=\"http://cn.vuejs.org/v2/guide/unit-testing.html\" target=\"_blank\" rel=\"noopener\">单元测试</a></li>\n<li><a href=\"http://www.jianshu.com/p/f200a75a15d2\" target=\"_blank\" rel=\"noopener\">Chai.js断言库API中文文档</a></li>\n<li><a href=\"https://github.com/ElemeFE/element/tree/dev/test/unit\" target=\"_blank\" rel=\"noopener\">Element</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006895064\" target=\"_blank\" rel=\"noopener\">前端单元测试之Karma环境搭建</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000009527765\" target=\"_blank\" rel=\"noopener\">前端自动化测试是干嘛的？</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html\" target=\"_blank\" rel=\"noopener\">测试框架 Mocha 实例教程</a></li>\n<li><a href=\"http://karma-runner.github.io/1.0/index.html\" target=\"_blank\" rel=\"noopener\">Karma官网</a></li>\n</ul>\n<h1 id=\"Vue-js学习系列\"><a href=\"#Vue-js学习系列\" class=\"headerlink\" title=\"Vue.js学习系列\"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>\n<p><a href=\"http://www.jianshu.com/p/8013d8d37bd0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/d6f7e11f18af\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/8e5fb763c3d7\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href=\"http://www.jianshu.com/p/aef34acd111f\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href=\"http://www.jianshu.com/p/efb6fbed6fac\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href=\"http://www.jianshu.com/p/073d25a3bba0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href=\"https://www.jianshu.com/p/ba7466d7101a\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href=\"https://www.jianshu.com/p/15028f91226e\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>\n<h1 id=\"Vue-js学习系列项目地址\"><a href=\"#Vue-js学习系列项目地址\" class=\"headerlink\" title=\"Vue.js学习系列项目地址\"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack/VueStudyDemos</a></p>\n<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>\n<p>新浪微博： <a href=\"http://weibo.com/u/2640909603\" target=\"_blank\" rel=\"noopener\">http://weibo.com/u/2640909603</a><br>掘金：<a href=\"https://gold.xitu.io/user/571d953d39b0570068145cd1\" target=\"_blank\" rel=\"noopener\">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href=\"http://blog.csdn.net/violetjack0808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/violetjack0808</a><br>简书： <a href=\"http://www.jianshu.com/users/54ae4af3a98d/latest_articles\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href=\"https://github.com/violetjack\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack</a></p>\n"},{"title":"Vue.js学习系列四 —— Webpack学习实践","date":"2017-02-06T16:00:00.000Z","_content":"\n> 这两周一直想写webpack的知识点，却发现webpack其实要将webpack说的具体内容还是挺多的。而且稀土掘金上一搜webpack有好多人都有去写webpack的知识点，所以本文中不再去重复别人的东西了，就简单记录一下我对webpack的理解。并按照老规矩附上demo以及我收藏的几篇不错的webpack入门文章以供学习参考~\n\n# 一、什么是webpack\n## 1. webpack是什么？\nwebpack是一个模块打包工具。\n**用vue项目来举例：**浏览器它是只认识js，不认识vue的。而我们写的代码后缀大多是.vue的，在每个.vue文件中都可能html、js、css甚至是图片资源；并且由于组件化，这些.vue文件之间还有错综复杂的关系。所以项目要被浏览器识别，我们就要使用webpack将它们打包成js文件以及相应的资源文件。\n或者这么理解，我们以vue项目的形式编写项目逻辑，浏览器以他理解的方式来运行项目。webpack把我们的vue项目想表达的所有意图传递给浏览器让浏览器去运行。\n*PS：webpack功能不止于此，但这个功能是让我们项目能跑起来的必要条件！（个人理解，如有错误，还请批评指正）*\n## 2. 来个demo理解下\n这里我们来理解下webpack是如何打包的~（转译会在loaders中提到）。首先我们写两个最简单的js\n**hello.js**\n```\nconsole.log(\"hello~~\")\n```\n**app.js**\n```\nconsole.log(\"hello app\");\nrequire(\"./hello.js\")\n```\n`app.js`中导入了`hello.js`，它们之间有导入关系。我们假如直接将`app.js`放到html中是会报错的。\n```\nhello app\nUncaught ReferenceError: require is not defined at app.js:2\n```\n如果我们要维持这种关系我们就必须使用打包工具进行打包。在命令行中输入：\n```\n// 安装webpack\n$ npm install webpack -g\n// 打包app.js\n$ webpack app.js bundle.js\n```\n然后我们会发现项目中多了一个bundle.js文件，我们在html中导入这个js文件。\n**index.html**\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>demo01</title>\n  </head>\n  <body>\n    <h1>demo01</h1>\n    <script src=\"bundle.js\"></script>\n  </body>\n</html>\n```\n最后输出正确结果\n```\nhello app\nhello~~\n```\n# 二、webpack.config.js\n## 1. 定义\nwebpack.config.js文件是webpack的默认配置文件。之前我们使用命令行`$ webpack entry.js output.js`来实现打包，其实webpack可以有更多的打包配置，这些配置都是在webpack.config.js中完成的。下面是一个简单的webpack.config.js。\n```\nconst webpack = require(\"webpack\")\n\nmodule.exports = {\n  entry: {\n    entry: \"./app/entry.js\",\n  },\n  output:\n  {\n    path: __dirname + \"/dist\",\n    filename: 'bundle.js',\n  },\n  module: {\n    loaders: [\n      {\n        test: /\\.js$/,\n        loader: 'babel',\n        exclude: /node_modules/\n      },\n    ]\n  }\n}\n```\n个人觉得这三个东西是最最重要的了，所以必须单独说说这三个配置。其他配置都可以去查阅资料慢慢来。\n## 2. entry&output\nentry是配置webpack的入口文件，上面的代码中我们将app目录下的entry.js作为入口文件。webpack会将与entry.js有关的资源都进行打包。\noutput是出口文件，即打包好的文件的存放地址和文件名。\n\n这里有几种文件的输入输出情况。引用自[Webpack 2 入门教程](https://llp0574.github.io/2016/11/29/getting-started-with-webpack2/)。\n### 2.1 单文件，单输出\n```\nconst webpack = require(\"webpack\");\nmodule.exports = {\n  context: __dirname + \"/src\",\n  entry: {\n    app: \"./app.js\",\n  },\n  output: {\n    path: __dirname + \"/dist\",\n    filename: \"[name].bundle.js\",\n  },\n};\n```\n### 2.2 多文件，单输出\n```\nconst webpack = require(\"webpack\");\nmodule.exports = {\n  context: __dirname + \"/src\",\n  entry: {\n    app: [\"./home.js\", \"./events.js\", \"./vendor.js\"],\n  },\n  output: {\n    path: __dirname + \"/dist\",\n    filename: \"[name].bundle.js\",\n  },\n};\n```\n### 2.3 多文件，多输出\n```\nconst webpack = require(\"webpack\");\nmodule.exports = {\n  context: __dirname + \"/src\",\n  entry: {\n    home: \"./home.js\",\n    events: \"./events.js\",\n    contact: \"./contact.js\",\n  },\n  output: {\n    path: __dirname + \"/dist\",\n    filename: \"[name].bundle.js\",\n  },\n};\n```\n大家可以动手实践一下，很好理解。打包出来的单个或者多个文件直接可以在html中使用。\n```\n<script src=\"./dist/entry.js\"></script>\n```\n## 3. loaders\nloader是webpack的加载器，可以帮我们处理各种非js文件。如css样式，vue、jsx、weex等后缀的代码，JPG、PNG图片等。所以我们一般会在package.json中看到各种***-loader。这些就是各类资源的loader加载器。\n在module的loaders数组中可以有多个对象，每个对象就是一个加载器。下面是babel-loader的最简单配置方式\n```\n  module: {\n    loaders: [\n      {\n        test: /\\.js$/,\n        loader: 'babel',\n      },\n    ]\n  }\n```\n对象中的test是正则表达式，用于搜索后缀为.js的文件。loader是所用加载器名称。\n## 4. 使用babel来转译ES6代码\n下面我们来一步步使用babel-loader将ES6语法用于项目中。\nwebpack打包的文件默认是不支持ES6的，我们需要用babel转译。\n### 4.1 安装babel\n这个配置其实我是抄的vue-cli，个人对babel用法还不是很熟。\n在package.json中添加依赖。\n```\n  \"devDependencies\": {\n    ...\n    \"babel-core\": \"^6.22.1\",\n    \"babel-loader\": \"^6.2.10\",\n    \"babel-plugin-transform-runtime\": \"^6.22.0\",\n    \"babel-preset-es2015\": \"^6.0.0\",\n    \"babel-preset-stage-2\": \"^6.0.0\",\n    \"babel-register\": \"^6.0.0\",\n    \"webpack\": \"^1.14.0\"\n    ...\n  }\n```\nnpm安装\n```\n$ npm install\n```\n### 4.2 在webpack.config.js中添加babel-loader的配置\n```\n  module: {\n    loaders: [\n      {\n        test: /\\.js$/,\n        loader: 'babel',\n      },\n    ]\n  }\n```\n### 4.3 添加.babelrc\n在项目根目录下添加.babelrc文件，文件内容为\n```\n{\n  \"presets\": [\"es2015\", \"stage-2\"],\n  \"plugins\": [\"transform-runtime\"],\n  \"comments\": false\n}\n```\n### 4.4 使用ES6\n```\nimport good from './good.js'\n```\n# 三、分析vue-cli\n说了这么多，我的最终目的还是为了学习Vue.js。所以在对webpack有了一定的理解之后，就发现其实vue-cli并不是那么深不可测。\n## 1. 结构分析\n\n* build —— 项目构建文件夹\n * build.js —— 打包构建脚本（npm run build）\n * check-versions.js —— npm和node版本的查询\n * dev-client.js —— \n * dev-server.js —— 开发调试脚本（npm run dev）\n * utils.js —— 工具类\n * webpack.base.config.js —— Webpack配置文件\n * webpack.dev.config.js —— 开发版本Webpack配置文件，与webpack.base.config.js合并成完整的配置文件。\n * webpack.prod.config.js —— 生产版本Webpack配置文件，与webpack.base.config.js合并成完整的配置文件。\n* config —— 配置文件夹，保存有各种配置参数（文件路径、服务器端口、功能开关）\n* src —— 代码文件夹\n* static\n * .gitkeep —— 作用是将文件所在文件夹保留在git版本控制中。文件类型和.gitignore差不多。\n* .babelrc —— babel配置文件\n* .editorconfig —— 编辑配置，确保使用各种编辑器时能有相同的编辑格式。\n* .gitignore —— git忽略文件\n* index.html —— 页面，最终显示在这个html中\n* package.json —— npm配置文件，包含了项目的信息、脚本、依赖库等重要信息。\n\n## 2. 创建简易cli\n理解完vue-cli的某些功能后，不难发现我们自己也可以搭建简易的vue-cli了。\n官方的脚手架中除了有webpack打包，还包含了node脚本、开发和生产模式的切换、ESLint配置等功能。我们暂时不需要，将项目简化来更好的理解webpack。\n### 2.1 package.json\n让我们来自己建立一个cli，首先创建一个空文件夹。\n```\n$ mkdir demo05\n$ cd demo05\n```\n初始化npm\n```\n$ npm init\n```\n然后复制vue-cli中的依赖库到package.json中（直接复制啦，具体依赖库的作用就不提啦~之后会写博客补上的）。\n```\n  \"dependencies\": {\n    \"vue\": \"^2.1.0\"\n  },\n  \"devDependencies\": {\n    \"autoprefixer\": \"^6.4.0\",\n    \"babel-core\": \"^6.0.0\",\n    \"babel-loader\": \"^6.0.0\",\n    \"babel-plugin-transform-runtime\": \"^6.0.0\",\n    \"babel-preset-es2015\": \"^6.0.0\",\n    \"babel-preset-stage-2\": \"^6.0.0\",\n    \"babel-register\": \"^6.0.0\",\n    \"chalk\": \"^1.1.3\",\n    \"connect-history-api-fallback\": \"^1.1.0\",\n    \"css-loader\": \"^0.25.0\",\n    \"eventsource-polyfill\": \"^0.9.6\",\n    \"express\": \"^4.13.3\",\n    \"extract-text-webpack-plugin\": \"^1.0.1\",\n    \"file-loader\": \"^0.9.0\",\n    \"friendly-errors-webpack-plugin\": \"^1.1.2\",\n    \"function-bind\": \"^1.0.2\",\n    \"html-webpack-plugin\": \"^2.8.1\",\n    \"http-proxy-middleware\": \"^0.17.2\",\n    \"json-loader\": \"^0.5.4\",\n    \"semver\": \"^5.3.0\",\n    \"opn\": \"^4.0.2\",\n    \"ora\": \"^0.3.0\",\n    \"shelljs\": \"^0.7.4\",\n    \"url-loader\": \"^0.5.7\",\n    \"vue-loader\": \"^10.0.0\",\n    \"vue-style-loader\": \"^1.0.0\",\n    \"vue-template-compiler\": \"^2.1.0\",\n    \"webpack\": \"^1.13.2\",\n    \"webpack-dev-middleware\": \"^1.8.3\",\n    \"webpack-hot-middleware\": \"^2.12.2\",\n    \"webpack-merge\": \"^0.14.1\"\n  },\n```\n### 2.2 webpack.config.js\n这里的webpack配置文件中的部分内容是从官方的 `webpack.base.config.js` 中复制出来的。正如我项目结构中所说的，vue-cli中的 `webpack.base.config.js` 是基础的配置文件。vue-cli中的 `webpack.dev.config.js` 和 `webpack.prod.config.js` 分别代表了开发和生产版本的webpack配置文件，他们与 `webpack.base.config.js` 合并成最后的webpack配置文件。这里我们只要找到 `webpack.base.config.js` 即可。\n下面是完整配置代码。\n```\nvar path = require(\"path\")\nvar projectRoot = path.resolve(__dirname, '../')\n\nmodule.exports = {\n  // 入口文件\n  entry: \"./src/main.js\",\n  // 输出文件\n  output: {\n    filename: \"./dist/bundle.js\"\n  },\n  // 别名\n  resolve: {\n    extensions: ['', '.js', '.vue', '.json'],\n    fallback: [path.join(__dirname, '../node_modules')],\n    alias: {\n      'vue$': 'vue/dist/vue.common.js',\n      'src': path.resolve(__dirname, '../src'),\n      'assets': path.resolve(__dirname, '../src/assets'),\n      'components': path.resolve(__dirname, '../src/components')\n    }\n  },\n  module: {\n    // 加载器\n    loaders: [\n      {\n        test: /\\.vue$/,\n        loader: 'vue'\n      },\n      {\n        test: /\\.js$/,\n        loader: 'babel',\n        exclude: /node_modules/\n      },\n      {\n        test: /\\.json$/,\n        loader: 'json'\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: 'url',\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: 'url',\n      }\n    ]\n  },\n}\n```\n### 2.3 添加必要文件\n由于使用git、babel，所以我将vue-cli中的 `.gitignore` 和 `.babelrc` 直接复制过来。\n还有，由于懒得写逻辑代码，这里我将 `src` 文件夹中所有内容也直接复制过来。\n复制按成后进行webpack打包。\n```\n$ webpack\n```\n打包完成就会出现一个在 `dist` 目录下有一个 `bundle.js` 文件。有了打包文件，我们还需要创建一个 `index.html` 来显示效果，这个之后再说。\n所以，最后的项目结构如下图\n\n![项目结构](http://upload-images.jianshu.io/upload_images/1987062-b65832334ec76374.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 2.4 index.html\n现在，到了呈现效果的时候了。\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Demo3</title>\n  </head>\n  <body>\n    <div id=\"app\">\n    </div>\n    <script src=\"./dist/bundle.js\"></script>\n  </body>\n</html>\n```\n很简单，创建一个id为app的div元素用于显示Vue组件内容，然后将打包好的bundle.js引用进去。\n现在，到项目目录中找到 `index.html` 页面，浏览器打开就可以看到效果啦~\n\n![效果图](http://upload-images.jianshu.io/upload_images/1987062-9e3fd5985b12e67a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**注：**简易cli项目的源码在 VueStudyDemos\\WebpackDemos\\demo5中\n\n# 四、相关资料推荐\n这里推荐一下我学习webpack中发现的一些好的网站，分享一下。\nhttps://github.com/webpack-china/awesome-webpack-cn\nhttp://blog.guowenfh.com/2016/03/24/vue-webpack-01-base/\n\n# 写在最后\n拖了一个春节，终于把webpack的博客给写出来了。感觉在写完博客之后对webpack的理解深刻了许多，再次证明了“教是最好的学”这个理论。\n新的一年，我要坚持好好写博客，享受分享带来的快乐。\n之后计划学习一下eslint以及一些测试工具。然后试着用element和mint做两个小demo分享出来。然后了解一下node的相关知识。\n\n# Vue.js学习系列\n鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。\n\n[Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）](http://www.jianshu.com/p/8013d8d37bd0)\n[Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）](http://www.jianshu.com/p/d6f7e11f18af)\n[Vue.js学习系列三 —— axios和网络传输相关知识的学习实践](http://www.jianshu.com/p/8e5fb763c3d7)\n[Vue.js学习系列四 —— Webpack打包工具的使用](http://www.jianshu.com/p/aef34acd111f)\n[Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint](http://www.jianshu.com/p/efb6fbed6fac)\n[Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记](http://www.jianshu.com/p/073d25a3bba0)\n[Vue.js学习系列七 —— Vue服务器渲染Nuxt学习](https://www.jianshu.com/p/ba7466d7101a)\n[Vue.js学习系列八 —— Vue源码学习之State学习](https://www.jianshu.com/p/15028f91226e)\n\n# Vue.js学习系列项目地址\n本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。\n[https://github.com/violetjack/VueStudyDemos](https://github.com/violetjack/VueStudyDemos)\n\n# 关于作者\nVioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。\n欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。\n\n新浪微博： http://weibo.com/u/2640909603\n掘金：https://gold.xitu.io/user/571d953d39b0570068145cd1\nCSDN: http://blog.csdn.net/violetjack0808\n简书： http://www.jianshu.com/users/54ae4af3a98d/latest_articles\nGithub： https://github.com/violetjack","source":"_posts/Vue.js学习系列四 —— Webpack学习实践.md","raw":"---\ntitle: Vue.js学习系列四 —— Webpack学习实践\ndate: 2017-02-07\n---\n\n> 这两周一直想写webpack的知识点，却发现webpack其实要将webpack说的具体内容还是挺多的。而且稀土掘金上一搜webpack有好多人都有去写webpack的知识点，所以本文中不再去重复别人的东西了，就简单记录一下我对webpack的理解。并按照老规矩附上demo以及我收藏的几篇不错的webpack入门文章以供学习参考~\n\n# 一、什么是webpack\n## 1. webpack是什么？\nwebpack是一个模块打包工具。\n**用vue项目来举例：**浏览器它是只认识js，不认识vue的。而我们写的代码后缀大多是.vue的，在每个.vue文件中都可能html、js、css甚至是图片资源；并且由于组件化，这些.vue文件之间还有错综复杂的关系。所以项目要被浏览器识别，我们就要使用webpack将它们打包成js文件以及相应的资源文件。\n或者这么理解，我们以vue项目的形式编写项目逻辑，浏览器以他理解的方式来运行项目。webpack把我们的vue项目想表达的所有意图传递给浏览器让浏览器去运行。\n*PS：webpack功能不止于此，但这个功能是让我们项目能跑起来的必要条件！（个人理解，如有错误，还请批评指正）*\n## 2. 来个demo理解下\n这里我们来理解下webpack是如何打包的~（转译会在loaders中提到）。首先我们写两个最简单的js\n**hello.js**\n```\nconsole.log(\"hello~~\")\n```\n**app.js**\n```\nconsole.log(\"hello app\");\nrequire(\"./hello.js\")\n```\n`app.js`中导入了`hello.js`，它们之间有导入关系。我们假如直接将`app.js`放到html中是会报错的。\n```\nhello app\nUncaught ReferenceError: require is not defined at app.js:2\n```\n如果我们要维持这种关系我们就必须使用打包工具进行打包。在命令行中输入：\n```\n// 安装webpack\n$ npm install webpack -g\n// 打包app.js\n$ webpack app.js bundle.js\n```\n然后我们会发现项目中多了一个bundle.js文件，我们在html中导入这个js文件。\n**index.html**\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>demo01</title>\n  </head>\n  <body>\n    <h1>demo01</h1>\n    <script src=\"bundle.js\"></script>\n  </body>\n</html>\n```\n最后输出正确结果\n```\nhello app\nhello~~\n```\n# 二、webpack.config.js\n## 1. 定义\nwebpack.config.js文件是webpack的默认配置文件。之前我们使用命令行`$ webpack entry.js output.js`来实现打包，其实webpack可以有更多的打包配置，这些配置都是在webpack.config.js中完成的。下面是一个简单的webpack.config.js。\n```\nconst webpack = require(\"webpack\")\n\nmodule.exports = {\n  entry: {\n    entry: \"./app/entry.js\",\n  },\n  output:\n  {\n    path: __dirname + \"/dist\",\n    filename: 'bundle.js',\n  },\n  module: {\n    loaders: [\n      {\n        test: /\\.js$/,\n        loader: 'babel',\n        exclude: /node_modules/\n      },\n    ]\n  }\n}\n```\n个人觉得这三个东西是最最重要的了，所以必须单独说说这三个配置。其他配置都可以去查阅资料慢慢来。\n## 2. entry&output\nentry是配置webpack的入口文件，上面的代码中我们将app目录下的entry.js作为入口文件。webpack会将与entry.js有关的资源都进行打包。\noutput是出口文件，即打包好的文件的存放地址和文件名。\n\n这里有几种文件的输入输出情况。引用自[Webpack 2 入门教程](https://llp0574.github.io/2016/11/29/getting-started-with-webpack2/)。\n### 2.1 单文件，单输出\n```\nconst webpack = require(\"webpack\");\nmodule.exports = {\n  context: __dirname + \"/src\",\n  entry: {\n    app: \"./app.js\",\n  },\n  output: {\n    path: __dirname + \"/dist\",\n    filename: \"[name].bundle.js\",\n  },\n};\n```\n### 2.2 多文件，单输出\n```\nconst webpack = require(\"webpack\");\nmodule.exports = {\n  context: __dirname + \"/src\",\n  entry: {\n    app: [\"./home.js\", \"./events.js\", \"./vendor.js\"],\n  },\n  output: {\n    path: __dirname + \"/dist\",\n    filename: \"[name].bundle.js\",\n  },\n};\n```\n### 2.3 多文件，多输出\n```\nconst webpack = require(\"webpack\");\nmodule.exports = {\n  context: __dirname + \"/src\",\n  entry: {\n    home: \"./home.js\",\n    events: \"./events.js\",\n    contact: \"./contact.js\",\n  },\n  output: {\n    path: __dirname + \"/dist\",\n    filename: \"[name].bundle.js\",\n  },\n};\n```\n大家可以动手实践一下，很好理解。打包出来的单个或者多个文件直接可以在html中使用。\n```\n<script src=\"./dist/entry.js\"></script>\n```\n## 3. loaders\nloader是webpack的加载器，可以帮我们处理各种非js文件。如css样式，vue、jsx、weex等后缀的代码，JPG、PNG图片等。所以我们一般会在package.json中看到各种***-loader。这些就是各类资源的loader加载器。\n在module的loaders数组中可以有多个对象，每个对象就是一个加载器。下面是babel-loader的最简单配置方式\n```\n  module: {\n    loaders: [\n      {\n        test: /\\.js$/,\n        loader: 'babel',\n      },\n    ]\n  }\n```\n对象中的test是正则表达式，用于搜索后缀为.js的文件。loader是所用加载器名称。\n## 4. 使用babel来转译ES6代码\n下面我们来一步步使用babel-loader将ES6语法用于项目中。\nwebpack打包的文件默认是不支持ES6的，我们需要用babel转译。\n### 4.1 安装babel\n这个配置其实我是抄的vue-cli，个人对babel用法还不是很熟。\n在package.json中添加依赖。\n```\n  \"devDependencies\": {\n    ...\n    \"babel-core\": \"^6.22.1\",\n    \"babel-loader\": \"^6.2.10\",\n    \"babel-plugin-transform-runtime\": \"^6.22.0\",\n    \"babel-preset-es2015\": \"^6.0.0\",\n    \"babel-preset-stage-2\": \"^6.0.0\",\n    \"babel-register\": \"^6.0.0\",\n    \"webpack\": \"^1.14.0\"\n    ...\n  }\n```\nnpm安装\n```\n$ npm install\n```\n### 4.2 在webpack.config.js中添加babel-loader的配置\n```\n  module: {\n    loaders: [\n      {\n        test: /\\.js$/,\n        loader: 'babel',\n      },\n    ]\n  }\n```\n### 4.3 添加.babelrc\n在项目根目录下添加.babelrc文件，文件内容为\n```\n{\n  \"presets\": [\"es2015\", \"stage-2\"],\n  \"plugins\": [\"transform-runtime\"],\n  \"comments\": false\n}\n```\n### 4.4 使用ES6\n```\nimport good from './good.js'\n```\n# 三、分析vue-cli\n说了这么多，我的最终目的还是为了学习Vue.js。所以在对webpack有了一定的理解之后，就发现其实vue-cli并不是那么深不可测。\n## 1. 结构分析\n\n* build —— 项目构建文件夹\n * build.js —— 打包构建脚本（npm run build）\n * check-versions.js —— npm和node版本的查询\n * dev-client.js —— \n * dev-server.js —— 开发调试脚本（npm run dev）\n * utils.js —— 工具类\n * webpack.base.config.js —— Webpack配置文件\n * webpack.dev.config.js —— 开发版本Webpack配置文件，与webpack.base.config.js合并成完整的配置文件。\n * webpack.prod.config.js —— 生产版本Webpack配置文件，与webpack.base.config.js合并成完整的配置文件。\n* config —— 配置文件夹，保存有各种配置参数（文件路径、服务器端口、功能开关）\n* src —— 代码文件夹\n* static\n * .gitkeep —— 作用是将文件所在文件夹保留在git版本控制中。文件类型和.gitignore差不多。\n* .babelrc —— babel配置文件\n* .editorconfig —— 编辑配置，确保使用各种编辑器时能有相同的编辑格式。\n* .gitignore —— git忽略文件\n* index.html —— 页面，最终显示在这个html中\n* package.json —— npm配置文件，包含了项目的信息、脚本、依赖库等重要信息。\n\n## 2. 创建简易cli\n理解完vue-cli的某些功能后，不难发现我们自己也可以搭建简易的vue-cli了。\n官方的脚手架中除了有webpack打包，还包含了node脚本、开发和生产模式的切换、ESLint配置等功能。我们暂时不需要，将项目简化来更好的理解webpack。\n### 2.1 package.json\n让我们来自己建立一个cli，首先创建一个空文件夹。\n```\n$ mkdir demo05\n$ cd demo05\n```\n初始化npm\n```\n$ npm init\n```\n然后复制vue-cli中的依赖库到package.json中（直接复制啦，具体依赖库的作用就不提啦~之后会写博客补上的）。\n```\n  \"dependencies\": {\n    \"vue\": \"^2.1.0\"\n  },\n  \"devDependencies\": {\n    \"autoprefixer\": \"^6.4.0\",\n    \"babel-core\": \"^6.0.0\",\n    \"babel-loader\": \"^6.0.0\",\n    \"babel-plugin-transform-runtime\": \"^6.0.0\",\n    \"babel-preset-es2015\": \"^6.0.0\",\n    \"babel-preset-stage-2\": \"^6.0.0\",\n    \"babel-register\": \"^6.0.0\",\n    \"chalk\": \"^1.1.3\",\n    \"connect-history-api-fallback\": \"^1.1.0\",\n    \"css-loader\": \"^0.25.0\",\n    \"eventsource-polyfill\": \"^0.9.6\",\n    \"express\": \"^4.13.3\",\n    \"extract-text-webpack-plugin\": \"^1.0.1\",\n    \"file-loader\": \"^0.9.0\",\n    \"friendly-errors-webpack-plugin\": \"^1.1.2\",\n    \"function-bind\": \"^1.0.2\",\n    \"html-webpack-plugin\": \"^2.8.1\",\n    \"http-proxy-middleware\": \"^0.17.2\",\n    \"json-loader\": \"^0.5.4\",\n    \"semver\": \"^5.3.0\",\n    \"opn\": \"^4.0.2\",\n    \"ora\": \"^0.3.0\",\n    \"shelljs\": \"^0.7.4\",\n    \"url-loader\": \"^0.5.7\",\n    \"vue-loader\": \"^10.0.0\",\n    \"vue-style-loader\": \"^1.0.0\",\n    \"vue-template-compiler\": \"^2.1.0\",\n    \"webpack\": \"^1.13.2\",\n    \"webpack-dev-middleware\": \"^1.8.3\",\n    \"webpack-hot-middleware\": \"^2.12.2\",\n    \"webpack-merge\": \"^0.14.1\"\n  },\n```\n### 2.2 webpack.config.js\n这里的webpack配置文件中的部分内容是从官方的 `webpack.base.config.js` 中复制出来的。正如我项目结构中所说的，vue-cli中的 `webpack.base.config.js` 是基础的配置文件。vue-cli中的 `webpack.dev.config.js` 和 `webpack.prod.config.js` 分别代表了开发和生产版本的webpack配置文件，他们与 `webpack.base.config.js` 合并成最后的webpack配置文件。这里我们只要找到 `webpack.base.config.js` 即可。\n下面是完整配置代码。\n```\nvar path = require(\"path\")\nvar projectRoot = path.resolve(__dirname, '../')\n\nmodule.exports = {\n  // 入口文件\n  entry: \"./src/main.js\",\n  // 输出文件\n  output: {\n    filename: \"./dist/bundle.js\"\n  },\n  // 别名\n  resolve: {\n    extensions: ['', '.js', '.vue', '.json'],\n    fallback: [path.join(__dirname, '../node_modules')],\n    alias: {\n      'vue$': 'vue/dist/vue.common.js',\n      'src': path.resolve(__dirname, '../src'),\n      'assets': path.resolve(__dirname, '../src/assets'),\n      'components': path.resolve(__dirname, '../src/components')\n    }\n  },\n  module: {\n    // 加载器\n    loaders: [\n      {\n        test: /\\.vue$/,\n        loader: 'vue'\n      },\n      {\n        test: /\\.js$/,\n        loader: 'babel',\n        exclude: /node_modules/\n      },\n      {\n        test: /\\.json$/,\n        loader: 'json'\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: 'url',\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: 'url',\n      }\n    ]\n  },\n}\n```\n### 2.3 添加必要文件\n由于使用git、babel，所以我将vue-cli中的 `.gitignore` 和 `.babelrc` 直接复制过来。\n还有，由于懒得写逻辑代码，这里我将 `src` 文件夹中所有内容也直接复制过来。\n复制按成后进行webpack打包。\n```\n$ webpack\n```\n打包完成就会出现一个在 `dist` 目录下有一个 `bundle.js` 文件。有了打包文件，我们还需要创建一个 `index.html` 来显示效果，这个之后再说。\n所以，最后的项目结构如下图\n\n![项目结构](http://upload-images.jianshu.io/upload_images/1987062-b65832334ec76374.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 2.4 index.html\n现在，到了呈现效果的时候了。\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Demo3</title>\n  </head>\n  <body>\n    <div id=\"app\">\n    </div>\n    <script src=\"./dist/bundle.js\"></script>\n  </body>\n</html>\n```\n很简单，创建一个id为app的div元素用于显示Vue组件内容，然后将打包好的bundle.js引用进去。\n现在，到项目目录中找到 `index.html` 页面，浏览器打开就可以看到效果啦~\n\n![效果图](http://upload-images.jianshu.io/upload_images/1987062-9e3fd5985b12e67a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**注：**简易cli项目的源码在 VueStudyDemos\\WebpackDemos\\demo5中\n\n# 四、相关资料推荐\n这里推荐一下我学习webpack中发现的一些好的网站，分享一下。\nhttps://github.com/webpack-china/awesome-webpack-cn\nhttp://blog.guowenfh.com/2016/03/24/vue-webpack-01-base/\n\n# 写在最后\n拖了一个春节，终于把webpack的博客给写出来了。感觉在写完博客之后对webpack的理解深刻了许多，再次证明了“教是最好的学”这个理论。\n新的一年，我要坚持好好写博客，享受分享带来的快乐。\n之后计划学习一下eslint以及一些测试工具。然后试着用element和mint做两个小demo分享出来。然后了解一下node的相关知识。\n\n# Vue.js学习系列\n鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。\n\n[Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）](http://www.jianshu.com/p/8013d8d37bd0)\n[Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）](http://www.jianshu.com/p/d6f7e11f18af)\n[Vue.js学习系列三 —— axios和网络传输相关知识的学习实践](http://www.jianshu.com/p/8e5fb763c3d7)\n[Vue.js学习系列四 —— Webpack打包工具的使用](http://www.jianshu.com/p/aef34acd111f)\n[Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint](http://www.jianshu.com/p/efb6fbed6fac)\n[Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记](http://www.jianshu.com/p/073d25a3bba0)\n[Vue.js学习系列七 —— Vue服务器渲染Nuxt学习](https://www.jianshu.com/p/ba7466d7101a)\n[Vue.js学习系列八 —— Vue源码学习之State学习](https://www.jianshu.com/p/15028f91226e)\n\n# Vue.js学习系列项目地址\n本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。\n[https://github.com/violetjack/VueStudyDemos](https://github.com/violetjack/VueStudyDemos)\n\n# 关于作者\nVioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。\n欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。\n\n新浪微博： http://weibo.com/u/2640909603\n掘金：https://gold.xitu.io/user/571d953d39b0570068145cd1\nCSDN: http://blog.csdn.net/violetjack0808\n简书： http://www.jianshu.com/users/54ae4af3a98d/latest_articles\nGithub： https://github.com/violetjack","slug":"Vue.js学习系列四 —— Webpack学习实践","published":1,"updated":"2018-02-07T02:30:05.597Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjddwxbma000ai8btfom3a8af","content":"<blockquote>\n<p>这两周一直想写webpack的知识点，却发现webpack其实要将webpack说的具体内容还是挺多的。而且稀土掘金上一搜webpack有好多人都有去写webpack的知识点，所以本文中不再去重复别人的东西了，就简单记录一下我对webpack的理解。并按照老规矩附上demo以及我收藏的几篇不错的webpack入门文章以供学习参考~</p>\n</blockquote>\n<h1 id=\"一、什么是webpack\"><a href=\"#一、什么是webpack\" class=\"headerlink\" title=\"一、什么是webpack\"></a>一、什么是webpack</h1><h2 id=\"1-webpack是什么？\"><a href=\"#1-webpack是什么？\" class=\"headerlink\" title=\"1. webpack是什么？\"></a>1. webpack是什么？</h2><p>webpack是一个模块打包工具。<br><strong>用vue项目来举例：</strong>浏览器它是只认识js，不认识vue的。而我们写的代码后缀大多是.vue的，在每个.vue文件中都可能html、js、css甚至是图片资源；并且由于组件化，这些.vue文件之间还有错综复杂的关系。所以项目要被浏览器识别，我们就要使用webpack将它们打包成js文件以及相应的资源文件。<br>或者这么理解，我们以vue项目的形式编写项目逻辑，浏览器以他理解的方式来运行项目。webpack把我们的vue项目想表达的所有意图传递给浏览器让浏览器去运行。<br><em>PS：webpack功能不止于此，但这个功能是让我们项目能跑起来的必要条件！（个人理解，如有错误，还请批评指正）</em></p>\n<h2 id=\"2-来个demo理解下\"><a href=\"#2-来个demo理解下\" class=\"headerlink\" title=\"2. 来个demo理解下\"></a>2. 来个demo理解下</h2><p>这里我们来理解下webpack是如何打包的~（转译会在loaders中提到）。首先我们写两个最简单的js<br><strong>hello.js</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&quot;hello~~&quot;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>app.js</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&quot;hello app&quot;);</span><br><span class=\"line\">require(&quot;./hello.js&quot;)</span><br></pre></td></tr></table></figure></p>\n<p><code>app.js</code>中导入了<code>hello.js</code>，它们之间有导入关系。我们假如直接将<code>app.js</code>放到html中是会报错的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello app</span><br><span class=\"line\">Uncaught ReferenceError: require is not defined at app.js:2</span><br></pre></td></tr></table></figure></p>\n<p>如果我们要维持这种关系我们就必须使用打包工具进行打包。在命令行中输入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 安装webpack</span><br><span class=\"line\">$ npm install webpack -g</span><br><span class=\"line\">// 打包app.js</span><br><span class=\"line\">$ webpack app.js bundle.js</span><br></pre></td></tr></table></figure></p>\n<p>然后我们会发现项目中多了一个bundle.js文件，我们在html中导入这个js文件。<br><strong>index.html</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;demo01&lt;/title&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;h1&gt;demo01&lt;/h1&gt;</span><br><span class=\"line\">    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>最后输出正确结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello app</span><br><span class=\"line\">hello~~</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"二、webpack-config-js\"><a href=\"#二、webpack-config-js\" class=\"headerlink\" title=\"二、webpack.config.js\"></a>二、webpack.config.js</h1><h2 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h2><p>webpack.config.js文件是webpack的默认配置文件。之前我们使用命令行<code>$ webpack entry.js output.js</code>来实现打包，其实webpack可以有更多的打包配置，这些配置都是在webpack.config.js中完成的。下面是一个简单的webpack.config.js。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const webpack = require(&quot;webpack&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    entry: &quot;./app/entry.js&quot;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output:</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: __dirname + &quot;/dist&quot;,</span><br><span class=\"line\">    filename: &apos;bundle.js&apos;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    loaders: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.js$/,</span><br><span class=\"line\">        loader: &apos;babel&apos;,</span><br><span class=\"line\">        exclude: /node_modules/</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>个人觉得这三个东西是最最重要的了，所以必须单独说说这三个配置。其他配置都可以去查阅资料慢慢来。</p>\n<h2 id=\"2-entry-amp-output\"><a href=\"#2-entry-amp-output\" class=\"headerlink\" title=\"2. entry&amp;output\"></a>2. entry&amp;output</h2><p>entry是配置webpack的入口文件，上面的代码中我们将app目录下的entry.js作为入口文件。webpack会将与entry.js有关的资源都进行打包。<br>output是出口文件，即打包好的文件的存放地址和文件名。</p>\n<p>这里有几种文件的输入输出情况。引用自<a href=\"https://llp0574.github.io/2016/11/29/getting-started-with-webpack2/\" target=\"_blank\" rel=\"noopener\">Webpack 2 入门教程</a>。</p>\n<h3 id=\"2-1-单文件，单输出\"><a href=\"#2-1-单文件，单输出\" class=\"headerlink\" title=\"2.1 单文件，单输出\"></a>2.1 单文件，单输出</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const webpack = require(&quot;webpack&quot;);</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  context: __dirname + &quot;/src&quot;,</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    app: &quot;./app.js&quot;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: __dirname + &quot;/dist&quot;,</span><br><span class=\"line\">    filename: &quot;[name].bundle.js&quot;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-多文件，单输出\"><a href=\"#2-2-多文件，单输出\" class=\"headerlink\" title=\"2.2 多文件，单输出\"></a>2.2 多文件，单输出</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const webpack = require(&quot;webpack&quot;);</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  context: __dirname + &quot;/src&quot;,</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    app: [&quot;./home.js&quot;, &quot;./events.js&quot;, &quot;./vendor.js&quot;],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: __dirname + &quot;/dist&quot;,</span><br><span class=\"line\">    filename: &quot;[name].bundle.js&quot;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-多文件，多输出\"><a href=\"#2-3-多文件，多输出\" class=\"headerlink\" title=\"2.3 多文件，多输出\"></a>2.3 多文件，多输出</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const webpack = require(&quot;webpack&quot;);</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  context: __dirname + &quot;/src&quot;,</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    home: &quot;./home.js&quot;,</span><br><span class=\"line\">    events: &quot;./events.js&quot;,</span><br><span class=\"line\">    contact: &quot;./contact.js&quot;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: __dirname + &quot;/dist&quot;,</span><br><span class=\"line\">    filename: &quot;[name].bundle.js&quot;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>大家可以动手实践一下，很好理解。打包出来的单个或者多个文件直接可以在html中使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;./dist/entry.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-loaders\"><a href=\"#3-loaders\" class=\"headerlink\" title=\"3. loaders\"></a>3. loaders</h2><p>loader是webpack的加载器，可以帮我们处理各种非js文件。如css样式，vue、jsx、weex等后缀的代码，JPG、PNG图片等。所以我们一般会在package.json中看到各种<em>*</em>-loader。这些就是各类资源的loader加载器。<br>在module的loaders数组中可以有多个对象，每个对象就是一个加载器。下面是babel-loader的最简单配置方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module: &#123;</span><br><span class=\"line\">  loaders: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      test: /\\.js$/,</span><br><span class=\"line\">      loader: &apos;babel&apos;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对象中的test是正则表达式，用于搜索后缀为.js的文件。loader是所用加载器名称。</p>\n<h2 id=\"4-使用babel来转译ES6代码\"><a href=\"#4-使用babel来转译ES6代码\" class=\"headerlink\" title=\"4. 使用babel来转译ES6代码\"></a>4. 使用babel来转译ES6代码</h2><p>下面我们来一步步使用babel-loader将ES6语法用于项目中。<br>webpack打包的文件默认是不支持ES6的，我们需要用babel转译。</p>\n<h3 id=\"4-1-安装babel\"><a href=\"#4-1-安装babel\" class=\"headerlink\" title=\"4.1 安装babel\"></a>4.1 安装babel</h3><p>这个配置其实我是抄的vue-cli，个人对babel用法还不是很熟。<br>在package.json中添加依赖。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &quot;babel-core&quot;: &quot;^6.22.1&quot;,</span><br><span class=\"line\">  &quot;babel-loader&quot;: &quot;^6.2.10&quot;,</span><br><span class=\"line\">  &quot;babel-plugin-transform-runtime&quot;: &quot;^6.22.0&quot;,</span><br><span class=\"line\">  &quot;babel-preset-es2015&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">  &quot;babel-preset-stage-2&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">  &quot;babel-register&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">  &quot;webpack&quot;: &quot;^1.14.0&quot;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>npm安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-2-在webpack-config-js中添加babel-loader的配置\"><a href=\"#4-2-在webpack-config-js中添加babel-loader的配置\" class=\"headerlink\" title=\"4.2 在webpack.config.js中添加babel-loader的配置\"></a>4.2 在webpack.config.js中添加babel-loader的配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module: &#123;</span><br><span class=\"line\">  loaders: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      test: /\\.js$/,</span><br><span class=\"line\">      loader: &apos;babel&apos;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-3-添加-babelrc\"><a href=\"#4-3-添加-babelrc\" class=\"headerlink\" title=\"4.3 添加.babelrc\"></a>4.3 添加.babelrc</h3><p>在项目根目录下添加.babelrc文件，文件内容为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-2&quot;],</span><br><span class=\"line\">  &quot;plugins&quot;: [&quot;transform-runtime&quot;],</span><br><span class=\"line\">  &quot;comments&quot;: false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-4-使用ES6\"><a href=\"#4-4-使用ES6\" class=\"headerlink\" title=\"4.4 使用ES6\"></a>4.4 使用ES6</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import good from &apos;./good.js&apos;</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、分析vue-cli\"><a href=\"#三、分析vue-cli\" class=\"headerlink\" title=\"三、分析vue-cli\"></a>三、分析vue-cli</h1><p>说了这么多，我的最终目的还是为了学习Vue.js。所以在对webpack有了一定的理解之后，就发现其实vue-cli并不是那么深不可测。</p>\n<h2 id=\"1-结构分析\"><a href=\"#1-结构分析\" class=\"headerlink\" title=\"1. 结构分析\"></a>1. 结构分析</h2><ul>\n<li>build —— 项目构建文件夹<ul>\n<li>build.js —— 打包构建脚本（npm run build）</li>\n<li>check-versions.js —— npm和node版本的查询</li>\n<li>dev-client.js —— </li>\n<li>dev-server.js —— 开发调试脚本（npm run dev）</li>\n<li>utils.js —— 工具类</li>\n<li>webpack.base.config.js —— Webpack配置文件</li>\n<li>webpack.dev.config.js —— 开发版本Webpack配置文件，与webpack.base.config.js合并成完整的配置文件。</li>\n<li>webpack.prod.config.js —— 生产版本Webpack配置文件，与webpack.base.config.js合并成完整的配置文件。</li>\n</ul>\n</li>\n<li>config —— 配置文件夹，保存有各种配置参数（文件路径、服务器端口、功能开关）</li>\n<li>src —— 代码文件夹</li>\n<li>static<ul>\n<li>.gitkeep —— 作用是将文件所在文件夹保留在git版本控制中。文件类型和.gitignore差不多。</li>\n</ul>\n</li>\n<li>.babelrc —— babel配置文件</li>\n<li>.editorconfig —— 编辑配置，确保使用各种编辑器时能有相同的编辑格式。</li>\n<li>.gitignore —— git忽略文件</li>\n<li>index.html —— 页面，最终显示在这个html中</li>\n<li>package.json —— npm配置文件，包含了项目的信息、脚本、依赖库等重要信息。</li>\n</ul>\n<h2 id=\"2-创建简易cli\"><a href=\"#2-创建简易cli\" class=\"headerlink\" title=\"2. 创建简易cli\"></a>2. 创建简易cli</h2><p>理解完vue-cli的某些功能后，不难发现我们自己也可以搭建简易的vue-cli了。<br>官方的脚手架中除了有webpack打包，还包含了node脚本、开发和生产模式的切换、ESLint配置等功能。我们暂时不需要，将项目简化来更好的理解webpack。</p>\n<h3 id=\"2-1-package-json\"><a href=\"#2-1-package-json\" class=\"headerlink\" title=\"2.1 package.json\"></a>2.1 package.json</h3><p>让我们来自己建立一个cli，首先创建一个空文件夹。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir demo05</span><br><span class=\"line\">$ cd demo05</span><br></pre></td></tr></table></figure></p>\n<p>初始化npm<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm init</span><br></pre></td></tr></table></figure></p>\n<p>然后复制vue-cli中的依赖库到package.json中（直接复制啦，具体依赖库的作用就不提啦~之后会写博客补上的）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;dependencies&quot;: &#123;</span><br><span class=\"line\">  &quot;vue&quot;: &quot;^2.1.0&quot;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">  &quot;autoprefixer&quot;: &quot;^6.4.0&quot;,</span><br><span class=\"line\">  &quot;babel-core&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">  &quot;babel-loader&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">  &quot;babel-plugin-transform-runtime&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">  &quot;babel-preset-es2015&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">  &quot;babel-preset-stage-2&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">  &quot;babel-register&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">  &quot;chalk&quot;: &quot;^1.1.3&quot;,</span><br><span class=\"line\">  &quot;connect-history-api-fallback&quot;: &quot;^1.1.0&quot;,</span><br><span class=\"line\">  &quot;css-loader&quot;: &quot;^0.25.0&quot;,</span><br><span class=\"line\">  &quot;eventsource-polyfill&quot;: &quot;^0.9.6&quot;,</span><br><span class=\"line\">  &quot;express&quot;: &quot;^4.13.3&quot;,</span><br><span class=\"line\">  &quot;extract-text-webpack-plugin&quot;: &quot;^1.0.1&quot;,</span><br><span class=\"line\">  &quot;file-loader&quot;: &quot;^0.9.0&quot;,</span><br><span class=\"line\">  &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.1.2&quot;,</span><br><span class=\"line\">  &quot;function-bind&quot;: &quot;^1.0.2&quot;,</span><br><span class=\"line\">  &quot;html-webpack-plugin&quot;: &quot;^2.8.1&quot;,</span><br><span class=\"line\">  &quot;http-proxy-middleware&quot;: &quot;^0.17.2&quot;,</span><br><span class=\"line\">  &quot;json-loader&quot;: &quot;^0.5.4&quot;,</span><br><span class=\"line\">  &quot;semver&quot;: &quot;^5.3.0&quot;,</span><br><span class=\"line\">  &quot;opn&quot;: &quot;^4.0.2&quot;,</span><br><span class=\"line\">  &quot;ora&quot;: &quot;^0.3.0&quot;,</span><br><span class=\"line\">  &quot;shelljs&quot;: &quot;^0.7.4&quot;,</span><br><span class=\"line\">  &quot;url-loader&quot;: &quot;^0.5.7&quot;,</span><br><span class=\"line\">  &quot;vue-loader&quot;: &quot;^10.0.0&quot;,</span><br><span class=\"line\">  &quot;vue-style-loader&quot;: &quot;^1.0.0&quot;,</span><br><span class=\"line\">  &quot;vue-template-compiler&quot;: &quot;^2.1.0&quot;,</span><br><span class=\"line\">  &quot;webpack&quot;: &quot;^1.13.2&quot;,</span><br><span class=\"line\">  &quot;webpack-dev-middleware&quot;: &quot;^1.8.3&quot;,</span><br><span class=\"line\">  &quot;webpack-hot-middleware&quot;: &quot;^2.12.2&quot;,</span><br><span class=\"line\">  &quot;webpack-merge&quot;: &quot;^0.14.1&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-2-webpack-config-js\"><a href=\"#2-2-webpack-config-js\" class=\"headerlink\" title=\"2.2 webpack.config.js\"></a>2.2 webpack.config.js</h3><p>这里的webpack配置文件中的部分内容是从官方的 <code>webpack.base.config.js</code> 中复制出来的。正如我项目结构中所说的，vue-cli中的 <code>webpack.base.config.js</code> 是基础的配置文件。vue-cli中的 <code>webpack.dev.config.js</code> 和 <code>webpack.prod.config.js</code> 分别代表了开发和生产版本的webpack配置文件，他们与 <code>webpack.base.config.js</code> 合并成最后的webpack配置文件。这里我们只要找到 <code>webpack.base.config.js</code> 即可。<br>下面是完整配置代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var path = require(&quot;path&quot;)</span><br><span class=\"line\">var projectRoot = path.resolve(__dirname, &apos;../&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 入口文件</span><br><span class=\"line\">  entry: &quot;./src/main.js&quot;,</span><br><span class=\"line\">  // 输出文件</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: &quot;./dist/bundle.js&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 别名</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],</span><br><span class=\"line\">    fallback: [path.join(__dirname, &apos;../node_modules&apos;)],</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">      &apos;vue$&apos;: &apos;vue/dist/vue.common.js&apos;,</span><br><span class=\"line\">      &apos;src&apos;: path.resolve(__dirname, &apos;../src&apos;),</span><br><span class=\"line\">      &apos;assets&apos;: path.resolve(__dirname, &apos;../src/assets&apos;),</span><br><span class=\"line\">      &apos;components&apos;: path.resolve(__dirname, &apos;../src/components&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    // 加载器</span><br><span class=\"line\">    loaders: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.vue$/,</span><br><span class=\"line\">        loader: &apos;vue&apos;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.js$/,</span><br><span class=\"line\">        loader: &apos;babel&apos;,</span><br><span class=\"line\">        exclude: /node_modules/</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.json$/,</span><br><span class=\"line\">        loader: &apos;json&apos;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,</span><br><span class=\"line\">        loader: &apos;url&apos;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,</span><br><span class=\"line\">        loader: &apos;url&apos;,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-3-添加必要文件\"><a href=\"#2-3-添加必要文件\" class=\"headerlink\" title=\"2.3 添加必要文件\"></a>2.3 添加必要文件</h3><p>由于使用git、babel，所以我将vue-cli中的 <code>.gitignore</code> 和 <code>.babelrc</code> 直接复制过来。<br>还有，由于懒得写逻辑代码，这里我将 <code>src</code> 文件夹中所有内容也直接复制过来。<br>复制按成后进行webpack打包。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br></pre></td></tr></table></figure></p>\n<p>打包完成就会出现一个在 <code>dist</code> 目录下有一个 <code>bundle.js</code> 文件。有了打包文件，我们还需要创建一个 <code>index.html</code> 来显示效果，这个之后再说。<br>所以，最后的项目结构如下图</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1987062-b65832334ec76374.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"项目结构\"></p>\n<h3 id=\"2-4-index-html\"><a href=\"#2-4-index-html\" class=\"headerlink\" title=\"2.4 index.html\"></a>2.4 index.html</h3><p>现在，到了呈现效果的时候了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Demo3&lt;/title&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>很简单，创建一个id为app的div元素用于显示Vue组件内容，然后将打包好的bundle.js引用进去。<br>现在，到项目目录中找到 <code>index.html</code> 页面，浏览器打开就可以看到效果啦~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1987062-9e3fd5985b12e67a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"效果图\"></p>\n<p><strong>注：</strong>简易cli项目的源码在 VueStudyDemos\\WebpackDemos\\demo5中</p>\n<h1 id=\"四、相关资料推荐\"><a href=\"#四、相关资料推荐\" class=\"headerlink\" title=\"四、相关资料推荐\"></a>四、相关资料推荐</h1><p>这里推荐一下我学习webpack中发现的一些好的网站，分享一下。<br><a href=\"https://github.com/webpack-china/awesome-webpack-cn\" target=\"_blank\" rel=\"noopener\">https://github.com/webpack-china/awesome-webpack-cn</a><br><a href=\"http://blog.guowenfh.com/2016/03/24/vue-webpack-01-base/\" target=\"_blank\" rel=\"noopener\">http://blog.guowenfh.com/2016/03/24/vue-webpack-01-base/</a></p>\n<h1 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h1><p>拖了一个春节，终于把webpack的博客给写出来了。感觉在写完博客之后对webpack的理解深刻了许多，再次证明了“教是最好的学”这个理论。<br>新的一年，我要坚持好好写博客，享受分享带来的快乐。<br>之后计划学习一下eslint以及一些测试工具。然后试着用element和mint做两个小demo分享出来。然后了解一下node的相关知识。</p>\n<h1 id=\"Vue-js学习系列\"><a href=\"#Vue-js学习系列\" class=\"headerlink\" title=\"Vue.js学习系列\"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>\n<p><a href=\"http://www.jianshu.com/p/8013d8d37bd0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/d6f7e11f18af\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/8e5fb763c3d7\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href=\"http://www.jianshu.com/p/aef34acd111f\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href=\"http://www.jianshu.com/p/efb6fbed6fac\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href=\"http://www.jianshu.com/p/073d25a3bba0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href=\"https://www.jianshu.com/p/ba7466d7101a\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href=\"https://www.jianshu.com/p/15028f91226e\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>\n<h1 id=\"Vue-js学习系列项目地址\"><a href=\"#Vue-js学习系列项目地址\" class=\"headerlink\" title=\"Vue.js学习系列项目地址\"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack/VueStudyDemos</a></p>\n<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>\n<p>新浪微博： <a href=\"http://weibo.com/u/2640909603\" target=\"_blank\" rel=\"noopener\">http://weibo.com/u/2640909603</a><br>掘金：<a href=\"https://gold.xitu.io/user/571d953d39b0570068145cd1\" target=\"_blank\" rel=\"noopener\">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href=\"http://blog.csdn.net/violetjack0808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/violetjack0808</a><br>简书： <a href=\"http://www.jianshu.com/users/54ae4af3a98d/latest_articles\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href=\"https://github.com/violetjack\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>这两周一直想写webpack的知识点，却发现webpack其实要将webpack说的具体内容还是挺多的。而且稀土掘金上一搜webpack有好多人都有去写webpack的知识点，所以本文中不再去重复别人的东西了，就简单记录一下我对webpack的理解。并按照老规矩附上demo以及我收藏的几篇不错的webpack入门文章以供学习参考~</p>\n</blockquote>\n<h1 id=\"一、什么是webpack\"><a href=\"#一、什么是webpack\" class=\"headerlink\" title=\"一、什么是webpack\"></a>一、什么是webpack</h1><h2 id=\"1-webpack是什么？\"><a href=\"#1-webpack是什么？\" class=\"headerlink\" title=\"1. webpack是什么？\"></a>1. webpack是什么？</h2><p>webpack是一个模块打包工具。<br><strong>用vue项目来举例：</strong>浏览器它是只认识js，不认识vue的。而我们写的代码后缀大多是.vue的，在每个.vue文件中都可能html、js、css甚至是图片资源；并且由于组件化，这些.vue文件之间还有错综复杂的关系。所以项目要被浏览器识别，我们就要使用webpack将它们打包成js文件以及相应的资源文件。<br>或者这么理解，我们以vue项目的形式编写项目逻辑，浏览器以他理解的方式来运行项目。webpack把我们的vue项目想表达的所有意图传递给浏览器让浏览器去运行。<br><em>PS：webpack功能不止于此，但这个功能是让我们项目能跑起来的必要条件！（个人理解，如有错误，还请批评指正）</em></p>\n<h2 id=\"2-来个demo理解下\"><a href=\"#2-来个demo理解下\" class=\"headerlink\" title=\"2. 来个demo理解下\"></a>2. 来个demo理解下</h2><p>这里我们来理解下webpack是如何打包的~（转译会在loaders中提到）。首先我们写两个最简单的js<br><strong>hello.js</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&quot;hello~~&quot;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>app.js</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&quot;hello app&quot;);</span><br><span class=\"line\">require(&quot;./hello.js&quot;)</span><br></pre></td></tr></table></figure></p>\n<p><code>app.js</code>中导入了<code>hello.js</code>，它们之间有导入关系。我们假如直接将<code>app.js</code>放到html中是会报错的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello app</span><br><span class=\"line\">Uncaught ReferenceError: require is not defined at app.js:2</span><br></pre></td></tr></table></figure></p>\n<p>如果我们要维持这种关系我们就必须使用打包工具进行打包。在命令行中输入：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 安装webpack</span><br><span class=\"line\">$ npm install webpack -g</span><br><span class=\"line\">// 打包app.js</span><br><span class=\"line\">$ webpack app.js bundle.js</span><br></pre></td></tr></table></figure></p>\n<p>然后我们会发现项目中多了一个bundle.js文件，我们在html中导入这个js文件。<br><strong>index.html</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;demo01&lt;/title&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;h1&gt;demo01&lt;/h1&gt;</span><br><span class=\"line\">    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>最后输出正确结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello app</span><br><span class=\"line\">hello~~</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"二、webpack-config-js\"><a href=\"#二、webpack-config-js\" class=\"headerlink\" title=\"二、webpack.config.js\"></a>二、webpack.config.js</h1><h2 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h2><p>webpack.config.js文件是webpack的默认配置文件。之前我们使用命令行<code>$ webpack entry.js output.js</code>来实现打包，其实webpack可以有更多的打包配置，这些配置都是在webpack.config.js中完成的。下面是一个简单的webpack.config.js。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const webpack = require(&quot;webpack&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    entry: &quot;./app/entry.js&quot;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output:</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: __dirname + &quot;/dist&quot;,</span><br><span class=\"line\">    filename: &apos;bundle.js&apos;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    loaders: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.js$/,</span><br><span class=\"line\">        loader: &apos;babel&apos;,</span><br><span class=\"line\">        exclude: /node_modules/</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>个人觉得这三个东西是最最重要的了，所以必须单独说说这三个配置。其他配置都可以去查阅资料慢慢来。</p>\n<h2 id=\"2-entry-amp-output\"><a href=\"#2-entry-amp-output\" class=\"headerlink\" title=\"2. entry&amp;output\"></a>2. entry&amp;output</h2><p>entry是配置webpack的入口文件，上面的代码中我们将app目录下的entry.js作为入口文件。webpack会将与entry.js有关的资源都进行打包。<br>output是出口文件，即打包好的文件的存放地址和文件名。</p>\n<p>这里有几种文件的输入输出情况。引用自<a href=\"https://llp0574.github.io/2016/11/29/getting-started-with-webpack2/\" target=\"_blank\" rel=\"noopener\">Webpack 2 入门教程</a>。</p>\n<h3 id=\"2-1-单文件，单输出\"><a href=\"#2-1-单文件，单输出\" class=\"headerlink\" title=\"2.1 单文件，单输出\"></a>2.1 单文件，单输出</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const webpack = require(&quot;webpack&quot;);</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  context: __dirname + &quot;/src&quot;,</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    app: &quot;./app.js&quot;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: __dirname + &quot;/dist&quot;,</span><br><span class=\"line\">    filename: &quot;[name].bundle.js&quot;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-多文件，单输出\"><a href=\"#2-2-多文件，单输出\" class=\"headerlink\" title=\"2.2 多文件，单输出\"></a>2.2 多文件，单输出</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const webpack = require(&quot;webpack&quot;);</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  context: __dirname + &quot;/src&quot;,</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    app: [&quot;./home.js&quot;, &quot;./events.js&quot;, &quot;./vendor.js&quot;],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: __dirname + &quot;/dist&quot;,</span><br><span class=\"line\">    filename: &quot;[name].bundle.js&quot;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-多文件，多输出\"><a href=\"#2-3-多文件，多输出\" class=\"headerlink\" title=\"2.3 多文件，多输出\"></a>2.3 多文件，多输出</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const webpack = require(&quot;webpack&quot;);</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  context: __dirname + &quot;/src&quot;,</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    home: &quot;./home.js&quot;,</span><br><span class=\"line\">    events: &quot;./events.js&quot;,</span><br><span class=\"line\">    contact: &quot;./contact.js&quot;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    path: __dirname + &quot;/dist&quot;,</span><br><span class=\"line\">    filename: &quot;[name].bundle.js&quot;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>大家可以动手实践一下，很好理解。打包出来的单个或者多个文件直接可以在html中使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;./dist/entry.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-loaders\"><a href=\"#3-loaders\" class=\"headerlink\" title=\"3. loaders\"></a>3. loaders</h2><p>loader是webpack的加载器，可以帮我们处理各种非js文件。如css样式，vue、jsx、weex等后缀的代码，JPG、PNG图片等。所以我们一般会在package.json中看到各种<em>*</em>-loader。这些就是各类资源的loader加载器。<br>在module的loaders数组中可以有多个对象，每个对象就是一个加载器。下面是babel-loader的最简单配置方式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module: &#123;</span><br><span class=\"line\">  loaders: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      test: /\\.js$/,</span><br><span class=\"line\">      loader: &apos;babel&apos;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对象中的test是正则表达式，用于搜索后缀为.js的文件。loader是所用加载器名称。</p>\n<h2 id=\"4-使用babel来转译ES6代码\"><a href=\"#4-使用babel来转译ES6代码\" class=\"headerlink\" title=\"4. 使用babel来转译ES6代码\"></a>4. 使用babel来转译ES6代码</h2><p>下面我们来一步步使用babel-loader将ES6语法用于项目中。<br>webpack打包的文件默认是不支持ES6的，我们需要用babel转译。</p>\n<h3 id=\"4-1-安装babel\"><a href=\"#4-1-安装babel\" class=\"headerlink\" title=\"4.1 安装babel\"></a>4.1 安装babel</h3><p>这个配置其实我是抄的vue-cli，个人对babel用法还不是很熟。<br>在package.json中添加依赖。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &quot;babel-core&quot;: &quot;^6.22.1&quot;,</span><br><span class=\"line\">  &quot;babel-loader&quot;: &quot;^6.2.10&quot;,</span><br><span class=\"line\">  &quot;babel-plugin-transform-runtime&quot;: &quot;^6.22.0&quot;,</span><br><span class=\"line\">  &quot;babel-preset-es2015&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">  &quot;babel-preset-stage-2&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">  &quot;babel-register&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">  &quot;webpack&quot;: &quot;^1.14.0&quot;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>npm安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-2-在webpack-config-js中添加babel-loader的配置\"><a href=\"#4-2-在webpack-config-js中添加babel-loader的配置\" class=\"headerlink\" title=\"4.2 在webpack.config.js中添加babel-loader的配置\"></a>4.2 在webpack.config.js中添加babel-loader的配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module: &#123;</span><br><span class=\"line\">  loaders: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      test: /\\.js$/,</span><br><span class=\"line\">      loader: &apos;babel&apos;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-3-添加-babelrc\"><a href=\"#4-3-添加-babelrc\" class=\"headerlink\" title=\"4.3 添加.babelrc\"></a>4.3 添加.babelrc</h3><p>在项目根目录下添加.babelrc文件，文件内容为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-2&quot;],</span><br><span class=\"line\">  &quot;plugins&quot;: [&quot;transform-runtime&quot;],</span><br><span class=\"line\">  &quot;comments&quot;: false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-4-使用ES6\"><a href=\"#4-4-使用ES6\" class=\"headerlink\" title=\"4.4 使用ES6\"></a>4.4 使用ES6</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import good from &apos;./good.js&apos;</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、分析vue-cli\"><a href=\"#三、分析vue-cli\" class=\"headerlink\" title=\"三、分析vue-cli\"></a>三、分析vue-cli</h1><p>说了这么多，我的最终目的还是为了学习Vue.js。所以在对webpack有了一定的理解之后，就发现其实vue-cli并不是那么深不可测。</p>\n<h2 id=\"1-结构分析\"><a href=\"#1-结构分析\" class=\"headerlink\" title=\"1. 结构分析\"></a>1. 结构分析</h2><ul>\n<li>build —— 项目构建文件夹<ul>\n<li>build.js —— 打包构建脚本（npm run build）</li>\n<li>check-versions.js —— npm和node版本的查询</li>\n<li>dev-client.js —— </li>\n<li>dev-server.js —— 开发调试脚本（npm run dev）</li>\n<li>utils.js —— 工具类</li>\n<li>webpack.base.config.js —— Webpack配置文件</li>\n<li>webpack.dev.config.js —— 开发版本Webpack配置文件，与webpack.base.config.js合并成完整的配置文件。</li>\n<li>webpack.prod.config.js —— 生产版本Webpack配置文件，与webpack.base.config.js合并成完整的配置文件。</li>\n</ul>\n</li>\n<li>config —— 配置文件夹，保存有各种配置参数（文件路径、服务器端口、功能开关）</li>\n<li>src —— 代码文件夹</li>\n<li>static<ul>\n<li>.gitkeep —— 作用是将文件所在文件夹保留在git版本控制中。文件类型和.gitignore差不多。</li>\n</ul>\n</li>\n<li>.babelrc —— babel配置文件</li>\n<li>.editorconfig —— 编辑配置，确保使用各种编辑器时能有相同的编辑格式。</li>\n<li>.gitignore —— git忽略文件</li>\n<li>index.html —— 页面，最终显示在这个html中</li>\n<li>package.json —— npm配置文件，包含了项目的信息、脚本、依赖库等重要信息。</li>\n</ul>\n<h2 id=\"2-创建简易cli\"><a href=\"#2-创建简易cli\" class=\"headerlink\" title=\"2. 创建简易cli\"></a>2. 创建简易cli</h2><p>理解完vue-cli的某些功能后，不难发现我们自己也可以搭建简易的vue-cli了。<br>官方的脚手架中除了有webpack打包，还包含了node脚本、开发和生产模式的切换、ESLint配置等功能。我们暂时不需要，将项目简化来更好的理解webpack。</p>\n<h3 id=\"2-1-package-json\"><a href=\"#2-1-package-json\" class=\"headerlink\" title=\"2.1 package.json\"></a>2.1 package.json</h3><p>让我们来自己建立一个cli，首先创建一个空文件夹。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir demo05</span><br><span class=\"line\">$ cd demo05</span><br></pre></td></tr></table></figure></p>\n<p>初始化npm<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm init</span><br></pre></td></tr></table></figure></p>\n<p>然后复制vue-cli中的依赖库到package.json中（直接复制啦，具体依赖库的作用就不提啦~之后会写博客补上的）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;dependencies&quot;: &#123;</span><br><span class=\"line\">  &quot;vue&quot;: &quot;^2.1.0&quot;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">  &quot;autoprefixer&quot;: &quot;^6.4.0&quot;,</span><br><span class=\"line\">  &quot;babel-core&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">  &quot;babel-loader&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">  &quot;babel-plugin-transform-runtime&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">  &quot;babel-preset-es2015&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">  &quot;babel-preset-stage-2&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">  &quot;babel-register&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">  &quot;chalk&quot;: &quot;^1.1.3&quot;,</span><br><span class=\"line\">  &quot;connect-history-api-fallback&quot;: &quot;^1.1.0&quot;,</span><br><span class=\"line\">  &quot;css-loader&quot;: &quot;^0.25.0&quot;,</span><br><span class=\"line\">  &quot;eventsource-polyfill&quot;: &quot;^0.9.6&quot;,</span><br><span class=\"line\">  &quot;express&quot;: &quot;^4.13.3&quot;,</span><br><span class=\"line\">  &quot;extract-text-webpack-plugin&quot;: &quot;^1.0.1&quot;,</span><br><span class=\"line\">  &quot;file-loader&quot;: &quot;^0.9.0&quot;,</span><br><span class=\"line\">  &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.1.2&quot;,</span><br><span class=\"line\">  &quot;function-bind&quot;: &quot;^1.0.2&quot;,</span><br><span class=\"line\">  &quot;html-webpack-plugin&quot;: &quot;^2.8.1&quot;,</span><br><span class=\"line\">  &quot;http-proxy-middleware&quot;: &quot;^0.17.2&quot;,</span><br><span class=\"line\">  &quot;json-loader&quot;: &quot;^0.5.4&quot;,</span><br><span class=\"line\">  &quot;semver&quot;: &quot;^5.3.0&quot;,</span><br><span class=\"line\">  &quot;opn&quot;: &quot;^4.0.2&quot;,</span><br><span class=\"line\">  &quot;ora&quot;: &quot;^0.3.0&quot;,</span><br><span class=\"line\">  &quot;shelljs&quot;: &quot;^0.7.4&quot;,</span><br><span class=\"line\">  &quot;url-loader&quot;: &quot;^0.5.7&quot;,</span><br><span class=\"line\">  &quot;vue-loader&quot;: &quot;^10.0.0&quot;,</span><br><span class=\"line\">  &quot;vue-style-loader&quot;: &quot;^1.0.0&quot;,</span><br><span class=\"line\">  &quot;vue-template-compiler&quot;: &quot;^2.1.0&quot;,</span><br><span class=\"line\">  &quot;webpack&quot;: &quot;^1.13.2&quot;,</span><br><span class=\"line\">  &quot;webpack-dev-middleware&quot;: &quot;^1.8.3&quot;,</span><br><span class=\"line\">  &quot;webpack-hot-middleware&quot;: &quot;^2.12.2&quot;,</span><br><span class=\"line\">  &quot;webpack-merge&quot;: &quot;^0.14.1&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-2-webpack-config-js\"><a href=\"#2-2-webpack-config-js\" class=\"headerlink\" title=\"2.2 webpack.config.js\"></a>2.2 webpack.config.js</h3><p>这里的webpack配置文件中的部分内容是从官方的 <code>webpack.base.config.js</code> 中复制出来的。正如我项目结构中所说的，vue-cli中的 <code>webpack.base.config.js</code> 是基础的配置文件。vue-cli中的 <code>webpack.dev.config.js</code> 和 <code>webpack.prod.config.js</code> 分别代表了开发和生产版本的webpack配置文件，他们与 <code>webpack.base.config.js</code> 合并成最后的webpack配置文件。这里我们只要找到 <code>webpack.base.config.js</code> 即可。<br>下面是完整配置代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var path = require(&quot;path&quot;)</span><br><span class=\"line\">var projectRoot = path.resolve(__dirname, &apos;../&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 入口文件</span><br><span class=\"line\">  entry: &quot;./src/main.js&quot;,</span><br><span class=\"line\">  // 输出文件</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: &quot;./dist/bundle.js&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 别名</span><br><span class=\"line\">  resolve: &#123;</span><br><span class=\"line\">    extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],</span><br><span class=\"line\">    fallback: [path.join(__dirname, &apos;../node_modules&apos;)],</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">      &apos;vue$&apos;: &apos;vue/dist/vue.common.js&apos;,</span><br><span class=\"line\">      &apos;src&apos;: path.resolve(__dirname, &apos;../src&apos;),</span><br><span class=\"line\">      &apos;assets&apos;: path.resolve(__dirname, &apos;../src/assets&apos;),</span><br><span class=\"line\">      &apos;components&apos;: path.resolve(__dirname, &apos;../src/components&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    // 加载器</span><br><span class=\"line\">    loaders: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.vue$/,</span><br><span class=\"line\">        loader: &apos;vue&apos;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.js$/,</span><br><span class=\"line\">        loader: &apos;babel&apos;,</span><br><span class=\"line\">        exclude: /node_modules/</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.json$/,</span><br><span class=\"line\">        loader: &apos;json&apos;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,</span><br><span class=\"line\">        loader: &apos;url&apos;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,</span><br><span class=\"line\">        loader: &apos;url&apos;,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-3-添加必要文件\"><a href=\"#2-3-添加必要文件\" class=\"headerlink\" title=\"2.3 添加必要文件\"></a>2.3 添加必要文件</h3><p>由于使用git、babel，所以我将vue-cli中的 <code>.gitignore</code> 和 <code>.babelrc</code> 直接复制过来。<br>还有，由于懒得写逻辑代码，这里我将 <code>src</code> 文件夹中所有内容也直接复制过来。<br>复制按成后进行webpack打包。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br></pre></td></tr></table></figure></p>\n<p>打包完成就会出现一个在 <code>dist</code> 目录下有一个 <code>bundle.js</code> 文件。有了打包文件，我们还需要创建一个 <code>index.html</code> 来显示效果，这个之后再说。<br>所以，最后的项目结构如下图</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1987062-b65832334ec76374.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"项目结构\"></p>\n<h3 id=\"2-4-index-html\"><a href=\"#2-4-index-html\" class=\"headerlink\" title=\"2.4 index.html\"></a>2.4 index.html</h3><p>现在，到了呈现效果的时候了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Demo3&lt;/title&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>很简单，创建一个id为app的div元素用于显示Vue组件内容，然后将打包好的bundle.js引用进去。<br>现在，到项目目录中找到 <code>index.html</code> 页面，浏览器打开就可以看到效果啦~</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1987062-9e3fd5985b12e67a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"效果图\"></p>\n<p><strong>注：</strong>简易cli项目的源码在 VueStudyDemos\\WebpackDemos\\demo5中</p>\n<h1 id=\"四、相关资料推荐\"><a href=\"#四、相关资料推荐\" class=\"headerlink\" title=\"四、相关资料推荐\"></a>四、相关资料推荐</h1><p>这里推荐一下我学习webpack中发现的一些好的网站，分享一下。<br><a href=\"https://github.com/webpack-china/awesome-webpack-cn\" target=\"_blank\" rel=\"noopener\">https://github.com/webpack-china/awesome-webpack-cn</a><br><a href=\"http://blog.guowenfh.com/2016/03/24/vue-webpack-01-base/\" target=\"_blank\" rel=\"noopener\">http://blog.guowenfh.com/2016/03/24/vue-webpack-01-base/</a></p>\n<h1 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h1><p>拖了一个春节，终于把webpack的博客给写出来了。感觉在写完博客之后对webpack的理解深刻了许多，再次证明了“教是最好的学”这个理论。<br>新的一年，我要坚持好好写博客，享受分享带来的快乐。<br>之后计划学习一下eslint以及一些测试工具。然后试着用element和mint做两个小demo分享出来。然后了解一下node的相关知识。</p>\n<h1 id=\"Vue-js学习系列\"><a href=\"#Vue-js学习系列\" class=\"headerlink\" title=\"Vue.js学习系列\"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>\n<p><a href=\"http://www.jianshu.com/p/8013d8d37bd0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/d6f7e11f18af\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/8e5fb763c3d7\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href=\"http://www.jianshu.com/p/aef34acd111f\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href=\"http://www.jianshu.com/p/efb6fbed6fac\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href=\"http://www.jianshu.com/p/073d25a3bba0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href=\"https://www.jianshu.com/p/ba7466d7101a\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href=\"https://www.jianshu.com/p/15028f91226e\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>\n<h1 id=\"Vue-js学习系列项目地址\"><a href=\"#Vue-js学习系列项目地址\" class=\"headerlink\" title=\"Vue.js学习系列项目地址\"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack/VueStudyDemos</a></p>\n<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>\n<p>新浪微博： <a href=\"http://weibo.com/u/2640909603\" target=\"_blank\" rel=\"noopener\">http://weibo.com/u/2640909603</a><br>掘金：<a href=\"https://gold.xitu.io/user/571d953d39b0570068145cd1\" target=\"_blank\" rel=\"noopener\">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href=\"http://blog.csdn.net/violetjack0808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/violetjack0808</a><br>简书： <a href=\"http://www.jianshu.com/users/54ae4af3a98d/latest_articles\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href=\"https://github.com/violetjack\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack</a></p>\n"},{"title":"Vue学习系列倡议书","date":"2018-01-28T16:00:00.000Z","_content":"\n> 我想通过社区的力量把《Vue学习系列》做到最优质的Vue系列博客\n\n# 解决学习痛点\n学习前端的同学都知道，前端有一大痛点就是知识点分散，学习的东西多。\n就像我学习Vue，一拿到手就告诉我有个全家桶要学习。虽然一个一个学习下来了，但是过程是比较漫长的。而且如果是刚入门前端世界，会发现还没开始写代码各种配置都能玩好几天。Webpack打包、ESLint代码检查、Babel语法转译等等……\n写本系列博客的本意是想将学习Vue的内容用博客的形式写出来，加深对知识点的理解。同时也希望能够帮助到和我有同样需求的朋友。\n不过，就在昨天晚上我突然多了一个想法。**我想把《Vue学习系列》做到最优质的Vue系列博客。**通过我惯用的 **资料索引+个人理解+Demo** 的方式将Vue前端世界的所有都讲清楚、讲明白。让想学习前端的同学能够快速度过学习的迷茫期。通过本系列博客，快速入门Vue前端世界。\n**打一个比方就是：官方文档是满汉全席，那么本系列博客就是肯德基、麦当劳，提高效率，拿来就用！**\n\n# 定位\n**通过一篇博客和一个演示项目快速学会Vue某个功能的常规使用方法。**\n本系列博客定位是刚入门学习Vue的同学~相比于看官方文档，通过本系列博客有几个优点：\n* **常用功能** —— 正如二八原则一样，100%的学习内容中只有20%是常用而又必要的，我们先把20%掌握开始上手，其他80%按需学习。\n* **个人理解** —— 尽量用容易理解的语言对技术点进行描述，最好能让没有学过前端的人都能理解是怎么回事。\n* **实例项目** —— 每篇博客一个简单的小项目，包含了博客中提到的所有功能的实现（其实作者是边撸博客边写demo的，确保博客内容是可执行的）。博客和demo配合味道更佳哦~\n* **踩坑提醒** —— 前端项目中总是会有一些奇奇怪怪的坑，如果作者踩过了，我会尽量提出。避免其他同学浪费时间精力去过这些无谓的坑。\n\n在入门系列发布后，会继续发布高级系列、源码解析系列。让我们一起学习共同进步。\n# 倡议\n> [《Vue学习系列》博客](https://github.com/violetjack/VueStudyDemos/tree/master/Blogs)的文本和Demo都将发布在Github上，并且博客内容将在[简书](https://www.jianshu.com/c/edec9ac6d9a7)上首发和更新。\n如果对本系列课程有任何建议、想法、评论。可以在简书下留言，或者在VueStudyDemos项目中提交 issue 和 PR，希望通过大家的力量将本系列课程做好，帮助到更多人。\n\n到我写本文的时候，Vue学习系列的demo项目[VueStudyDemos](https://github.com/violetjack/VueStudyDemos)已有173颗star了。感谢大家的支持，希望本系列博客真的可以帮助到大家。之后还会继续产出Vue相关的博客。\n\n# Vue.js学习系列\n鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。\n\n[Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）](http://www.jianshu.com/p/8013d8d37bd0)\n[Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）](http://www.jianshu.com/p/d6f7e11f18af)\n[Vue.js学习系列三 —— axios和网络传输相关知识的学习实践](http://www.jianshu.com/p/8e5fb763c3d7)\n[Vue.js学习系列四 —— Webpack打包工具的使用](http://www.jianshu.com/p/aef34acd111f)\n[Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint](http://www.jianshu.com/p/efb6fbed6fac)\n[Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记](http://www.jianshu.com/p/073d25a3bba0)\n[Vue.js学习系列七 —— Vue服务器渲染Nuxt学习](https://www.jianshu.com/p/ba7466d7101a)\n[Vue.js学习系列八 —— Vue源码学习之State学习](https://www.jianshu.com/p/15028f91226e)\n\n# Vue.js学习系列项目地址\n本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。\n[https://github.com/violetjack/VueStudyDemos](https://github.com/violetjack/VueStudyDemos)\n\n# 关于作者\nVioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。\n欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。\n\n新浪微博： http://weibo.com/u/2640909603\n掘金：https://gold.xitu.io/user/571d953d39b0570068145cd1\nCSDN: http://blog.csdn.net/violetjack0808\n简书： http://www.jianshu.com/users/54ae4af3a98d/latest_articles\nGithub： https://github.com/violetjack","source":"_posts/Vue学习系列倡议书.md","raw":"---\ntitle: Vue学习系列倡议书\ndate: 2018-01-29\n---\n\n> 我想通过社区的力量把《Vue学习系列》做到最优质的Vue系列博客\n\n# 解决学习痛点\n学习前端的同学都知道，前端有一大痛点就是知识点分散，学习的东西多。\n就像我学习Vue，一拿到手就告诉我有个全家桶要学习。虽然一个一个学习下来了，但是过程是比较漫长的。而且如果是刚入门前端世界，会发现还没开始写代码各种配置都能玩好几天。Webpack打包、ESLint代码检查、Babel语法转译等等……\n写本系列博客的本意是想将学习Vue的内容用博客的形式写出来，加深对知识点的理解。同时也希望能够帮助到和我有同样需求的朋友。\n不过，就在昨天晚上我突然多了一个想法。**我想把《Vue学习系列》做到最优质的Vue系列博客。**通过我惯用的 **资料索引+个人理解+Demo** 的方式将Vue前端世界的所有都讲清楚、讲明白。让想学习前端的同学能够快速度过学习的迷茫期。通过本系列博客，快速入门Vue前端世界。\n**打一个比方就是：官方文档是满汉全席，那么本系列博客就是肯德基、麦当劳，提高效率，拿来就用！**\n\n# 定位\n**通过一篇博客和一个演示项目快速学会Vue某个功能的常规使用方法。**\n本系列博客定位是刚入门学习Vue的同学~相比于看官方文档，通过本系列博客有几个优点：\n* **常用功能** —— 正如二八原则一样，100%的学习内容中只有20%是常用而又必要的，我们先把20%掌握开始上手，其他80%按需学习。\n* **个人理解** —— 尽量用容易理解的语言对技术点进行描述，最好能让没有学过前端的人都能理解是怎么回事。\n* **实例项目** —— 每篇博客一个简单的小项目，包含了博客中提到的所有功能的实现（其实作者是边撸博客边写demo的，确保博客内容是可执行的）。博客和demo配合味道更佳哦~\n* **踩坑提醒** —— 前端项目中总是会有一些奇奇怪怪的坑，如果作者踩过了，我会尽量提出。避免其他同学浪费时间精力去过这些无谓的坑。\n\n在入门系列发布后，会继续发布高级系列、源码解析系列。让我们一起学习共同进步。\n# 倡议\n> [《Vue学习系列》博客](https://github.com/violetjack/VueStudyDemos/tree/master/Blogs)的文本和Demo都将发布在Github上，并且博客内容将在[简书](https://www.jianshu.com/c/edec9ac6d9a7)上首发和更新。\n如果对本系列课程有任何建议、想法、评论。可以在简书下留言，或者在VueStudyDemos项目中提交 issue 和 PR，希望通过大家的力量将本系列课程做好，帮助到更多人。\n\n到我写本文的时候，Vue学习系列的demo项目[VueStudyDemos](https://github.com/violetjack/VueStudyDemos)已有173颗star了。感谢大家的支持，希望本系列博客真的可以帮助到大家。之后还会继续产出Vue相关的博客。\n\n# Vue.js学习系列\n鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。\n\n[Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）](http://www.jianshu.com/p/8013d8d37bd0)\n[Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）](http://www.jianshu.com/p/d6f7e11f18af)\n[Vue.js学习系列三 —— axios和网络传输相关知识的学习实践](http://www.jianshu.com/p/8e5fb763c3d7)\n[Vue.js学习系列四 —— Webpack打包工具的使用](http://www.jianshu.com/p/aef34acd111f)\n[Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint](http://www.jianshu.com/p/efb6fbed6fac)\n[Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记](http://www.jianshu.com/p/073d25a3bba0)\n[Vue.js学习系列七 —— Vue服务器渲染Nuxt学习](https://www.jianshu.com/p/ba7466d7101a)\n[Vue.js学习系列八 —— Vue源码学习之State学习](https://www.jianshu.com/p/15028f91226e)\n\n# Vue.js学习系列项目地址\n本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。\n[https://github.com/violetjack/VueStudyDemos](https://github.com/violetjack/VueStudyDemos)\n\n# 关于作者\nVioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。\n欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。\n\n新浪微博： http://weibo.com/u/2640909603\n掘金：https://gold.xitu.io/user/571d953d39b0570068145cd1\nCSDN: http://blog.csdn.net/violetjack0808\n简书： http://www.jianshu.com/users/54ae4af3a98d/latest_articles\nGithub： https://github.com/violetjack","slug":"Vue学习系列倡议书","published":1,"updated":"2018-02-07T02:26:26.752Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjddwxbmk000bi8bt8usg6s35","content":"<blockquote>\n<p>我想通过社区的力量把《Vue学习系列》做到最优质的Vue系列博客</p>\n</blockquote>\n<h1 id=\"解决学习痛点\"><a href=\"#解决学习痛点\" class=\"headerlink\" title=\"解决学习痛点\"></a>解决学习痛点</h1><p>学习前端的同学都知道，前端有一大痛点就是知识点分散，学习的东西多。<br>就像我学习Vue，一拿到手就告诉我有个全家桶要学习。虽然一个一个学习下来了，但是过程是比较漫长的。而且如果是刚入门前端世界，会发现还没开始写代码各种配置都能玩好几天。Webpack打包、ESLint代码检查、Babel语法转译等等……<br>写本系列博客的本意是想将学习Vue的内容用博客的形式写出来，加深对知识点的理解。同时也希望能够帮助到和我有同样需求的朋友。<br>不过，就在昨天晚上我突然多了一个想法。<strong>我想把《Vue学习系列》做到最优质的Vue系列博客。</strong>通过我惯用的 <strong>资料索引+个人理解+Demo</strong> 的方式将Vue前端世界的所有都讲清楚、讲明白。让想学习前端的同学能够快速度过学习的迷茫期。通过本系列博客，快速入门Vue前端世界。<br><strong>打一个比方就是：官方文档是满汉全席，那么本系列博客就是肯德基、麦当劳，提高效率，拿来就用！</strong></p>\n<h1 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h1><p><strong>通过一篇博客和一个演示项目快速学会Vue某个功能的常规使用方法。</strong><br>本系列博客定位是刚入门学习Vue的同学~相比于看官方文档，通过本系列博客有几个优点：</p>\n<ul>\n<li><strong>常用功能</strong> —— 正如二八原则一样，100%的学习内容中只有20%是常用而又必要的，我们先把20%掌握开始上手，其他80%按需学习。</li>\n<li><strong>个人理解</strong> —— 尽量用容易理解的语言对技术点进行描述，最好能让没有学过前端的人都能理解是怎么回事。</li>\n<li><strong>实例项目</strong> —— 每篇博客一个简单的小项目，包含了博客中提到的所有功能的实现（其实作者是边撸博客边写demo的，确保博客内容是可执行的）。博客和demo配合味道更佳哦~</li>\n<li><strong>踩坑提醒</strong> —— 前端项目中总是会有一些奇奇怪怪的坑，如果作者踩过了，我会尽量提出。避免其他同学浪费时间精力去过这些无谓的坑。</li>\n</ul>\n<p>在入门系列发布后，会继续发布高级系列、源码解析系列。让我们一起学习共同进步。</p>\n<h1 id=\"倡议\"><a href=\"#倡议\" class=\"headerlink\" title=\"倡议\"></a>倡议</h1><blockquote>\n<p><a href=\"https://github.com/violetjack/VueStudyDemos/tree/master/Blogs\" target=\"_blank\" rel=\"noopener\">《Vue学习系列》博客</a>的文本和Demo都将发布在Github上，并且博客内容将在<a href=\"https://www.jianshu.com/c/edec9ac6d9a7\" target=\"_blank\" rel=\"noopener\">简书</a>上首发和更新。<br>如果对本系列课程有任何建议、想法、评论。可以在简书下留言，或者在VueStudyDemos项目中提交 issue 和 PR，希望通过大家的力量将本系列课程做好，帮助到更多人。</p>\n</blockquote>\n<p>到我写本文的时候，Vue学习系列的demo项目<a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">VueStudyDemos</a>已有173颗star了。感谢大家的支持，希望本系列博客真的可以帮助到大家。之后还会继续产出Vue相关的博客。</p>\n<h1 id=\"Vue-js学习系列\"><a href=\"#Vue-js学习系列\" class=\"headerlink\" title=\"Vue.js学习系列\"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>\n<p><a href=\"http://www.jianshu.com/p/8013d8d37bd0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/d6f7e11f18af\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/8e5fb763c3d7\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href=\"http://www.jianshu.com/p/aef34acd111f\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href=\"http://www.jianshu.com/p/efb6fbed6fac\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href=\"http://www.jianshu.com/p/073d25a3bba0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href=\"https://www.jianshu.com/p/ba7466d7101a\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href=\"https://www.jianshu.com/p/15028f91226e\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>\n<h1 id=\"Vue-js学习系列项目地址\"><a href=\"#Vue-js学习系列项目地址\" class=\"headerlink\" title=\"Vue.js学习系列项目地址\"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack/VueStudyDemos</a></p>\n<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>\n<p>新浪微博： <a href=\"http://weibo.com/u/2640909603\" target=\"_blank\" rel=\"noopener\">http://weibo.com/u/2640909603</a><br>掘金：<a href=\"https://gold.xitu.io/user/571d953d39b0570068145cd1\" target=\"_blank\" rel=\"noopener\">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href=\"http://blog.csdn.net/violetjack0808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/violetjack0808</a><br>简书： <a href=\"http://www.jianshu.com/users/54ae4af3a98d/latest_articles\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href=\"https://github.com/violetjack\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>我想通过社区的力量把《Vue学习系列》做到最优质的Vue系列博客</p>\n</blockquote>\n<h1 id=\"解决学习痛点\"><a href=\"#解决学习痛点\" class=\"headerlink\" title=\"解决学习痛点\"></a>解决学习痛点</h1><p>学习前端的同学都知道，前端有一大痛点就是知识点分散，学习的东西多。<br>就像我学习Vue，一拿到手就告诉我有个全家桶要学习。虽然一个一个学习下来了，但是过程是比较漫长的。而且如果是刚入门前端世界，会发现还没开始写代码各种配置都能玩好几天。Webpack打包、ESLint代码检查、Babel语法转译等等……<br>写本系列博客的本意是想将学习Vue的内容用博客的形式写出来，加深对知识点的理解。同时也希望能够帮助到和我有同样需求的朋友。<br>不过，就在昨天晚上我突然多了一个想法。<strong>我想把《Vue学习系列》做到最优质的Vue系列博客。</strong>通过我惯用的 <strong>资料索引+个人理解+Demo</strong> 的方式将Vue前端世界的所有都讲清楚、讲明白。让想学习前端的同学能够快速度过学习的迷茫期。通过本系列博客，快速入门Vue前端世界。<br><strong>打一个比方就是：官方文档是满汉全席，那么本系列博客就是肯德基、麦当劳，提高效率，拿来就用！</strong></p>\n<h1 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h1><p><strong>通过一篇博客和一个演示项目快速学会Vue某个功能的常规使用方法。</strong><br>本系列博客定位是刚入门学习Vue的同学~相比于看官方文档，通过本系列博客有几个优点：</p>\n<ul>\n<li><strong>常用功能</strong> —— 正如二八原则一样，100%的学习内容中只有20%是常用而又必要的，我们先把20%掌握开始上手，其他80%按需学习。</li>\n<li><strong>个人理解</strong> —— 尽量用容易理解的语言对技术点进行描述，最好能让没有学过前端的人都能理解是怎么回事。</li>\n<li><strong>实例项目</strong> —— 每篇博客一个简单的小项目，包含了博客中提到的所有功能的实现（其实作者是边撸博客边写demo的，确保博客内容是可执行的）。博客和demo配合味道更佳哦~</li>\n<li><strong>踩坑提醒</strong> —— 前端项目中总是会有一些奇奇怪怪的坑，如果作者踩过了，我会尽量提出。避免其他同学浪费时间精力去过这些无谓的坑。</li>\n</ul>\n<p>在入门系列发布后，会继续发布高级系列、源码解析系列。让我们一起学习共同进步。</p>\n<h1 id=\"倡议\"><a href=\"#倡议\" class=\"headerlink\" title=\"倡议\"></a>倡议</h1><blockquote>\n<p><a href=\"https://github.com/violetjack/VueStudyDemos/tree/master/Blogs\" target=\"_blank\" rel=\"noopener\">《Vue学习系列》博客</a>的文本和Demo都将发布在Github上，并且博客内容将在<a href=\"https://www.jianshu.com/c/edec9ac6d9a7\" target=\"_blank\" rel=\"noopener\">简书</a>上首发和更新。<br>如果对本系列课程有任何建议、想法、评论。可以在简书下留言，或者在VueStudyDemos项目中提交 issue 和 PR，希望通过大家的力量将本系列课程做好，帮助到更多人。</p>\n</blockquote>\n<p>到我写本文的时候，Vue学习系列的demo项目<a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">VueStudyDemos</a>已有173颗star了。感谢大家的支持，希望本系列博客真的可以帮助到大家。之后还会继续产出Vue相关的博客。</p>\n<h1 id=\"Vue-js学习系列\"><a href=\"#Vue-js学习系列\" class=\"headerlink\" title=\"Vue.js学习系列\"></a>Vue.js学习系列</h1><p>鉴于前端知识碎片化严重，我希望能够系统化的整理出一套关于Vue的学习系列博客。</p>\n<p><a href=\"http://www.jianshu.com/p/8013d8d37bd0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列一 —— vue-router2学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/d6f7e11f18af\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列二 —— vuex学习实践笔记（附DEMO）</a><br><a href=\"http://www.jianshu.com/p/8e5fb763c3d7\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列三 —— axios和网络传输相关知识的学习实践</a><br><a href=\"http://www.jianshu.com/p/aef34acd111f\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四 —— Webpack打包工具的使用</a><br><a href=\"http://www.jianshu.com/p/efb6fbed6fac\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列五 —— 从VUE-CLI来聊聊ESLint</a><br><a href=\"http://www.jianshu.com/p/073d25a3bba0\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列六 —— Vue单元测试Karma+Mocha学习笔记</a><br><a href=\"https://www.jianshu.com/p/ba7466d7101a\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列七 —— Vue服务器渲染Nuxt学习</a><br><a href=\"https://www.jianshu.com/p/15028f91226e\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列八 —— Vue源码学习之State学习</a></p>\n<h1 id=\"Vue-js学习系列项目地址\"><a href=\"#Vue-js学习系列项目地址\" class=\"headerlink\" title=\"Vue.js学习系列项目地址\"></a>Vue.js学习系列项目地址</h1><p>本文源码已收入到GitHub中，以供参考，当然能留下一个star更好啦^-^。<br><a href=\"https://github.com/violetjack/VueStudyDemos\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack/VueStudyDemos</a></p>\n<h1 id=\"关于作者\"><a href=\"#关于作者\" class=\"headerlink\" title=\"关于作者\"></a>关于作者</h1><p>VioletJack，高效学习前端工程师，喜欢研究提高效率的方法，也专注于Vue前端相关知识的学习、整理。<br>欢迎关注、点赞、评论留言~我将持续产出Vue相关优质内容。</p>\n<p>新浪微博： <a href=\"http://weibo.com/u/2640909603\" target=\"_blank\" rel=\"noopener\">http://weibo.com/u/2640909603</a><br>掘金：<a href=\"https://gold.xitu.io/user/571d953d39b0570068145cd1\" target=\"_blank\" rel=\"noopener\">https://gold.xitu.io/user/571d953d39b0570068145cd1</a><br>CSDN: <a href=\"http://blog.csdn.net/violetjack0808\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/violetjack0808</a><br>简书： <a href=\"http://www.jianshu.com/users/54ae4af3a98d/latest_articles\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/users/54ae4af3a98d/latest_articles</a><br>Github： <a href=\"https://github.com/violetjack\" target=\"_blank\" rel=\"noopener\">https://github.com/violetjack</a></p>\n"},{"title":"Vue源码学习笔记","date":"2017-11-30T16:00:00.000Z","_content":"\n> 最近偷懒好久没有写博客了，一直想继续Vue学习系列，想深入Vue源码来写。结果发现自己层次不够，对js的理解差好多。所以一直想写一直搁置着。最近重新振作决心看完Vue源码，并且以我们这类前端小白的角度来一步步弄懂Vue源码。\n\n**PS：**以下文章为笔记类，记录了本人在看源码过程中的一些问题和感悟。\n\n# Vue源码的本质是什么\nVue.js 本质上就是一个包含各种逻辑的一个function。而我们通常初始化Vue的过程就是实例化的过程。\n```\nvar vm = new Vue({})\n```\n话不多说，老规矩用代码说话！\n让我们来对Vue进行打印：\n```\nvar vm = new Vue({\n  ...\n})\n\nconsole.log(Vue)\nconsole.log(vm)\n```\n打印结果如图：\n![vue](http://upload-images.jianshu.io/upload_images/1987062-51c2e9112e90eeef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里可以看到Vue$3这个方法，就是这个方法对Vue对象的构造函数了。其实这很简单，我们自己都可以造出一个Vue$4\n```\n    function Vue$4(options) {\n        this.options = options\n    }\n\n    Vue$4.prototype.name = \"小东西\"\n    Vue$4.prototype.age = 27\n\n    console.log(new Vue$4(\"很好\"))\n```\n显示结果如图\n![vue$4](http://upload-images.jianshu.io/upload_images/1987062-ff4ba64d71f9d5b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n综上所述，Vue对象的本质就是一个function，与我们的Vue$4的不同之处只在于逻辑的多与少。\n\n# 必须理解Object对象\n在Vue的源码中，出场率最多的应该就数`Object`对象的使用上了。可以这么说，不懂Object都没法往下看代码。以下是源码中用到的比较多的。\n\n* [Object.defineProperty](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。\n* [Object.create](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create) 使用指定的原型对象及其属性去创建一个新的对象。\n* [Object.keys](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys) 返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。\n* [Object.prototype](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype) Object的原型对象。\n* [Object.freeze](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) 冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。\n\n那么，Vue中哪个是Object呢？我们继续试验：\n```\nconsole.log(typeof Vue)\nconsole.log(typeof new Vue())\n```\n输出结果\n```\nfunction\nobject\n```\n结果显示，使用new来创建的Vue实例就是个对象，所以一切对Object的操作行为都是针对Vue实例对象的。\n\n# 理解setter和getter\n在网上看Vue的评论是经常会听到说\n\n> Vue无非就是setter和getter方法的运用而已\n\n这让我等新手一脸懵逼，这里我们就来认识认识setter和getter。\n当我们在获取一个Vue实例data中的某个对象，如果你用console打印出来会发现，对象属性中除了常规的对象属性和__proto__对象之外还会多一个set和一个get方法，所谓的setter和getter就是它们。Vue给每一个对象属性都添加了Observer观察数据的获取和修改。好吧，贴代码一睹真容。\n```\nfunction defineReactive (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  // Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。\n  //（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）\n  // 对象、属性名称、描述~\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  // 当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) { // Watcher\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (\"development\" !== 'production' && customSetter) {\n        customSetter(); // 自定义setter\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n```\n代码太长？懵逼了？没关系，我们自己来造一个简单的setter和getter来了解一下。\n其实用的就是Object.defineProperty方法中就有set和get。\n\n* get 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。\n* set 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。\n\n好了，写代码~\n```\n    var obj = {}\n    var mValue = \"abc\"\n    Object.defineProperty(obj, \"_name\", {\n        configurable: false, \n        enumerable: false, \n        get: function reactiveGetter () {\n            return mValue\n        },\n        set: function reactiveSetter (val) {\n            mValue = val\n        }\n    })\n\n    obj._name = \"rose\"\n\n    console.log(obj)\n```\n到这里我们打印log，对象属性的set和get方法就出现了。\n![打印结果](http://upload-images.jianshu.io/upload_images/1987062-c11e06d42cf94a2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n# 逻辑运算符的使用\n在源码中有很多[逻辑运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_Operators)的使用，有些运用的很巧妙。这里也科普下吧~\n\n首先知道下可以转换成false的值，如下：\n* null\n* NaN\n* 0\n* 空字符串（\"\"）\n* undefined\n\n### 用法一：判断条件返回true或者false\n这是最基本的用法。\n```\nif (a & a.master & a.master.name) {} // 如果这三个属性都为true值，执行if逻辑\nif (a || b) {} // 如果a或者b为true值，执行if逻辑。\n```\n### 用法二：判断并返回条件对象\n\n* `&&` 如果几个条件都为true，则返回最后一个条件。\n* `||` 几个条件从前往后逐一判断，如果那个条件为true，返回该条件，否则返回最后一个条件。\n```\nvar getter = property && property.get;  // 如果两个属性都存在，将property.get赋值给getter\ne && e.__ob__ && e.__ob__.dep.depend(); // 如果三个属性都存在，执行第三条语句的方法\nvar res = assets[id] || assets[camelizedId] || assets[PascalCaseId]; \n// 给res赋值，如果assets[id]为true，则将其传res；\n// 如果assets[camelizedId]为true，将其传给res；\n// 如果前两者都为false，将assets[PascalCaseId]传给res。\nvar strat = strats[key] || defaultStrat;\n```\n然后，我对各种情况做了试验得出以下结论：\n\n* `&&` 判断中，判断值都为 `true`，返回最后一个判断值；判断值中有 `false`\n 值，返回第一个 `false` 值。\n* `||` 判断中，判断值都为 `true`，返回第一个判断值；判断值中有 `true` 值也有 `false` 值，返回第一个为 `true` 的判断值；如果判断值都为 `false`，返回最后面的 `false` 值。\n\n**注意：**这里所说的返回 `false` 值不一定是 Boolean 类型的 `false`，也可能是 `0、null` 等非值，详见上文。\n\n### 用法三：使用两个非\n两个感叹号会确保参数为非值时只能为false，不会是0、空字符串、undefined等非值。\n```\nif (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n```\n\n# 数组操作\n### 复制\n先看一段代码。\n```\n  var a = [ 'jack', 'rose', 'wade' ]\n  var b = a\n  b[1] = 'marry'\n  console.log(a)\n  console.log(b)\n```\n最后的结果是a和b的数组第二个值都变成了marry，原因就是b并不是获得了数组内容，而只是指向了a，a和b其实是一回事。如果我们需要复制，可以这么写：\n```\n  var b = a.slice()\n```\n查阅[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)可知：\n > slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，原始数组不会被修改。\n### 清空\n想要将非空数组的内容清空，最快捷的方式如下：\n```\narr.length = 0\n```\n### 合并\n直接引用[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)的例子。\n> concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。\n```\nvar arr1 = ['a', 'b', 'c'];\nvar arr2 = ['d', 'e', 'f'];\n\nvar arr3 = arr1.concat(arr2);\n\n// arr3 is a new array [ \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" ]\n```\n### 遍历\n呃，使用forEach方式来遍历数组是我刚知道的事 - -（之前都是用的for方法……），顺便记录下。\n```\narr.forEach(function(obj){\n    // 数组循环\n})\n```\n# 几种特殊的写法\n在代码中有些代码片段有些看不懂，于是在SF上进行了提问：[看Vue源码，有两段代码写法不知是何意思，求指教~](https://segmentfault.com/q/1010000012573448)。感谢大家的帮助，这里总结下。\n第一段是一段在{}里的代码。\n```\n{\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n}\n```\n这段代码，有的朋友说是块级作用域、隔离作用域。不过另一种说法更可信。那就是我所看到的vue是编译完的的代码。源代码其实在大括号前是有条件的。\n```\nif (process.env.NODE_ENV !== 'production') {\n  ...\n```\n再来看下面的代码\n```\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.Vue = factory());\n}(this, (function () { 'use strict';\n\n})))\n```\n这段代码是Vue开头的一段代码，它有两个知识点。\n* 立即执行函数 —— 定义函数并立即执行，写法有 `(function(){})()` 或者 `(function(){}())` 的形式。\n* 由于过去前端没有模块系统，使用script标签引入的js脚本共享同一个作用域，如果不把代码包起来，很容易产生作用域污染、变量冲突的问题。\n\n**PS：**这两个问题真是网友的结论，不一定完善。有空我会查资料证实~\n\n# 其他知识点\n*  [Arguments](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments) —— 传给函数的参数数组\n* [new运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new) —— 通过构造函数创建对象\n* `\"development\" !== 'production’`的作用 —— webpack打包判断执行环境是不是生产环境，如果是生产环境会压缩并且没有提示警告之类的东西\n* [ instanceof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof) —— 验证实例对象是否为该构造函数new出来的。\n* [in关键字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in) —— 判断某个值是否在数组或对象中。\n* [Proxy对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy) —— 创建某个对象，并定义一些行为给该对象。\n* 字符串的 `charAt` 是获取第几个字符，而 `slice` 方法是截取某段字符。\n* [delete关键字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete) —— 用于删除对象中的某个关键字。\n* [call()方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call) —— 函数的调用，第一个参数为this，之后为函数定义参数。试验了下 `fun(a, b)` 和 `fun.call(this, a, b)` 两种写法效果一致。另外还可以看下 [apply()方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)\n\n**PS：**都是从MDN中找到的资料，多查MDN让我受益良多。\n\n\n\n# 未完待续\n还在学习Vue源码中……看了很多文章、也看了一遍源码。内容太多，千头万绪，容我理清之后，用自己的文字把Vue的源码学习记录分享出来。一些值得记录下来的知识点和心得会继续在本文中更新。\n最后，想学习Vue源码的同学可以去买[《Vue.js权威指南》](https://item.jd.com/12028224.html?dist=jd)这本书，虽然许多章节内容和[官网](https://cn.vuejs.org/v2/guide/)是重复的，不过源码解析部分值得一看。我也正配合着这本书和源码在学习Vue。\n\n\n","source":"_posts/Vue源码学习笔记.md","raw":"---\ntitle: Vue源码学习笔记\ndate: 2017-12-01\n---\n\n> 最近偷懒好久没有写博客了，一直想继续Vue学习系列，想深入Vue源码来写。结果发现自己层次不够，对js的理解差好多。所以一直想写一直搁置着。最近重新振作决心看完Vue源码，并且以我们这类前端小白的角度来一步步弄懂Vue源码。\n\n**PS：**以下文章为笔记类，记录了本人在看源码过程中的一些问题和感悟。\n\n# Vue源码的本质是什么\nVue.js 本质上就是一个包含各种逻辑的一个function。而我们通常初始化Vue的过程就是实例化的过程。\n```\nvar vm = new Vue({})\n```\n话不多说，老规矩用代码说话！\n让我们来对Vue进行打印：\n```\nvar vm = new Vue({\n  ...\n})\n\nconsole.log(Vue)\nconsole.log(vm)\n```\n打印结果如图：\n![vue](http://upload-images.jianshu.io/upload_images/1987062-51c2e9112e90eeef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里可以看到Vue$3这个方法，就是这个方法对Vue对象的构造函数了。其实这很简单，我们自己都可以造出一个Vue$4\n```\n    function Vue$4(options) {\n        this.options = options\n    }\n\n    Vue$4.prototype.name = \"小东西\"\n    Vue$4.prototype.age = 27\n\n    console.log(new Vue$4(\"很好\"))\n```\n显示结果如图\n![vue$4](http://upload-images.jianshu.io/upload_images/1987062-ff4ba64d71f9d5b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n综上所述，Vue对象的本质就是一个function，与我们的Vue$4的不同之处只在于逻辑的多与少。\n\n# 必须理解Object对象\n在Vue的源码中，出场率最多的应该就数`Object`对象的使用上了。可以这么说，不懂Object都没法往下看代码。以下是源码中用到的比较多的。\n\n* [Object.defineProperty](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。\n* [Object.create](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create) 使用指定的原型对象及其属性去创建一个新的对象。\n* [Object.keys](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys) 返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。\n* [Object.prototype](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype) Object的原型对象。\n* [Object.freeze](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) 冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。\n\n那么，Vue中哪个是Object呢？我们继续试验：\n```\nconsole.log(typeof Vue)\nconsole.log(typeof new Vue())\n```\n输出结果\n```\nfunction\nobject\n```\n结果显示，使用new来创建的Vue实例就是个对象，所以一切对Object的操作行为都是针对Vue实例对象的。\n\n# 理解setter和getter\n在网上看Vue的评论是经常会听到说\n\n> Vue无非就是setter和getter方法的运用而已\n\n这让我等新手一脸懵逼，这里我们就来认识认识setter和getter。\n当我们在获取一个Vue实例data中的某个对象，如果你用console打印出来会发现，对象属性中除了常规的对象属性和__proto__对象之外还会多一个set和一个get方法，所谓的setter和getter就是它们。Vue给每一个对象属性都添加了Observer观察数据的获取和修改。好吧，贴代码一睹真容。\n```\nfunction defineReactive (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  // Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。\n  //（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）\n  // 对象、属性名称、描述~\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  // 当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) { // Watcher\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (\"development\" !== 'production' && customSetter) {\n        customSetter(); // 自定义setter\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n```\n代码太长？懵逼了？没关系，我们自己来造一个简单的setter和getter来了解一下。\n其实用的就是Object.defineProperty方法中就有set和get。\n\n* get 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。\n* set 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。\n\n好了，写代码~\n```\n    var obj = {}\n    var mValue = \"abc\"\n    Object.defineProperty(obj, \"_name\", {\n        configurable: false, \n        enumerable: false, \n        get: function reactiveGetter () {\n            return mValue\n        },\n        set: function reactiveSetter (val) {\n            mValue = val\n        }\n    })\n\n    obj._name = \"rose\"\n\n    console.log(obj)\n```\n到这里我们打印log，对象属性的set和get方法就出现了。\n![打印结果](http://upload-images.jianshu.io/upload_images/1987062-c11e06d42cf94a2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n# 逻辑运算符的使用\n在源码中有很多[逻辑运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_Operators)的使用，有些运用的很巧妙。这里也科普下吧~\n\n首先知道下可以转换成false的值，如下：\n* null\n* NaN\n* 0\n* 空字符串（\"\"）\n* undefined\n\n### 用法一：判断条件返回true或者false\n这是最基本的用法。\n```\nif (a & a.master & a.master.name) {} // 如果这三个属性都为true值，执行if逻辑\nif (a || b) {} // 如果a或者b为true值，执行if逻辑。\n```\n### 用法二：判断并返回条件对象\n\n* `&&` 如果几个条件都为true，则返回最后一个条件。\n* `||` 几个条件从前往后逐一判断，如果那个条件为true，返回该条件，否则返回最后一个条件。\n```\nvar getter = property && property.get;  // 如果两个属性都存在，将property.get赋值给getter\ne && e.__ob__ && e.__ob__.dep.depend(); // 如果三个属性都存在，执行第三条语句的方法\nvar res = assets[id] || assets[camelizedId] || assets[PascalCaseId]; \n// 给res赋值，如果assets[id]为true，则将其传res；\n// 如果assets[camelizedId]为true，将其传给res；\n// 如果前两者都为false，将assets[PascalCaseId]传给res。\nvar strat = strats[key] || defaultStrat;\n```\n然后，我对各种情况做了试验得出以下结论：\n\n* `&&` 判断中，判断值都为 `true`，返回最后一个判断值；判断值中有 `false`\n 值，返回第一个 `false` 值。\n* `||` 判断中，判断值都为 `true`，返回第一个判断值；判断值中有 `true` 值也有 `false` 值，返回第一个为 `true` 的判断值；如果判断值都为 `false`，返回最后面的 `false` 值。\n\n**注意：**这里所说的返回 `false` 值不一定是 Boolean 类型的 `false`，也可能是 `0、null` 等非值，详见上文。\n\n### 用法三：使用两个非\n两个感叹号会确保参数为非值时只能为false，不会是0、空字符串、undefined等非值。\n```\nif (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n```\n\n# 数组操作\n### 复制\n先看一段代码。\n```\n  var a = [ 'jack', 'rose', 'wade' ]\n  var b = a\n  b[1] = 'marry'\n  console.log(a)\n  console.log(b)\n```\n最后的结果是a和b的数组第二个值都变成了marry，原因就是b并不是获得了数组内容，而只是指向了a，a和b其实是一回事。如果我们需要复制，可以这么写：\n```\n  var b = a.slice()\n```\n查阅[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)可知：\n > slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，原始数组不会被修改。\n### 清空\n想要将非空数组的内容清空，最快捷的方式如下：\n```\narr.length = 0\n```\n### 合并\n直接引用[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)的例子。\n> concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。\n```\nvar arr1 = ['a', 'b', 'c'];\nvar arr2 = ['d', 'e', 'f'];\n\nvar arr3 = arr1.concat(arr2);\n\n// arr3 is a new array [ \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" ]\n```\n### 遍历\n呃，使用forEach方式来遍历数组是我刚知道的事 - -（之前都是用的for方法……），顺便记录下。\n```\narr.forEach(function(obj){\n    // 数组循环\n})\n```\n# 几种特殊的写法\n在代码中有些代码片段有些看不懂，于是在SF上进行了提问：[看Vue源码，有两段代码写法不知是何意思，求指教~](https://segmentfault.com/q/1010000012573448)。感谢大家的帮助，这里总结下。\n第一段是一段在{}里的代码。\n```\n{\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n}\n```\n这段代码，有的朋友说是块级作用域、隔离作用域。不过另一种说法更可信。那就是我所看到的vue是编译完的的代码。源代码其实在大括号前是有条件的。\n```\nif (process.env.NODE_ENV !== 'production') {\n  ...\n```\n再来看下面的代码\n```\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global.Vue = factory());\n}(this, (function () { 'use strict';\n\n})))\n```\n这段代码是Vue开头的一段代码，它有两个知识点。\n* 立即执行函数 —— 定义函数并立即执行，写法有 `(function(){})()` 或者 `(function(){}())` 的形式。\n* 由于过去前端没有模块系统，使用script标签引入的js脚本共享同一个作用域，如果不把代码包起来，很容易产生作用域污染、变量冲突的问题。\n\n**PS：**这两个问题真是网友的结论，不一定完善。有空我会查资料证实~\n\n# 其他知识点\n*  [Arguments](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments) —— 传给函数的参数数组\n* [new运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new) —— 通过构造函数创建对象\n* `\"development\" !== 'production’`的作用 —— webpack打包判断执行环境是不是生产环境，如果是生产环境会压缩并且没有提示警告之类的东西\n* [ instanceof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof) —— 验证实例对象是否为该构造函数new出来的。\n* [in关键字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in) —— 判断某个值是否在数组或对象中。\n* [Proxy对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy) —— 创建某个对象，并定义一些行为给该对象。\n* 字符串的 `charAt` 是获取第几个字符，而 `slice` 方法是截取某段字符。\n* [delete关键字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete) —— 用于删除对象中的某个关键字。\n* [call()方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call) —— 函数的调用，第一个参数为this，之后为函数定义参数。试验了下 `fun(a, b)` 和 `fun.call(this, a, b)` 两种写法效果一致。另外还可以看下 [apply()方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)\n\n**PS：**都是从MDN中找到的资料，多查MDN让我受益良多。\n\n\n\n# 未完待续\n还在学习Vue源码中……看了很多文章、也看了一遍源码。内容太多，千头万绪，容我理清之后，用自己的文字把Vue的源码学习记录分享出来。一些值得记录下来的知识点和心得会继续在本文中更新。\n最后，想学习Vue源码的同学可以去买[《Vue.js权威指南》](https://item.jd.com/12028224.html?dist=jd)这本书，虽然许多章节内容和[官网](https://cn.vuejs.org/v2/guide/)是重复的，不过源码解析部分值得一看。我也正配合着这本书和源码在学习Vue。\n\n\n","slug":"Vue源码学习笔记","published":1,"updated":"2018-02-07T02:28:06.353Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjddwxbmm000ci8btvxypznoq","content":"<blockquote>\n<p>最近偷懒好久没有写博客了，一直想继续Vue学习系列，想深入Vue源码来写。结果发现自己层次不够，对js的理解差好多。所以一直想写一直搁置着。最近重新振作决心看完Vue源码，并且以我们这类前端小白的角度来一步步弄懂Vue源码。</p>\n</blockquote>\n<p><strong>PS：</strong>以下文章为笔记类，记录了本人在看源码过程中的一些问题和感悟。</p>\n<h1 id=\"Vue源码的本质是什么\"><a href=\"#Vue源码的本质是什么\" class=\"headerlink\" title=\"Vue源码的本质是什么\"></a>Vue源码的本质是什么</h1><p>Vue.js 本质上就是一个包含各种逻辑的一个function。而我们通常初始化Vue的过程就是实例化的过程。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm = new Vue(&#123;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>话不多说，老规矩用代码说话！<br>让我们来对Vue进行打印：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Vue)</span><br><span class=\"line\">console.log(vm)</span><br></pre></td></tr></table></figure></p>\n<p>打印结果如图：<br><img src=\"http://upload-images.jianshu.io/upload_images/1987062-51c2e9112e90eeef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"vue\"></p>\n<p>这里可以看到Vue$3这个方法，就是这个方法对Vue对象的构造函数了。其实这很简单，我们自己都可以造出一个Vue$4<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Vue$4(options) &#123;</span><br><span class=\"line\">    this.options = options</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue$4.prototype.name = &quot;小东西&quot;</span><br><span class=\"line\">Vue$4.prototype.age = 27</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(new Vue$4(&quot;很好&quot;))</span><br></pre></td></tr></table></figure></p>\n<p>显示结果如图<br><img src=\"http://upload-images.jianshu.io/upload_images/1987062-ff4ba64d71f9d5b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"vue$4\"></p>\n<p>综上所述，Vue对象的本质就是一个function，与我们的Vue$4的不同之处只在于逻辑的多与少。</p>\n<h1 id=\"必须理解Object对象\"><a href=\"#必须理解Object对象\" class=\"headerlink\" title=\"必须理解Object对象\"></a>必须理解Object对象</h1><p>在Vue的源码中，出场率最多的应该就数<code>Object</code>对象的使用上了。可以这么说，不懂Object都没法往下看代码。以下是源码中用到的比较多的。</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" target=\"_blank\" rel=\"noopener\">Object.defineProperty</a> 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create\" target=\"_blank\" rel=\"noopener\">Object.create</a> 使用指定的原型对象及其属性去创建一个新的对象。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\" target=\"_blank\" rel=\"noopener\">Object.keys</a> 返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype\" target=\"_blank\" rel=\"noopener\">Object.prototype</a> Object的原型对象。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\" target=\"_blank\" rel=\"noopener\">Object.freeze</a> 冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。</li>\n</ul>\n<p>那么，Vue中哪个是Object呢？我们继续试验：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(typeof Vue)</span><br><span class=\"line\">console.log(typeof new Vue())</span><br></pre></td></tr></table></figure></p>\n<p>输出结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function</span><br><span class=\"line\">object</span><br></pre></td></tr></table></figure></p>\n<p>结果显示，使用new来创建的Vue实例就是个对象，所以一切对Object的操作行为都是针对Vue实例对象的。</p>\n<h1 id=\"理解setter和getter\"><a href=\"#理解setter和getter\" class=\"headerlink\" title=\"理解setter和getter\"></a>理解setter和getter</h1><p>在网上看Vue的评论是经常会听到说</p>\n<blockquote>\n<p>Vue无非就是setter和getter方法的运用而已</p>\n</blockquote>\n<p>这让我等新手一脸懵逼，这里我们就来认识认识setter和getter。<br>当我们在获取一个Vue实例data中的某个对象，如果你用console打印出来会发现，对象属性中除了常规的对象属性和<strong>proto</strong>对象之外还会多一个set和一个get方法，所谓的setter和getter就是它们。Vue给每一个对象属性都添加了Observer观察数据的获取和修改。好吧，贴代码一睹真容。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function defineReactive (</span><br><span class=\"line\">  obj,</span><br><span class=\"line\">  key,</span><br><span class=\"line\">  val,</span><br><span class=\"line\">  customSetter,</span><br><span class=\"line\">  shallow</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  var dep = new Dep();</span><br><span class=\"line\"></span><br><span class=\"line\">  // Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。</span><br><span class=\"line\">  //（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</span><br><span class=\"line\">  // 对象、属性名称、描述~</span><br><span class=\"line\">  var property = Object.getOwnPropertyDescriptor(obj, key);</span><br><span class=\"line\">  // 当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</span><br><span class=\"line\">  if (property &amp;&amp; property.configurable === false) &#123;</span><br><span class=\"line\">    return</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // cater for pre-defined getter/setters</span><br><span class=\"line\">  var getter = property &amp;&amp; property.get;</span><br><span class=\"line\">  var setter = property &amp;&amp; property.set;</span><br><span class=\"line\"></span><br><span class=\"line\">  var childOb = !shallow &amp;&amp; observe(val);</span><br><span class=\"line\">  Object.defineProperty(obj, key, &#123;</span><br><span class=\"line\">    enumerable: true,</span><br><span class=\"line\">    configurable: true,</span><br><span class=\"line\">    get: function reactiveGetter () &#123;</span><br><span class=\"line\">      var value = getter ? getter.call(obj) : val;</span><br><span class=\"line\">      if (Dep.target) &#123; // Watcher</span><br><span class=\"line\">        dep.depend();</span><br><span class=\"line\">        if (childOb) &#123;</span><br><span class=\"line\">          childOb.dep.depend();</span><br><span class=\"line\">          if (Array.isArray(value)) &#123;</span><br><span class=\"line\">            dependArray(value);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return value</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: function reactiveSetter (newVal) &#123;</span><br><span class=\"line\">      var value = getter ? getter.call(obj) : val;</span><br><span class=\"line\">      /* eslint-disable no-self-compare */</span><br><span class=\"line\">      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      /* eslint-enable no-self-compare */</span><br><span class=\"line\">      if (&quot;development&quot; !== &apos;production&apos; &amp;&amp; customSetter) &#123;</span><br><span class=\"line\">        customSetter(); // 自定义setter</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (setter) &#123;</span><br><span class=\"line\">        setter.call(obj, newVal);</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        val = newVal;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class=\"line\">      dep.notify();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码太长？懵逼了？没关系，我们自己来造一个简单的setter和getter来了解一下。<br>其实用的就是Object.defineProperty方法中就有set和get。</p>\n<ul>\n<li>get 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。</li>\n<li>set 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。</li>\n</ul>\n<p>好了，写代码~<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;&#125;</span><br><span class=\"line\">var mValue = &quot;abc&quot;</span><br><span class=\"line\">Object.defineProperty(obj, &quot;_name&quot;, &#123;</span><br><span class=\"line\">    configurable: false, </span><br><span class=\"line\">    enumerable: false, </span><br><span class=\"line\">    get: function reactiveGetter () &#123;</span><br><span class=\"line\">        return mValue</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: function reactiveSetter (val) &#123;</span><br><span class=\"line\">        mValue = val</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">obj._name = &quot;rose&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(obj)</span><br></pre></td></tr></table></figure></p>\n<p>到这里我们打印log，对象属性的set和get方法就出现了。<br><img src=\"http://upload-images.jianshu.io/upload_images/1987062-c11e06d42cf94a2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"打印结果\"></p>\n<h1 id=\"逻辑运算符的使用\"><a href=\"#逻辑运算符的使用\" class=\"headerlink\" title=\"逻辑运算符的使用\"></a>逻辑运算符的使用</h1><p>在源码中有很多<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_Operators\" target=\"_blank\" rel=\"noopener\">逻辑运算符</a>的使用，有些运用的很巧妙。这里也科普下吧~</p>\n<p>首先知道下可以转换成false的值，如下：</p>\n<ul>\n<li>null</li>\n<li>NaN</li>\n<li>0</li>\n<li>空字符串（””）</li>\n<li>undefined</li>\n</ul>\n<h3 id=\"用法一：判断条件返回true或者false\"><a href=\"#用法一：判断条件返回true或者false\" class=\"headerlink\" title=\"用法一：判断条件返回true或者false\"></a>用法一：判断条件返回true或者false</h3><p>这是最基本的用法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (a &amp; a.master &amp; a.master.name) &#123;&#125; // 如果这三个属性都为true值，执行if逻辑</span><br><span class=\"line\">if (a || b) &#123;&#125; // 如果a或者b为true值，执行if逻辑。</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"用法二：判断并返回条件对象\"><a href=\"#用法二：判断并返回条件对象\" class=\"headerlink\" title=\"用法二：判断并返回条件对象\"></a>用法二：判断并返回条件对象</h3><ul>\n<li><code>&amp;&amp;</code> 如果几个条件都为true，则返回最后一个条件。</li>\n<li><code>||</code> 几个条件从前往后逐一判断，如果那个条件为true，返回该条件，否则返回最后一个条件。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var getter = property &amp;&amp; property.get;  // 如果两个属性都存在，将property.get赋值给getter</span><br><span class=\"line\">e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend(); // 如果三个属性都存在，执行第三条语句的方法</span><br><span class=\"line\">var res = assets[id] || assets[camelizedId] || assets[PascalCaseId]; </span><br><span class=\"line\">// 给res赋值，如果assets[id]为true，则将其传res；</span><br><span class=\"line\">// 如果assets[camelizedId]为true，将其传给res；</span><br><span class=\"line\">// 如果前两者都为false，将assets[PascalCaseId]传给res。</span><br><span class=\"line\">var strat = strats[key] || defaultStrat;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>然后，我对各种情况做了试验得出以下结论：</p>\n<ul>\n<li><code>&amp;&amp;</code> 判断中，判断值都为 <code>true</code>，返回最后一个判断值；判断值中有 <code>false</code><br>值，返回第一个 <code>false</code> 值。</li>\n<li><code>||</code> 判断中，判断值都为 <code>true</code>，返回第一个判断值；判断值中有 <code>true</code> 值也有 <code>false</code> 值，返回第一个为 <code>true</code> 的判断值；如果判断值都为 <code>false</code>，返回最后面的 <code>false</code> 值。</li>\n</ul>\n<p><strong>注意：</strong>这里所说的返回 <code>false</code> 值不一定是 Boolean 类型的 <code>false</code>，也可能是 <code>0、null</code> 等非值，详见上文。</p>\n<h3 id=\"用法三：使用两个非\"><a href=\"#用法三：使用两个非\" class=\"headerlink\" title=\"用法三：使用两个非\"></a>用法三：使用两个非</h3><p>两个感叹号会确保参数为非值时只能为false，不会是0、空字符串、undefined等非值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (options) &#123;</span><br><span class=\"line\">    this.deep = !!options.deep;</span><br><span class=\"line\">    this.user = !!options.user;</span><br><span class=\"line\">    this.lazy = !!options.lazy;</span><br><span class=\"line\">    this.sync = !!options.sync;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    this.deep = this.user = this.lazy = this.sync = false;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"数组操作\"><a href=\"#数组操作\" class=\"headerlink\" title=\"数组操作\"></a>数组操作</h1><h3 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h3><p>先看一段代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = [ &apos;jack&apos;, &apos;rose&apos;, &apos;wade&apos; ]</span><br><span class=\"line\">var b = a</span><br><span class=\"line\">b[1] = &apos;marry&apos;</span><br><span class=\"line\">console.log(a)</span><br><span class=\"line\">console.log(b)</span><br></pre></td></tr></table></figure></p>\n<p>最后的结果是a和b的数组第二个值都变成了marry，原因就是b并不是获得了数组内容，而只是指向了a，a和b其实是一回事。如果我们需要复制，可以这么写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var b = a.slice()</span><br></pre></td></tr></table></figure></p>\n<p>查阅<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\" target=\"_blank\" rel=\"noopener\">MDN</a>可知：</p>\n<blockquote>\n<p>slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，原始数组不会被修改。</p>\n<h3 id=\"清空\"><a href=\"#清空\" class=\"headerlink\" title=\"清空\"></a>清空</h3><p>想要将非空数组的内容清空，最快捷的方式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.length = 0</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h3><p>直接引用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat\" target=\"_blank\" rel=\"noopener\">MDN</a>的例子。</p>\n<blockquote>\n<p>concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class=\"line\">var arr2 = [&apos;d&apos;, &apos;e&apos;, &apos;f&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">var arr3 = arr1.concat(arr2);</span><br><span class=\"line\"></span><br><span class=\"line\">// arr3 is a new array [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot; ]</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h3><p>呃，使用forEach方式来遍历数组是我刚知道的事 - -（之前都是用的for方法……），顺便记录下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.forEach(function(obj)&#123;</span><br><span class=\"line\">    // 数组循环</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"几种特殊的写法\"><a href=\"#几种特殊的写法\" class=\"headerlink\" title=\"几种特殊的写法\"></a>几种特殊的写法</h1><p>在代码中有些代码片段有些看不懂，于是在SF上进行了提问：<a href=\"https://segmentfault.com/q/1010000012573448\" target=\"_blank\" rel=\"noopener\">看Vue源码，有两段代码写法不知是何意思，求指教~</a>。感谢大家的帮助，这里总结下。<br>第一段是一段在{}里的代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    dataDef.set = function (newData) &#123;</span><br><span class=\"line\">      warn(</span><br><span class=\"line\">        &apos;Avoid replacing instance root $data. &apos; +</span><br><span class=\"line\">        &apos;Use nested data properties instead.&apos;,</span><br><span class=\"line\">        this</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    propsDef.set = function () &#123;</span><br><span class=\"line\">      warn(&quot;$props is readonly.&quot;, this);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码，有的朋友说是块级作用域、隔离作用域。不过另一种说法更可信。那就是我所看到的vue是编译完的的代码。源代码其实在大括号前是有条件的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure></p>\n<p>再来看下面的代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function (global, factory) &#123;</span><br><span class=\"line\">    typeof exports === &apos;object&apos; &amp;&amp; typeof module !== &apos;undefined&apos; ? module.exports = factory() :</span><br><span class=\"line\">    typeof define === &apos;function&apos; &amp;&amp; define.amd ? define(factory) :</span><br><span class=\"line\">    (global.Vue = factory());</span><br><span class=\"line\">&#125;(this, (function () &#123; &apos;use strict&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)))</span><br></pre></td></tr></table></figure></p>\n<p>这段代码是Vue开头的一段代码，它有两个知识点。</p>\n<ul>\n<li>立即执行函数 —— 定义函数并立即执行，写法有 <code>(function(){})()</code> 或者 <code>(function(){}())</code> 的形式。</li>\n<li>由于过去前端没有模块系统，使用script标签引入的js脚本共享同一个作用域，如果不把代码包起来，很容易产生作用域污染、变量冲突的问题。</li>\n</ul>\n<p><strong>PS：</strong>这两个问题真是网友的结论，不一定完善。有空我会查资料证实~</p>\n<h1 id=\"其他知识点\"><a href=\"#其他知识点\" class=\"headerlink\" title=\"其他知识点\"></a>其他知识点</h1><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments\" target=\"_blank\" rel=\"noopener\">Arguments</a> —— 传给函数的参数数组</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new\" target=\"_blank\" rel=\"noopener\">new运算符</a> —— 通过构造函数创建对象</li>\n<li><code>&quot;development&quot; !== &#39;production’</code>的作用 —— webpack打包判断执行环境是不是生产环境，如果是生产环境会压缩并且没有提示警告之类的东西</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof\" target=\"_blank\" rel=\"noopener\"> instanceof</a> —— 验证实例对象是否为该构造函数new出来的。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in\" target=\"_blank\" rel=\"noopener\">in关键字</a> —— 判断某个值是否在数组或对象中。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\" target=\"_blank\" rel=\"noopener\">Proxy对象</a> —— 创建某个对象，并定义一些行为给该对象。</li>\n<li>字符串的 <code>charAt</code> 是获取第几个字符，而 <code>slice</code> 方法是截取某段字符。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete\" target=\"_blank\" rel=\"noopener\">delete关键字</a> —— 用于删除对象中的某个关键字。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call\" target=\"_blank\" rel=\"noopener\">call()方法</a> —— 函数的调用，第一个参数为this，之后为函数定义参数。试验了下 <code>fun(a, b)</code> 和 <code>fun.call(this, a, b)</code> 两种写法效果一致。另外还可以看下 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\" target=\"_blank\" rel=\"noopener\">apply()方法</a></li>\n</ul>\n<p><strong>PS：</strong>都是从MDN中找到的资料，多查MDN让我受益良多。</p>\n<h1 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h1><p>还在学习Vue源码中……看了很多文章、也看了一遍源码。内容太多，千头万绪，容我理清之后，用自己的文字把Vue的源码学习记录分享出来。一些值得记录下来的知识点和心得会继续在本文中更新。<br>最后，想学习Vue源码的同学可以去买<a href=\"https://item.jd.com/12028224.html?dist=jd\" target=\"_blank\" rel=\"noopener\">《Vue.js权威指南》</a>这本书，虽然许多章节内容和<a href=\"https://cn.vuejs.org/v2/guide/\" target=\"_blank\" rel=\"noopener\">官网</a>是重复的，不过源码解析部分值得一看。我也正配合着这本书和源码在学习Vue。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近偷懒好久没有写博客了，一直想继续Vue学习系列，想深入Vue源码来写。结果发现自己层次不够，对js的理解差好多。所以一直想写一直搁置着。最近重新振作决心看完Vue源码，并且以我们这类前端小白的角度来一步步弄懂Vue源码。</p>\n</blockquote>\n<p><strong>PS：</strong>以下文章为笔记类，记录了本人在看源码过程中的一些问题和感悟。</p>\n<h1 id=\"Vue源码的本质是什么\"><a href=\"#Vue源码的本质是什么\" class=\"headerlink\" title=\"Vue源码的本质是什么\"></a>Vue源码的本质是什么</h1><p>Vue.js 本质上就是一个包含各种逻辑的一个function。而我们通常初始化Vue的过程就是实例化的过程。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm = new Vue(&#123;&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>话不多说，老规矩用代码说话！<br>让我们来对Vue进行打印：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Vue)</span><br><span class=\"line\">console.log(vm)</span><br></pre></td></tr></table></figure></p>\n<p>打印结果如图：<br><img src=\"http://upload-images.jianshu.io/upload_images/1987062-51c2e9112e90eeef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"vue\"></p>\n<p>这里可以看到Vue$3这个方法，就是这个方法对Vue对象的构造函数了。其实这很简单，我们自己都可以造出一个Vue$4<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Vue$4(options) &#123;</span><br><span class=\"line\">    this.options = options</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue$4.prototype.name = &quot;小东西&quot;</span><br><span class=\"line\">Vue$4.prototype.age = 27</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(new Vue$4(&quot;很好&quot;))</span><br></pre></td></tr></table></figure></p>\n<p>显示结果如图<br><img src=\"http://upload-images.jianshu.io/upload_images/1987062-ff4ba64d71f9d5b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"vue$4\"></p>\n<p>综上所述，Vue对象的本质就是一个function，与我们的Vue$4的不同之处只在于逻辑的多与少。</p>\n<h1 id=\"必须理解Object对象\"><a href=\"#必须理解Object对象\" class=\"headerlink\" title=\"必须理解Object对象\"></a>必须理解Object对象</h1><p>在Vue的源码中，出场率最多的应该就数<code>Object</code>对象的使用上了。可以这么说，不懂Object都没法往下看代码。以下是源码中用到的比较多的。</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" target=\"_blank\" rel=\"noopener\">Object.defineProperty</a> 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create\" target=\"_blank\" rel=\"noopener\">Object.create</a> 使用指定的原型对象及其属性去创建一个新的对象。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\" target=\"_blank\" rel=\"noopener\">Object.keys</a> 返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype\" target=\"_blank\" rel=\"noopener\">Object.prototype</a> Object的原型对象。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\" target=\"_blank\" rel=\"noopener\">Object.freeze</a> 冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。</li>\n</ul>\n<p>那么，Vue中哪个是Object呢？我们继续试验：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(typeof Vue)</span><br><span class=\"line\">console.log(typeof new Vue())</span><br></pre></td></tr></table></figure></p>\n<p>输出结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function</span><br><span class=\"line\">object</span><br></pre></td></tr></table></figure></p>\n<p>结果显示，使用new来创建的Vue实例就是个对象，所以一切对Object的操作行为都是针对Vue实例对象的。</p>\n<h1 id=\"理解setter和getter\"><a href=\"#理解setter和getter\" class=\"headerlink\" title=\"理解setter和getter\"></a>理解setter和getter</h1><p>在网上看Vue的评论是经常会听到说</p>\n<blockquote>\n<p>Vue无非就是setter和getter方法的运用而已</p>\n</blockquote>\n<p>这让我等新手一脸懵逼，这里我们就来认识认识setter和getter。<br>当我们在获取一个Vue实例data中的某个对象，如果你用console打印出来会发现，对象属性中除了常规的对象属性和<strong>proto</strong>对象之外还会多一个set和一个get方法，所谓的setter和getter就是它们。Vue给每一个对象属性都添加了Observer观察数据的获取和修改。好吧，贴代码一睹真容。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function defineReactive (</span><br><span class=\"line\">  obj,</span><br><span class=\"line\">  key,</span><br><span class=\"line\">  val,</span><br><span class=\"line\">  customSetter,</span><br><span class=\"line\">  shallow</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  var dep = new Dep();</span><br><span class=\"line\"></span><br><span class=\"line\">  // Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。</span><br><span class=\"line\">  //（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</span><br><span class=\"line\">  // 对象、属性名称、描述~</span><br><span class=\"line\">  var property = Object.getOwnPropertyDescriptor(obj, key);</span><br><span class=\"line\">  // 当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</span><br><span class=\"line\">  if (property &amp;&amp; property.configurable === false) &#123;</span><br><span class=\"line\">    return</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // cater for pre-defined getter/setters</span><br><span class=\"line\">  var getter = property &amp;&amp; property.get;</span><br><span class=\"line\">  var setter = property &amp;&amp; property.set;</span><br><span class=\"line\"></span><br><span class=\"line\">  var childOb = !shallow &amp;&amp; observe(val);</span><br><span class=\"line\">  Object.defineProperty(obj, key, &#123;</span><br><span class=\"line\">    enumerable: true,</span><br><span class=\"line\">    configurable: true,</span><br><span class=\"line\">    get: function reactiveGetter () &#123;</span><br><span class=\"line\">      var value = getter ? getter.call(obj) : val;</span><br><span class=\"line\">      if (Dep.target) &#123; // Watcher</span><br><span class=\"line\">        dep.depend();</span><br><span class=\"line\">        if (childOb) &#123;</span><br><span class=\"line\">          childOb.dep.depend();</span><br><span class=\"line\">          if (Array.isArray(value)) &#123;</span><br><span class=\"line\">            dependArray(value);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return value</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: function reactiveSetter (newVal) &#123;</span><br><span class=\"line\">      var value = getter ? getter.call(obj) : val;</span><br><span class=\"line\">      /* eslint-disable no-self-compare */</span><br><span class=\"line\">      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      /* eslint-enable no-self-compare */</span><br><span class=\"line\">      if (&quot;development&quot; !== &apos;production&apos; &amp;&amp; customSetter) &#123;</span><br><span class=\"line\">        customSetter(); // 自定义setter</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (setter) &#123;</span><br><span class=\"line\">        setter.call(obj, newVal);</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        val = newVal;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class=\"line\">      dep.notify();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码太长？懵逼了？没关系，我们自己来造一个简单的setter和getter来了解一下。<br>其实用的就是Object.defineProperty方法中就有set和get。</p>\n<ul>\n<li>get 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。</li>\n<li>set 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。</li>\n</ul>\n<p>好了，写代码~<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;&#125;</span><br><span class=\"line\">var mValue = &quot;abc&quot;</span><br><span class=\"line\">Object.defineProperty(obj, &quot;_name&quot;, &#123;</span><br><span class=\"line\">    configurable: false, </span><br><span class=\"line\">    enumerable: false, </span><br><span class=\"line\">    get: function reactiveGetter () &#123;</span><br><span class=\"line\">        return mValue</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: function reactiveSetter (val) &#123;</span><br><span class=\"line\">        mValue = val</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">obj._name = &quot;rose&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(obj)</span><br></pre></td></tr></table></figure></p>\n<p>到这里我们打印log，对象属性的set和get方法就出现了。<br><img src=\"http://upload-images.jianshu.io/upload_images/1987062-c11e06d42cf94a2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"打印结果\"></p>\n<h1 id=\"逻辑运算符的使用\"><a href=\"#逻辑运算符的使用\" class=\"headerlink\" title=\"逻辑运算符的使用\"></a>逻辑运算符的使用</h1><p>在源码中有很多<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_Operators\" target=\"_blank\" rel=\"noopener\">逻辑运算符</a>的使用，有些运用的很巧妙。这里也科普下吧~</p>\n<p>首先知道下可以转换成false的值，如下：</p>\n<ul>\n<li>null</li>\n<li>NaN</li>\n<li>0</li>\n<li>空字符串（””）</li>\n<li>undefined</li>\n</ul>\n<h3 id=\"用法一：判断条件返回true或者false\"><a href=\"#用法一：判断条件返回true或者false\" class=\"headerlink\" title=\"用法一：判断条件返回true或者false\"></a>用法一：判断条件返回true或者false</h3><p>这是最基本的用法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (a &amp; a.master &amp; a.master.name) &#123;&#125; // 如果这三个属性都为true值，执行if逻辑</span><br><span class=\"line\">if (a || b) &#123;&#125; // 如果a或者b为true值，执行if逻辑。</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"用法二：判断并返回条件对象\"><a href=\"#用法二：判断并返回条件对象\" class=\"headerlink\" title=\"用法二：判断并返回条件对象\"></a>用法二：判断并返回条件对象</h3><ul>\n<li><code>&amp;&amp;</code> 如果几个条件都为true，则返回最后一个条件。</li>\n<li><code>||</code> 几个条件从前往后逐一判断，如果那个条件为true，返回该条件，否则返回最后一个条件。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var getter = property &amp;&amp; property.get;  // 如果两个属性都存在，将property.get赋值给getter</span><br><span class=\"line\">e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend(); // 如果三个属性都存在，执行第三条语句的方法</span><br><span class=\"line\">var res = assets[id] || assets[camelizedId] || assets[PascalCaseId]; </span><br><span class=\"line\">// 给res赋值，如果assets[id]为true，则将其传res；</span><br><span class=\"line\">// 如果assets[camelizedId]为true，将其传给res；</span><br><span class=\"line\">// 如果前两者都为false，将assets[PascalCaseId]传给res。</span><br><span class=\"line\">var strat = strats[key] || defaultStrat;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>然后，我对各种情况做了试验得出以下结论：</p>\n<ul>\n<li><code>&amp;&amp;</code> 判断中，判断值都为 <code>true</code>，返回最后一个判断值；判断值中有 <code>false</code><br>值，返回第一个 <code>false</code> 值。</li>\n<li><code>||</code> 判断中，判断值都为 <code>true</code>，返回第一个判断值；判断值中有 <code>true</code> 值也有 <code>false</code> 值，返回第一个为 <code>true</code> 的判断值；如果判断值都为 <code>false</code>，返回最后面的 <code>false</code> 值。</li>\n</ul>\n<p><strong>注意：</strong>这里所说的返回 <code>false</code> 值不一定是 Boolean 类型的 <code>false</code>，也可能是 <code>0、null</code> 等非值，详见上文。</p>\n<h3 id=\"用法三：使用两个非\"><a href=\"#用法三：使用两个非\" class=\"headerlink\" title=\"用法三：使用两个非\"></a>用法三：使用两个非</h3><p>两个感叹号会确保参数为非值时只能为false，不会是0、空字符串、undefined等非值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (options) &#123;</span><br><span class=\"line\">    this.deep = !!options.deep;</span><br><span class=\"line\">    this.user = !!options.user;</span><br><span class=\"line\">    this.lazy = !!options.lazy;</span><br><span class=\"line\">    this.sync = !!options.sync;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    this.deep = this.user = this.lazy = this.sync = false;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"数组操作\"><a href=\"#数组操作\" class=\"headerlink\" title=\"数组操作\"></a>数组操作</h1><h3 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h3><p>先看一段代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = [ &apos;jack&apos;, &apos;rose&apos;, &apos;wade&apos; ]</span><br><span class=\"line\">var b = a</span><br><span class=\"line\">b[1] = &apos;marry&apos;</span><br><span class=\"line\">console.log(a)</span><br><span class=\"line\">console.log(b)</span><br></pre></td></tr></table></figure></p>\n<p>最后的结果是a和b的数组第二个值都变成了marry，原因就是b并不是获得了数组内容，而只是指向了a，a和b其实是一回事。如果我们需要复制，可以这么写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var b = a.slice()</span><br></pre></td></tr></table></figure></p>\n<p>查阅<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\" target=\"_blank\" rel=\"noopener\">MDN</a>可知：</p>\n<blockquote>\n<p>slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，原始数组不会被修改。</p>\n<h3 id=\"清空\"><a href=\"#清空\" class=\"headerlink\" title=\"清空\"></a>清空</h3><p>想要将非空数组的内容清空，最快捷的方式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.length = 0</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h3><p>直接引用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat\" target=\"_blank\" rel=\"noopener\">MDN</a>的例子。</p>\n<blockquote>\n<p>concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class=\"line\">var arr2 = [&apos;d&apos;, &apos;e&apos;, &apos;f&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">var arr3 = arr1.concat(arr2);</span><br><span class=\"line\"></span><br><span class=\"line\">// arr3 is a new array [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot; ]</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h3><p>呃，使用forEach方式来遍历数组是我刚知道的事 - -（之前都是用的for方法……），顺便记录下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.forEach(function(obj)&#123;</span><br><span class=\"line\">    // 数组循环</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"几种特殊的写法\"><a href=\"#几种特殊的写法\" class=\"headerlink\" title=\"几种特殊的写法\"></a>几种特殊的写法</h1><p>在代码中有些代码片段有些看不懂，于是在SF上进行了提问：<a href=\"https://segmentfault.com/q/1010000012573448\" target=\"_blank\" rel=\"noopener\">看Vue源码，有两段代码写法不知是何意思，求指教~</a>。感谢大家的帮助，这里总结下。<br>第一段是一段在{}里的代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    dataDef.set = function (newData) &#123;</span><br><span class=\"line\">      warn(</span><br><span class=\"line\">        &apos;Avoid replacing instance root $data. &apos; +</span><br><span class=\"line\">        &apos;Use nested data properties instead.&apos;,</span><br><span class=\"line\">        this</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    propsDef.set = function () &#123;</span><br><span class=\"line\">      warn(&quot;$props is readonly.&quot;, this);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这段代码，有的朋友说是块级作用域、隔离作用域。不过另一种说法更可信。那就是我所看到的vue是编译完的的代码。源代码其实在大括号前是有条件的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure></p>\n<p>再来看下面的代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function (global, factory) &#123;</span><br><span class=\"line\">    typeof exports === &apos;object&apos; &amp;&amp; typeof module !== &apos;undefined&apos; ? module.exports = factory() :</span><br><span class=\"line\">    typeof define === &apos;function&apos; &amp;&amp; define.amd ? define(factory) :</span><br><span class=\"line\">    (global.Vue = factory());</span><br><span class=\"line\">&#125;(this, (function () &#123; &apos;use strict&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)))</span><br></pre></td></tr></table></figure></p>\n<p>这段代码是Vue开头的一段代码，它有两个知识点。</p>\n<ul>\n<li>立即执行函数 —— 定义函数并立即执行，写法有 <code>(function(){})()</code> 或者 <code>(function(){}())</code> 的形式。</li>\n<li>由于过去前端没有模块系统，使用script标签引入的js脚本共享同一个作用域，如果不把代码包起来，很容易产生作用域污染、变量冲突的问题。</li>\n</ul>\n<p><strong>PS：</strong>这两个问题真是网友的结论，不一定完善。有空我会查资料证实~</p>\n<h1 id=\"其他知识点\"><a href=\"#其他知识点\" class=\"headerlink\" title=\"其他知识点\"></a>其他知识点</h1><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments\" target=\"_blank\" rel=\"noopener\">Arguments</a> —— 传给函数的参数数组</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new\" target=\"_blank\" rel=\"noopener\">new运算符</a> —— 通过构造函数创建对象</li>\n<li><code>&quot;development&quot; !== &#39;production’</code>的作用 —— webpack打包判断执行环境是不是生产环境，如果是生产环境会压缩并且没有提示警告之类的东西</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof\" target=\"_blank\" rel=\"noopener\"> instanceof</a> —— 验证实例对象是否为该构造函数new出来的。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in\" target=\"_blank\" rel=\"noopener\">in关键字</a> —— 判断某个值是否在数组或对象中。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\" target=\"_blank\" rel=\"noopener\">Proxy对象</a> —— 创建某个对象，并定义一些行为给该对象。</li>\n<li>字符串的 <code>charAt</code> 是获取第几个字符，而 <code>slice</code> 方法是截取某段字符。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete\" target=\"_blank\" rel=\"noopener\">delete关键字</a> —— 用于删除对象中的某个关键字。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call\" target=\"_blank\" rel=\"noopener\">call()方法</a> —— 函数的调用，第一个参数为this，之后为函数定义参数。试验了下 <code>fun(a, b)</code> 和 <code>fun.call(this, a, b)</code> 两种写法效果一致。另外还可以看下 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\" target=\"_blank\" rel=\"noopener\">apply()方法</a></li>\n</ul>\n<p><strong>PS：</strong>都是从MDN中找到的资料，多查MDN让我受益良多。</p>\n<h1 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h1><p>还在学习Vue源码中……看了很多文章、也看了一遍源码。内容太多，千头万绪，容我理清之后，用自己的文字把Vue的源码学习记录分享出来。一些值得记录下来的知识点和心得会继续在本文中更新。<br>最后，想学习Vue源码的同学可以去买<a href=\"https://item.jd.com/12028224.html?dist=jd\" target=\"_blank\" rel=\"noopener\">《Vue.js权威指南》</a>这本书，虽然许多章节内容和<a href=\"https://cn.vuejs.org/v2/guide/\" target=\"_blank\" rel=\"noopener\">官网</a>是重复的，不过源码解析部分值得一看。我也正配合着这本书和源码在学习Vue。</p>\n"},{"title":"Weex控制Android返回键解决方案","date":"2016-06-29T16:00:00.000Z","_content":"\n> 正在深入倒腾weex，希望可以将weex用在项目中。这里找出了weex控制Android返回键的方法。\n\n# 需求\n项目使用的是Vue+VueRouter的单页应用来写Weex的，现有以下需求。\n\n* 当页面不在首页上时，返回上一页面。 `this.$router.go(-1)`\n*  当页面在首页是，关闭当前Android应用\n\n# 解决方案\n## Android和Weex的通信\n### Android to Weex\n使用的是[globalEvent](http://weex.apache.org/cn/references/modules/globalevent.html)来实现的。我们在 Android 的返回按钮事件中触发 `globalEvent`，在 Weex 中监听该 `globalEvent`。\n\n**Android**\n```\npublic void onBackPressed(){\n  Map<String,Object> params=new HashMap<>();\n  params.put(\"name\",\"returnmsg\");\n  mWXSDKInstance.fireGlobalEventCallback(\"androidback\",params);\n}\n```\n**Weex**\n```\nglobalEvent.addEventListener('androidback', function (e) {\n  // 这里就可以做返回事件操作了，如返回上一页或退出应用\n  // that.$router.go(-1)\n  // weex.requireModule('close').closeApp()\n})\n```\n### Weex to Android\n而Weex对Android的通信使用[Module扩展](http://weex.apache.org/cn/references/advanced/extend-to-android.html#Module-扩展)来实现。通过在Android中创建WXModule并在Application中注册后，Weex调用该Module触发Android事件。下面我们来一步步实现。\n\n**1. Android中创建CloseModule**\n```\npublic class CloseModule extends WXModule {\n\n    @JSMethod(uiThread = false)\n    public void closeApp() {\n        LogUtil.e(\"触发关闭效果\");\n        CacheActivity.finishActivity();\n    }\n}\n```\n**2. 在Application中注册Module**\n```\npublic class WXApplication extends Application {\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    InitConfig config = new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build();\n    WXSDKEngine.initialize(this, config);\n    try {\n      ...\n      WXSDKEngine.registerModule(\"close\", CloseModule.class);\n      ...\n    } catch (WXException e) {\n      e.printStackTrace();\n    }\n  }\n}\n```\n**3. 在Weex中使用**\n```\nweex.requireModule('close').closeApp()\n```\n这样调用Module之后就可以对Android做许多事情了。\n\n## 退出Activity\n这里我还遇到了一个问题，就是在Weex提供的WXModule中如何退出Activity，解决方案为[android 关闭多个或指定activity](http://www.cnblogs.com/jenson138/p/4516568.html),这篇文章让我可以非常优雅的管理我的Activity。简单写下用法.\n**1. 在每个Activity的onCreate方法中将Activity对象添加到List中**\n```\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  ...\n  CacheActivity.addActivity(NetworkActivity.this);\n}\n```\n**2. 在Module中去关闭Activity**\n```\nCacheActivity.finishActivity();\n```\n**3. 当然，别忘了把CacheActivity的代码贴到项目中去**\n```\npackage com.weex.sample.utlis;\n\nimport android.app.Activity;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class CacheActivity {\n    public static List<Activity> activityList = new LinkedList<Activity>();\n\n    public CacheActivity() {\n\n    }\n\n    /**\n     * 添加到Activity容器中\n     */\n    public static void addActivity(Activity activity) {\n        if (!activityList.contains(activity)) {\n            activityList.add(activity);\n        }\n    }\n\n    /**\n     * 便利所有Activigty并finish\n     */\n    public static void finishActivity() {\n        for (Activity activity : activityList) {\n            activity.finish();\n        }\n    }\n\n    /**\n     * 结束指定的Activity\n     */\n    public static void finishSingleActivity(Activity activity) {\n        if (activity != null) {\n            if (activityList.contains(activity)) {\n                activityList.remove(activity);\n            }\n            activity.finish();\n            activity = null;\n        }\n    }\n\n    /**\n     * 结束指定类名的Activity 在遍历一个列表的时候不能执行删除操作，所有我们先记住要删除的对象，遍历之后才去删除。\n     */\n    public static void finishSingleActivityByClass(Class<?> cls) {\n        Activity tempActivity = null;\n        for (Activity activity : activityList) {\n            if (activity.getClass().equals(cls)) {\n                tempActivity = activity;\n            }\n        }\n\n        finishSingleActivity(tempActivity);\n    }\n\n}\n```\n\nOver！继续倒腾Weex中……遇到问题继续总结。欢迎留言交流~","source":"_posts/Weex控制Android返回键解决方案.md","raw":"---\ntitle: Weex控制Android返回键解决方案\ndate: 2016-06-30\n---\n\n> 正在深入倒腾weex，希望可以将weex用在项目中。这里找出了weex控制Android返回键的方法。\n\n# 需求\n项目使用的是Vue+VueRouter的单页应用来写Weex的，现有以下需求。\n\n* 当页面不在首页上时，返回上一页面。 `this.$router.go(-1)`\n*  当页面在首页是，关闭当前Android应用\n\n# 解决方案\n## Android和Weex的通信\n### Android to Weex\n使用的是[globalEvent](http://weex.apache.org/cn/references/modules/globalevent.html)来实现的。我们在 Android 的返回按钮事件中触发 `globalEvent`，在 Weex 中监听该 `globalEvent`。\n\n**Android**\n```\npublic void onBackPressed(){\n  Map<String,Object> params=new HashMap<>();\n  params.put(\"name\",\"returnmsg\");\n  mWXSDKInstance.fireGlobalEventCallback(\"androidback\",params);\n}\n```\n**Weex**\n```\nglobalEvent.addEventListener('androidback', function (e) {\n  // 这里就可以做返回事件操作了，如返回上一页或退出应用\n  // that.$router.go(-1)\n  // weex.requireModule('close').closeApp()\n})\n```\n### Weex to Android\n而Weex对Android的通信使用[Module扩展](http://weex.apache.org/cn/references/advanced/extend-to-android.html#Module-扩展)来实现。通过在Android中创建WXModule并在Application中注册后，Weex调用该Module触发Android事件。下面我们来一步步实现。\n\n**1. Android中创建CloseModule**\n```\npublic class CloseModule extends WXModule {\n\n    @JSMethod(uiThread = false)\n    public void closeApp() {\n        LogUtil.e(\"触发关闭效果\");\n        CacheActivity.finishActivity();\n    }\n}\n```\n**2. 在Application中注册Module**\n```\npublic class WXApplication extends Application {\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    InitConfig config = new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build();\n    WXSDKEngine.initialize(this, config);\n    try {\n      ...\n      WXSDKEngine.registerModule(\"close\", CloseModule.class);\n      ...\n    } catch (WXException e) {\n      e.printStackTrace();\n    }\n  }\n}\n```\n**3. 在Weex中使用**\n```\nweex.requireModule('close').closeApp()\n```\n这样调用Module之后就可以对Android做许多事情了。\n\n## 退出Activity\n这里我还遇到了一个问题，就是在Weex提供的WXModule中如何退出Activity，解决方案为[android 关闭多个或指定activity](http://www.cnblogs.com/jenson138/p/4516568.html),这篇文章让我可以非常优雅的管理我的Activity。简单写下用法.\n**1. 在每个Activity的onCreate方法中将Activity对象添加到List中**\n```\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  ...\n  CacheActivity.addActivity(NetworkActivity.this);\n}\n```\n**2. 在Module中去关闭Activity**\n```\nCacheActivity.finishActivity();\n```\n**3. 当然，别忘了把CacheActivity的代码贴到项目中去**\n```\npackage com.weex.sample.utlis;\n\nimport android.app.Activity;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class CacheActivity {\n    public static List<Activity> activityList = new LinkedList<Activity>();\n\n    public CacheActivity() {\n\n    }\n\n    /**\n     * 添加到Activity容器中\n     */\n    public static void addActivity(Activity activity) {\n        if (!activityList.contains(activity)) {\n            activityList.add(activity);\n        }\n    }\n\n    /**\n     * 便利所有Activigty并finish\n     */\n    public static void finishActivity() {\n        for (Activity activity : activityList) {\n            activity.finish();\n        }\n    }\n\n    /**\n     * 结束指定的Activity\n     */\n    public static void finishSingleActivity(Activity activity) {\n        if (activity != null) {\n            if (activityList.contains(activity)) {\n                activityList.remove(activity);\n            }\n            activity.finish();\n            activity = null;\n        }\n    }\n\n    /**\n     * 结束指定类名的Activity 在遍历一个列表的时候不能执行删除操作，所有我们先记住要删除的对象，遍历之后才去删除。\n     */\n    public static void finishSingleActivityByClass(Class<?> cls) {\n        Activity tempActivity = null;\n        for (Activity activity : activityList) {\n            if (activity.getClass().equals(cls)) {\n                tempActivity = activity;\n            }\n        }\n\n        finishSingleActivity(tempActivity);\n    }\n\n}\n```\n\nOver！继续倒腾Weex中……遇到问题继续总结。欢迎留言交流~","slug":"Weex控制Android返回键解决方案","published":1,"updated":"2018-02-07T02:33:29.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjddwxbmn000di8btckcrdha6","content":"<blockquote>\n<p>正在深入倒腾weex，希望可以将weex用在项目中。这里找出了weex控制Android返回键的方法。</p>\n</blockquote>\n<h1 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h1><p>项目使用的是Vue+VueRouter的单页应用来写Weex的，现有以下需求。</p>\n<ul>\n<li>当页面不在首页上时，返回上一页面。 <code>this.$router.go(-1)</code></li>\n<li>当页面在首页是，关闭当前Android应用</li>\n</ul>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><h2 id=\"Android和Weex的通信\"><a href=\"#Android和Weex的通信\" class=\"headerlink\" title=\"Android和Weex的通信\"></a>Android和Weex的通信</h2><h3 id=\"Android-to-Weex\"><a href=\"#Android-to-Weex\" class=\"headerlink\" title=\"Android to Weex\"></a>Android to Weex</h3><p>使用的是<a href=\"http://weex.apache.org/cn/references/modules/globalevent.html\" target=\"_blank\" rel=\"noopener\">globalEvent</a>来实现的。我们在 Android 的返回按钮事件中触发 <code>globalEvent</code>，在 Weex 中监听该 <code>globalEvent</code>。</p>\n<p><strong>Android</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void onBackPressed()&#123;</span><br><span class=\"line\">  Map&lt;String,Object&gt; params=new HashMap&lt;&gt;();</span><br><span class=\"line\">  params.put(&quot;name&quot;,&quot;returnmsg&quot;);</span><br><span class=\"line\">  mWXSDKInstance.fireGlobalEventCallback(&quot;androidback&quot;,params);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Weex</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">globalEvent.addEventListener(&apos;androidback&apos;, function (e) &#123;</span><br><span class=\"line\">  // 这里就可以做返回事件操作了，如返回上一页或退出应用</span><br><span class=\"line\">  // that.$router.go(-1)</span><br><span class=\"line\">  // weex.requireModule(&apos;close&apos;).closeApp()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Weex-to-Android\"><a href=\"#Weex-to-Android\" class=\"headerlink\" title=\"Weex to Android\"></a>Weex to Android</h3><p>而Weex对Android的通信使用<a href=\"http://weex.apache.org/cn/references/advanced/extend-to-android.html#Module-扩展\" target=\"_blank\" rel=\"noopener\">Module扩展</a>来实现。通过在Android中创建WXModule并在Application中注册后，Weex调用该Module触发Android事件。下面我们来一步步实现。</p>\n<p><strong>1. Android中创建CloseModule</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CloseModule extends WXModule &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @JSMethod(uiThread = false)</span><br><span class=\"line\">    public void closeApp() &#123;</span><br><span class=\"line\">        LogUtil.e(&quot;触发关闭效果&quot;);</span><br><span class=\"line\">        CacheActivity.finishActivity();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>2. 在Application中注册Module</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WXApplication extends Application &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public void onCreate() &#123;</span><br><span class=\"line\">    super.onCreate();</span><br><span class=\"line\">    InitConfig config = new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build();</span><br><span class=\"line\">    WXSDKEngine.initialize(this, config);</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      WXSDKEngine.registerModule(&quot;close&quot;, CloseModule.class);</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125; catch (WXException e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>3. 在Weex中使用</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weex.requireModule(&apos;close&apos;).closeApp()</span><br></pre></td></tr></table></figure></p>\n<p>这样调用Module之后就可以对Android做许多事情了。</p>\n<h2 id=\"退出Activity\"><a href=\"#退出Activity\" class=\"headerlink\" title=\"退出Activity\"></a>退出Activity</h2><p>这里我还遇到了一个问题，就是在Weex提供的WXModule中如何退出Activity，解决方案为<a href=\"http://www.cnblogs.com/jenson138/p/4516568.html\" target=\"_blank\" rel=\"noopener\">android 关闭多个或指定activity</a>,这篇文章让我可以非常优雅的管理我的Activity。简单写下用法.<br><strong>1. 在每个Activity的onCreate方法中将Activity对象添加到List中</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  CacheActivity.addActivity(NetworkActivity.this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>2. 在Module中去关闭Activity</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CacheActivity.finishActivity();</span><br></pre></td></tr></table></figure></p>\n<p><strong>3. 当然，别忘了把CacheActivity的代码贴到项目中去</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.weex.sample.utlis;</span><br><span class=\"line\"></span><br><span class=\"line\">import android.app.Activity;</span><br><span class=\"line\">import java.util.LinkedList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class CacheActivity &#123;</span><br><span class=\"line\">    public static List&lt;Activity&gt; activityList = new LinkedList&lt;Activity&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public CacheActivity() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 添加到Activity容器中</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void addActivity(Activity activity) &#123;</span><br><span class=\"line\">        if (!activityList.contains(activity)) &#123;</span><br><span class=\"line\">            activityList.add(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 便利所有Activigty并finish</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void finishActivity() &#123;</span><br><span class=\"line\">        for (Activity activity : activityList) &#123;</span><br><span class=\"line\">            activity.finish();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 结束指定的Activity</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void finishSingleActivity(Activity activity) &#123;</span><br><span class=\"line\">        if (activity != null) &#123;</span><br><span class=\"line\">            if (activityList.contains(activity)) &#123;</span><br><span class=\"line\">                activityList.remove(activity);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            activity.finish();</span><br><span class=\"line\">            activity = null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 结束指定类名的Activity 在遍历一个列表的时候不能执行删除操作，所有我们先记住要删除的对象，遍历之后才去删除。</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void finishSingleActivityByClass(Class&lt;?&gt; cls) &#123;</span><br><span class=\"line\">        Activity tempActivity = null;</span><br><span class=\"line\">        for (Activity activity : activityList) &#123;</span><br><span class=\"line\">            if (activity.getClass().equals(cls)) &#123;</span><br><span class=\"line\">                tempActivity = activity;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        finishSingleActivity(tempActivity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Over！继续倒腾Weex中……遇到问题继续总结。欢迎留言交流~</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>正在深入倒腾weex，希望可以将weex用在项目中。这里找出了weex控制Android返回键的方法。</p>\n</blockquote>\n<h1 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h1><p>项目使用的是Vue+VueRouter的单页应用来写Weex的，现有以下需求。</p>\n<ul>\n<li>当页面不在首页上时，返回上一页面。 <code>this.$router.go(-1)</code></li>\n<li>当页面在首页是，关闭当前Android应用</li>\n</ul>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><h2 id=\"Android和Weex的通信\"><a href=\"#Android和Weex的通信\" class=\"headerlink\" title=\"Android和Weex的通信\"></a>Android和Weex的通信</h2><h3 id=\"Android-to-Weex\"><a href=\"#Android-to-Weex\" class=\"headerlink\" title=\"Android to Weex\"></a>Android to Weex</h3><p>使用的是<a href=\"http://weex.apache.org/cn/references/modules/globalevent.html\" target=\"_blank\" rel=\"noopener\">globalEvent</a>来实现的。我们在 Android 的返回按钮事件中触发 <code>globalEvent</code>，在 Weex 中监听该 <code>globalEvent</code>。</p>\n<p><strong>Android</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void onBackPressed()&#123;</span><br><span class=\"line\">  Map&lt;String,Object&gt; params=new HashMap&lt;&gt;();</span><br><span class=\"line\">  params.put(&quot;name&quot;,&quot;returnmsg&quot;);</span><br><span class=\"line\">  mWXSDKInstance.fireGlobalEventCallback(&quot;androidback&quot;,params);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Weex</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">globalEvent.addEventListener(&apos;androidback&apos;, function (e) &#123;</span><br><span class=\"line\">  // 这里就可以做返回事件操作了，如返回上一页或退出应用</span><br><span class=\"line\">  // that.$router.go(-1)</span><br><span class=\"line\">  // weex.requireModule(&apos;close&apos;).closeApp()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Weex-to-Android\"><a href=\"#Weex-to-Android\" class=\"headerlink\" title=\"Weex to Android\"></a>Weex to Android</h3><p>而Weex对Android的通信使用<a href=\"http://weex.apache.org/cn/references/advanced/extend-to-android.html#Module-扩展\" target=\"_blank\" rel=\"noopener\">Module扩展</a>来实现。通过在Android中创建WXModule并在Application中注册后，Weex调用该Module触发Android事件。下面我们来一步步实现。</p>\n<p><strong>1. Android中创建CloseModule</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CloseModule extends WXModule &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @JSMethod(uiThread = false)</span><br><span class=\"line\">    public void closeApp() &#123;</span><br><span class=\"line\">        LogUtil.e(&quot;触发关闭效果&quot;);</span><br><span class=\"line\">        CacheActivity.finishActivity();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>2. 在Application中注册Module</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class WXApplication extends Application &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public void onCreate() &#123;</span><br><span class=\"line\">    super.onCreate();</span><br><span class=\"line\">    InitConfig config = new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build();</span><br><span class=\"line\">    WXSDKEngine.initialize(this, config);</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      WXSDKEngine.registerModule(&quot;close&quot;, CloseModule.class);</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125; catch (WXException e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>3. 在Weex中使用</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weex.requireModule(&apos;close&apos;).closeApp()</span><br></pre></td></tr></table></figure></p>\n<p>这样调用Module之后就可以对Android做许多事情了。</p>\n<h2 id=\"退出Activity\"><a href=\"#退出Activity\" class=\"headerlink\" title=\"退出Activity\"></a>退出Activity</h2><p>这里我还遇到了一个问题，就是在Weex提供的WXModule中如何退出Activity，解决方案为<a href=\"http://www.cnblogs.com/jenson138/p/4516568.html\" target=\"_blank\" rel=\"noopener\">android 关闭多个或指定activity</a>,这篇文章让我可以非常优雅的管理我的Activity。简单写下用法.<br><strong>1. 在每个Activity的onCreate方法中将Activity对象添加到List中</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  CacheActivity.addActivity(NetworkActivity.this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>2. 在Module中去关闭Activity</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CacheActivity.finishActivity();</span><br></pre></td></tr></table></figure></p>\n<p><strong>3. 当然，别忘了把CacheActivity的代码贴到项目中去</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.weex.sample.utlis;</span><br><span class=\"line\"></span><br><span class=\"line\">import android.app.Activity;</span><br><span class=\"line\">import java.util.LinkedList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class CacheActivity &#123;</span><br><span class=\"line\">    public static List&lt;Activity&gt; activityList = new LinkedList&lt;Activity&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public CacheActivity() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 添加到Activity容器中</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void addActivity(Activity activity) &#123;</span><br><span class=\"line\">        if (!activityList.contains(activity)) &#123;</span><br><span class=\"line\">            activityList.add(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 便利所有Activigty并finish</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void finishActivity() &#123;</span><br><span class=\"line\">        for (Activity activity : activityList) &#123;</span><br><span class=\"line\">            activity.finish();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 结束指定的Activity</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void finishSingleActivity(Activity activity) &#123;</span><br><span class=\"line\">        if (activity != null) &#123;</span><br><span class=\"line\">            if (activityList.contains(activity)) &#123;</span><br><span class=\"line\">                activityList.remove(activity);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            activity.finish();</span><br><span class=\"line\">            activity = null;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 结束指定类名的Activity 在遍历一个列表的时候不能执行删除操作，所有我们先记住要删除的对象，遍历之后才去删除。</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void finishSingleActivityByClass(Class&lt;?&gt; cls) &#123;</span><br><span class=\"line\">        Activity tempActivity = null;</span><br><span class=\"line\">        for (Activity activity : activityList) &#123;</span><br><span class=\"line\">            if (activity.getClass().equals(cls)) &#123;</span><br><span class=\"line\">                tempActivity = activity;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        finishSingleActivity(tempActivity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Over！继续倒腾Weex中……遇到问题继续总结。欢迎留言交流~</p>\n"},{"title":"weex 踩坑记（持续更新中……）","date":"2016-08-02T16:00:00.000Z","_content":"\n> 消失了一个月，努力为新项目倒腾 weex 中，记录一下遇到的问题。之后还会持续更新~\n\n目前，我使用的 `weex` 都是在[集成Weex到Android](http://weex.apache.org/cn/guide/integrate-to-your-app.html)来做的，项目使用的是 `weex-toolkit` 生成的项目模板，代码发布使用webpack打包成js放到服务器上，Android端读取服务器上的js来实现weex项目的。\n\n# 杂七杂八的一些知识点\n\n* 屏幕宽度为 750，高度一直没查到，我用的是1300，刚好显示下。长度单位要么不写，要么就是 px，效果都一样。\n```\n.item {\n  height: 1300;\n  width: 750px;\n}\n```\n* 布局只支持 盒子模型、flex布局、relative定位，其他一些CSS不太支持。\n* CSS的 margin、padding、border 不支持缩写。像 `border:5px solid red;` 这样写是不行滴。\n* 暂不支持像 [mint-ui](http://mint-ui.github.io/#!/zh-cn) 这类 Vue Web UI 组件库。\n* 页面的跳转可以通过 [vue-router](https://router.vuejs.org/zh-cn/) 或者 weex 的 [navigator](http://weex.apache.org/cn/references/modules/navigator.html) 组件来实现，可以参考我提问的[Weex的页面跳转方案的选择](https://segmentfault.com/q/1010000009999942)。\n* 在 Android 中，`navigator` 的 `push` 方法跳转的 `Activity` 界面是需要处理的，需要创建一个带有特殊 `<intent-filter>` 标签的 Activity。假如手机中没有带有该 `<intent-filter>` 的 `Activity` 就不会发生跳转，报 `ActivityNotFoundException` 错误。而如果有多个带有该 `<intent-filter>` 的`Activity`，Android 系统会让我们去进行选择。注：这个带 `<intent-filter>` 的Activity 是跨 APP 的。可以参照[WEEX 使用navigator跳转Android系统出现ActivityNotFoundException报错](http://blog.csdn.net/violetjack0808/article/details/74390249)\n* `image` 必须设置宽高，否则不显示。也不能使用 `img` 来显示图片\n* Android 手机中显示图片需要在 `ImageAdapter` 中进行处理，官网只提供了处理的位置（有注释），但未对图片进行处理。我使用了 [picasso](https://github.com/square/picasso) 来对图片进行显示。\n* native 和 weex 的通信通过自定义module或者发送全局事件来完成。参考[Weex控制Android返回键解决方案](http://blog.csdn.net/violetjack0808/article/details/74002599)里面有 native 端和 weex 端交互的细节。\n* weex 在Android手机中的调试：\n  * 在 weex 中使用 console.log 方法来打 log，打开Android Studio，在 logcat中可以过滤关键词 jslog 来获取log数据。\n  * 如果 weex 报错，可以在 logcat 中查找错误，一般错误都好几行，很好找。\n  * 建议使用ESLint先过滤一些简单的语法错误，减少手机端的调试成本。\n* weex 其他调试方式\n  * 手机安装 [Playground](http://weex.apache.org/cn/playground.html)，运行 weex 项目，网页打开 `http://localhost:8080/` 扫描二维码进行调试。\n  * 可以在[Playground网页端](http://dotwe.org/vue/025db54e37123ab5336a4b848397660f)进行代码调试，但感觉遇到有组件的项目不太好调试。\n  * 在项目运行(`npm run serve`)后，直接打开 `http://localhost:8080/` 也能看到网页版本的项目，可以直接调试，不过一些设计Native端的组件用不了。\n* weex中的标签只支持官方提供的[内部组件](http://weex.apache.org/cn/references/components/index.html)，因为那些是会被渲染成native界面的。\n* `v-bind:class`只能使用数组语法\n* `stream` 的 `url` 选项好像默认不支持中文，需要将中文转为 `UTF-8` 来传输。\n* weex 的 css 只支持 class 选择器，并且只支持单个类的选择器，如`.item .item-content {}`是错误的~\n* weex有点击特效的，参照[伪类](http://weex.apache.org/cn/references/common-style.html#伪类-v0-9-5)。\n* 不支持 `display:none` 即不支持 `v-show`，需要使用 `v-if` 来实现显示和隐藏。\n* 默认flex布局，要设置 `flex-direction`。我怀疑我的web端显示错误可能就是没有设置 `flex-direction`，移动端没有错误是因为默认 `flex-direction:column`\n* 存储、网络等很多都是异步的，需要注意顺序\n* `storage` 只能存储字符串，取值后再转为json\n\n## 结尾\n暂时整理这么多，之后还会有其他的东西我会持续更新的~\nAndroid 端的 [demo](https://github.com/violetjack/WeexComponents) 我会放到我的 Github 上去，之后我会让我的 IOS 小伙伴给一版 IOS 版本的壳子，到时候直接写weex项目，Android端和IOS端只需要更改一下渲染的js文件路径就可以显示了。\n\n## 参考文档\n* [weex填坑注意事项](https://github.com/dreamochi/DayDayUp/issues/77)","source":"_posts/weex 踩坑记（持续更新中……）.md","raw":"---\ntitle: weex 踩坑记（持续更新中……）\ndate: 2016-08-03\n---\n\n> 消失了一个月，努力为新项目倒腾 weex 中，记录一下遇到的问题。之后还会持续更新~\n\n目前，我使用的 `weex` 都是在[集成Weex到Android](http://weex.apache.org/cn/guide/integrate-to-your-app.html)来做的，项目使用的是 `weex-toolkit` 生成的项目模板，代码发布使用webpack打包成js放到服务器上，Android端读取服务器上的js来实现weex项目的。\n\n# 杂七杂八的一些知识点\n\n* 屏幕宽度为 750，高度一直没查到，我用的是1300，刚好显示下。长度单位要么不写，要么就是 px，效果都一样。\n```\n.item {\n  height: 1300;\n  width: 750px;\n}\n```\n* 布局只支持 盒子模型、flex布局、relative定位，其他一些CSS不太支持。\n* CSS的 margin、padding、border 不支持缩写。像 `border:5px solid red;` 这样写是不行滴。\n* 暂不支持像 [mint-ui](http://mint-ui.github.io/#!/zh-cn) 这类 Vue Web UI 组件库。\n* 页面的跳转可以通过 [vue-router](https://router.vuejs.org/zh-cn/) 或者 weex 的 [navigator](http://weex.apache.org/cn/references/modules/navigator.html) 组件来实现，可以参考我提问的[Weex的页面跳转方案的选择](https://segmentfault.com/q/1010000009999942)。\n* 在 Android 中，`navigator` 的 `push` 方法跳转的 `Activity` 界面是需要处理的，需要创建一个带有特殊 `<intent-filter>` 标签的 Activity。假如手机中没有带有该 `<intent-filter>` 的 `Activity` 就不会发生跳转，报 `ActivityNotFoundException` 错误。而如果有多个带有该 `<intent-filter>` 的`Activity`，Android 系统会让我们去进行选择。注：这个带 `<intent-filter>` 的Activity 是跨 APP 的。可以参照[WEEX 使用navigator跳转Android系统出现ActivityNotFoundException报错](http://blog.csdn.net/violetjack0808/article/details/74390249)\n* `image` 必须设置宽高，否则不显示。也不能使用 `img` 来显示图片\n* Android 手机中显示图片需要在 `ImageAdapter` 中进行处理，官网只提供了处理的位置（有注释），但未对图片进行处理。我使用了 [picasso](https://github.com/square/picasso) 来对图片进行显示。\n* native 和 weex 的通信通过自定义module或者发送全局事件来完成。参考[Weex控制Android返回键解决方案](http://blog.csdn.net/violetjack0808/article/details/74002599)里面有 native 端和 weex 端交互的细节。\n* weex 在Android手机中的调试：\n  * 在 weex 中使用 console.log 方法来打 log，打开Android Studio，在 logcat中可以过滤关键词 jslog 来获取log数据。\n  * 如果 weex 报错，可以在 logcat 中查找错误，一般错误都好几行，很好找。\n  * 建议使用ESLint先过滤一些简单的语法错误，减少手机端的调试成本。\n* weex 其他调试方式\n  * 手机安装 [Playground](http://weex.apache.org/cn/playground.html)，运行 weex 项目，网页打开 `http://localhost:8080/` 扫描二维码进行调试。\n  * 可以在[Playground网页端](http://dotwe.org/vue/025db54e37123ab5336a4b848397660f)进行代码调试，但感觉遇到有组件的项目不太好调试。\n  * 在项目运行(`npm run serve`)后，直接打开 `http://localhost:8080/` 也能看到网页版本的项目，可以直接调试，不过一些设计Native端的组件用不了。\n* weex中的标签只支持官方提供的[内部组件](http://weex.apache.org/cn/references/components/index.html)，因为那些是会被渲染成native界面的。\n* `v-bind:class`只能使用数组语法\n* `stream` 的 `url` 选项好像默认不支持中文，需要将中文转为 `UTF-8` 来传输。\n* weex 的 css 只支持 class 选择器，并且只支持单个类的选择器，如`.item .item-content {}`是错误的~\n* weex有点击特效的，参照[伪类](http://weex.apache.org/cn/references/common-style.html#伪类-v0-9-5)。\n* 不支持 `display:none` 即不支持 `v-show`，需要使用 `v-if` 来实现显示和隐藏。\n* 默认flex布局，要设置 `flex-direction`。我怀疑我的web端显示错误可能就是没有设置 `flex-direction`，移动端没有错误是因为默认 `flex-direction:column`\n* 存储、网络等很多都是异步的，需要注意顺序\n* `storage` 只能存储字符串，取值后再转为json\n\n## 结尾\n暂时整理这么多，之后还会有其他的东西我会持续更新的~\nAndroid 端的 [demo](https://github.com/violetjack/WeexComponents) 我会放到我的 Github 上去，之后我会让我的 IOS 小伙伴给一版 IOS 版本的壳子，到时候直接写weex项目，Android端和IOS端只需要更改一下渲染的js文件路径就可以显示了。\n\n## 参考文档\n* [weex填坑注意事项](https://github.com/dreamochi/DayDayUp/issues/77)","slug":"weex 踩坑记（持续更新中……）","published":1,"updated":"2018-02-07T02:33:23.535Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjddwxbmo000ei8btb0gk5e7d","content":"<blockquote>\n<p>消失了一个月，努力为新项目倒腾 weex 中，记录一下遇到的问题。之后还会持续更新~</p>\n</blockquote>\n<p>目前，我使用的 <code>weex</code> 都是在<a href=\"http://weex.apache.org/cn/guide/integrate-to-your-app.html\" target=\"_blank\" rel=\"noopener\">集成Weex到Android</a>来做的，项目使用的是 <code>weex-toolkit</code> 生成的项目模板，代码发布使用webpack打包成js放到服务器上，Android端读取服务器上的js来实现weex项目的。</p>\n<h1 id=\"杂七杂八的一些知识点\"><a href=\"#杂七杂八的一些知识点\" class=\"headerlink\" title=\"杂七杂八的一些知识点\"></a>杂七杂八的一些知识点</h1><ul>\n<li><p>屏幕宽度为 750，高度一直没查到，我用的是1300，刚好显示下。长度单位要么不写，要么就是 px，效果都一样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.item &#123;</span><br><span class=\"line\">  height: 1300;</span><br><span class=\"line\">  width: 750px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>布局只支持 盒子模型、flex布局、relative定位，其他一些CSS不太支持。</p>\n</li>\n<li>CSS的 margin、padding、border 不支持缩写。像 <code>border:5px solid red;</code> 这样写是不行滴。</li>\n<li>暂不支持像 <a href=\"http://mint-ui.github.io/#!/zh-cn\" target=\"_blank\" rel=\"noopener\">mint-ui</a> 这类 Vue Web UI 组件库。</li>\n<li>页面的跳转可以通过 <a href=\"https://router.vuejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">vue-router</a> 或者 weex 的 <a href=\"http://weex.apache.org/cn/references/modules/navigator.html\" target=\"_blank\" rel=\"noopener\">navigator</a> 组件来实现，可以参考我提问的<a href=\"https://segmentfault.com/q/1010000009999942\" target=\"_blank\" rel=\"noopener\">Weex的页面跳转方案的选择</a>。</li>\n<li>在 Android 中，<code>navigator</code> 的 <code>push</code> 方法跳转的 <code>Activity</code> 界面是需要处理的，需要创建一个带有特殊 <code>&lt;intent-filter&gt;</code> 标签的 Activity。假如手机中没有带有该 <code>&lt;intent-filter&gt;</code> 的 <code>Activity</code> 就不会发生跳转，报 <code>ActivityNotFoundException</code> 错误。而如果有多个带有该 <code>&lt;intent-filter&gt;</code> 的<code>Activity</code>，Android 系统会让我们去进行选择。注：这个带 <code>&lt;intent-filter&gt;</code> 的Activity 是跨 APP 的。可以参照<a href=\"http://blog.csdn.net/violetjack0808/article/details/74390249\" target=\"_blank\" rel=\"noopener\">WEEX 使用navigator跳转Android系统出现ActivityNotFoundException报错</a></li>\n<li><code>image</code> 必须设置宽高，否则不显示。也不能使用 <code>img</code> 来显示图片</li>\n<li>Android 手机中显示图片需要在 <code>ImageAdapter</code> 中进行处理，官网只提供了处理的位置（有注释），但未对图片进行处理。我使用了 <a href=\"https://github.com/square/picasso\" target=\"_blank\" rel=\"noopener\">picasso</a> 来对图片进行显示。</li>\n<li>native 和 weex 的通信通过自定义module或者发送全局事件来完成。参考<a href=\"http://blog.csdn.net/violetjack0808/article/details/74002599\" target=\"_blank\" rel=\"noopener\">Weex控制Android返回键解决方案</a>里面有 native 端和 weex 端交互的细节。</li>\n<li>weex 在Android手机中的调试：<ul>\n<li>在 weex 中使用 console.log 方法来打 log，打开Android Studio，在 logcat中可以过滤关键词 jslog 来获取log数据。</li>\n<li>如果 weex 报错，可以在 logcat 中查找错误，一般错误都好几行，很好找。</li>\n<li>建议使用ESLint先过滤一些简单的语法错误，减少手机端的调试成本。</li>\n</ul>\n</li>\n<li>weex 其他调试方式<ul>\n<li>手机安装 <a href=\"http://weex.apache.org/cn/playground.html\" target=\"_blank\" rel=\"noopener\">Playground</a>，运行 weex 项目，网页打开 <code>http://localhost:8080/</code> 扫描二维码进行调试。</li>\n<li>可以在<a href=\"http://dotwe.org/vue/025db54e37123ab5336a4b848397660f\" target=\"_blank\" rel=\"noopener\">Playground网页端</a>进行代码调试，但感觉遇到有组件的项目不太好调试。</li>\n<li>在项目运行(<code>npm run serve</code>)后，直接打开 <code>http://localhost:8080/</code> 也能看到网页版本的项目，可以直接调试，不过一些设计Native端的组件用不了。</li>\n</ul>\n</li>\n<li>weex中的标签只支持官方提供的<a href=\"http://weex.apache.org/cn/references/components/index.html\" target=\"_blank\" rel=\"noopener\">内部组件</a>，因为那些是会被渲染成native界面的。</li>\n<li><code>v-bind:class</code>只能使用数组语法</li>\n<li><code>stream</code> 的 <code>url</code> 选项好像默认不支持中文，需要将中文转为 <code>UTF-8</code> 来传输。</li>\n<li>weex 的 css 只支持 class 选择器，并且只支持单个类的选择器，如<code>.item .item-content {}</code>是错误的~</li>\n<li>weex有点击特效的，参照<a href=\"http://weex.apache.org/cn/references/common-style.html#伪类-v0-9-5\" target=\"_blank\" rel=\"noopener\">伪类</a>。</li>\n<li>不支持 <code>display:none</code> 即不支持 <code>v-show</code>，需要使用 <code>v-if</code> 来实现显示和隐藏。</li>\n<li>默认flex布局，要设置 <code>flex-direction</code>。我怀疑我的web端显示错误可能就是没有设置 <code>flex-direction</code>，移动端没有错误是因为默认 <code>flex-direction:column</code></li>\n<li>存储、网络等很多都是异步的，需要注意顺序</li>\n<li><code>storage</code> 只能存储字符串，取值后再转为json</li>\n</ul>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>暂时整理这么多，之后还会有其他的东西我会持续更新的~<br>Android 端的 <a href=\"https://github.com/violetjack/WeexComponents\" target=\"_blank\" rel=\"noopener\">demo</a> 我会放到我的 Github 上去，之后我会让我的 IOS 小伙伴给一版 IOS 版本的壳子，到时候直接写weex项目，Android端和IOS端只需要更改一下渲染的js文件路径就可以显示了。</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ul>\n<li><a href=\"https://github.com/dreamochi/DayDayUp/issues/77\" target=\"_blank\" rel=\"noopener\">weex填坑注意事项</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>消失了一个月，努力为新项目倒腾 weex 中，记录一下遇到的问题。之后还会持续更新~</p>\n</blockquote>\n<p>目前，我使用的 <code>weex</code> 都是在<a href=\"http://weex.apache.org/cn/guide/integrate-to-your-app.html\" target=\"_blank\" rel=\"noopener\">集成Weex到Android</a>来做的，项目使用的是 <code>weex-toolkit</code> 生成的项目模板，代码发布使用webpack打包成js放到服务器上，Android端读取服务器上的js来实现weex项目的。</p>\n<h1 id=\"杂七杂八的一些知识点\"><a href=\"#杂七杂八的一些知识点\" class=\"headerlink\" title=\"杂七杂八的一些知识点\"></a>杂七杂八的一些知识点</h1><ul>\n<li><p>屏幕宽度为 750，高度一直没查到，我用的是1300，刚好显示下。长度单位要么不写，要么就是 px，效果都一样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.item &#123;</span><br><span class=\"line\">  height: 1300;</span><br><span class=\"line\">  width: 750px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>布局只支持 盒子模型、flex布局、relative定位，其他一些CSS不太支持。</p>\n</li>\n<li>CSS的 margin、padding、border 不支持缩写。像 <code>border:5px solid red;</code> 这样写是不行滴。</li>\n<li>暂不支持像 <a href=\"http://mint-ui.github.io/#!/zh-cn\" target=\"_blank\" rel=\"noopener\">mint-ui</a> 这类 Vue Web UI 组件库。</li>\n<li>页面的跳转可以通过 <a href=\"https://router.vuejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">vue-router</a> 或者 weex 的 <a href=\"http://weex.apache.org/cn/references/modules/navigator.html\" target=\"_blank\" rel=\"noopener\">navigator</a> 组件来实现，可以参考我提问的<a href=\"https://segmentfault.com/q/1010000009999942\" target=\"_blank\" rel=\"noopener\">Weex的页面跳转方案的选择</a>。</li>\n<li>在 Android 中，<code>navigator</code> 的 <code>push</code> 方法跳转的 <code>Activity</code> 界面是需要处理的，需要创建一个带有特殊 <code>&lt;intent-filter&gt;</code> 标签的 Activity。假如手机中没有带有该 <code>&lt;intent-filter&gt;</code> 的 <code>Activity</code> 就不会发生跳转，报 <code>ActivityNotFoundException</code> 错误。而如果有多个带有该 <code>&lt;intent-filter&gt;</code> 的<code>Activity</code>，Android 系统会让我们去进行选择。注：这个带 <code>&lt;intent-filter&gt;</code> 的Activity 是跨 APP 的。可以参照<a href=\"http://blog.csdn.net/violetjack0808/article/details/74390249\" target=\"_blank\" rel=\"noopener\">WEEX 使用navigator跳转Android系统出现ActivityNotFoundException报错</a></li>\n<li><code>image</code> 必须设置宽高，否则不显示。也不能使用 <code>img</code> 来显示图片</li>\n<li>Android 手机中显示图片需要在 <code>ImageAdapter</code> 中进行处理，官网只提供了处理的位置（有注释），但未对图片进行处理。我使用了 <a href=\"https://github.com/square/picasso\" target=\"_blank\" rel=\"noopener\">picasso</a> 来对图片进行显示。</li>\n<li>native 和 weex 的通信通过自定义module或者发送全局事件来完成。参考<a href=\"http://blog.csdn.net/violetjack0808/article/details/74002599\" target=\"_blank\" rel=\"noopener\">Weex控制Android返回键解决方案</a>里面有 native 端和 weex 端交互的细节。</li>\n<li>weex 在Android手机中的调试：<ul>\n<li>在 weex 中使用 console.log 方法来打 log，打开Android Studio，在 logcat中可以过滤关键词 jslog 来获取log数据。</li>\n<li>如果 weex 报错，可以在 logcat 中查找错误，一般错误都好几行，很好找。</li>\n<li>建议使用ESLint先过滤一些简单的语法错误，减少手机端的调试成本。</li>\n</ul>\n</li>\n<li>weex 其他调试方式<ul>\n<li>手机安装 <a href=\"http://weex.apache.org/cn/playground.html\" target=\"_blank\" rel=\"noopener\">Playground</a>，运行 weex 项目，网页打开 <code>http://localhost:8080/</code> 扫描二维码进行调试。</li>\n<li>可以在<a href=\"http://dotwe.org/vue/025db54e37123ab5336a4b848397660f\" target=\"_blank\" rel=\"noopener\">Playground网页端</a>进行代码调试，但感觉遇到有组件的项目不太好调试。</li>\n<li>在项目运行(<code>npm run serve</code>)后，直接打开 <code>http://localhost:8080/</code> 也能看到网页版本的项目，可以直接调试，不过一些设计Native端的组件用不了。</li>\n</ul>\n</li>\n<li>weex中的标签只支持官方提供的<a href=\"http://weex.apache.org/cn/references/components/index.html\" target=\"_blank\" rel=\"noopener\">内部组件</a>，因为那些是会被渲染成native界面的。</li>\n<li><code>v-bind:class</code>只能使用数组语法</li>\n<li><code>stream</code> 的 <code>url</code> 选项好像默认不支持中文，需要将中文转为 <code>UTF-8</code> 来传输。</li>\n<li>weex 的 css 只支持 class 选择器，并且只支持单个类的选择器，如<code>.item .item-content {}</code>是错误的~</li>\n<li>weex有点击特效的，参照<a href=\"http://weex.apache.org/cn/references/common-style.html#伪类-v0-9-5\" target=\"_blank\" rel=\"noopener\">伪类</a>。</li>\n<li>不支持 <code>display:none</code> 即不支持 <code>v-show</code>，需要使用 <code>v-if</code> 来实现显示和隐藏。</li>\n<li>默认flex布局，要设置 <code>flex-direction</code>。我怀疑我的web端显示错误可能就是没有设置 <code>flex-direction</code>，移动端没有错误是因为默认 <code>flex-direction:column</code></li>\n<li>存储、网络等很多都是异步的，需要注意顺序</li>\n<li><code>storage</code> 只能存储字符串，取值后再转为json</li>\n</ul>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>暂时整理这么多，之后还会有其他的东西我会持续更新的~<br>Android 端的 <a href=\"https://github.com/violetjack/WeexComponents\" target=\"_blank\" rel=\"noopener\">demo</a> 我会放到我的 Github 上去，之后我会让我的 IOS 小伙伴给一版 IOS 版本的壳子，到时候直接写weex项目，Android端和IOS端只需要更改一下渲染的js文件路径就可以显示了。</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ul>\n<li><a href=\"https://github.com/dreamochi/DayDayUp/issues/77\" target=\"_blank\" rel=\"noopener\">weex填坑注意事项</a></li>\n</ul>\n"},{"title":"weex项目弃坑小结","date":"2017-11-30T16:00:00.000Z","_content":"\n> 由于`weex` 的不稳定性，所以中途放弃了 `weex` 方案。转而使用 Android原生开发。今天项目第一阶段开发结束，来总结一下 `weex` 的一些东西。\n\n`weex` 相比于原生开发的好处\n\n* 界面搭建速度快，特别是重复性界面。\n* 数据处理方便，尤其是json解析方面。\n\n坏处么\n\n* 用的人太少，所以网上资料也很少。\n* 坑还是比较多的，要玩的溜要踩上不少坑。\n* 还是需要一些原生开发的知识才能够玩的溜。\n\n说说我这个项目的一些东西吧~\n\n## 页面跳转\n第一个困扰我的就是页面跳转，我去SF上提问了[Weex的页面跳转方案的选择](https://segmentfault.com/q/1010000009999942)这个问题。\n\n* `vue-router` 方案由于 `Vue`和 `weex` 的差异性，用法有所不同，好像需要使用注入 `minixs` 机制，挺麻烦的，所以放弃了……这个如果有需要我会再去研究一下的。\n* 第二种方案就是每个页面都是单独的 `Activity`，各自嵌入一个 `weex` 页面。但是有个问题：`weex` 如何与当前 `Activity` 交互，比如我要从页面A跳转到页面B，我需要 `weex` 调用 `Activity` 的 `startActivity` 方法，这个交互方式我没有找到。不然倒是可以随心所欲的在原生开发和weex之间来回交互。暂时来说我只知道[通过globalEvent和Module扩展来实现两者的交互](http://blog.csdn.net/violetjack0808/article/details/74002599)\n* 最后，还是选择了官方推荐的 `Navigator` 来作为页面跳转的方式。这种方式能够很快速的实现页面跳转。不用瞎折腾~\n\n选定方案之后，就要解决几个问题了。多页面打包和跳转所需的 `Activity` 。\n### 多页面打包\n`navigator` 的跳转方式，需要获取打包好的 `weex` 的文件路径来进行页面跳转和显示，所以我们就需要多页 `weex` 文件代表每一个页面。\n```\nnavigator.push({\n  url: 'http://dotwe.org/raw/dist/519962541fcf6acd911986357ad9c2ed.js',\n  animated: \"true\"\n}, event => {\n  modal.toast({ message: 'callback: ' + event })\n})\n```\n需要配置 `Webpack` 来实现这一目的。我将每个页面的入口文件都放在 `./src/entrys`文件夹下，通过 `node` 的 `fs文件模块` 读取里面的入口文件，并将他们传给 `entry` 入口对象。最后将入口对象配置到 `webpack` 打包配置中。\n```\nvar path = require('path')\nvar webpack = require('webpack')\nvar fs = require('fs')\n\nvar files = fs.readdirSync('./src/entrys')\nvar entry = {}\nfiles.forEach(function (file) {\n  var item = file.replace('.js', '')\n  entry[item] = path.resolve('./src/entrys/' + file)\n})\n\nvar bannerPlugin = new webpack.BannerPlugin(\n  '// { \"framework\": \"Vue\" }\\n', { raw: true }\n)\n\nfunction getBaseConfig() {\n  return {\n    entry: entry,\n    output: {\n      path: 'dist'\n    },\n    resolve: {\n      alias: {\n        '@': path.resolve('./src'),\n        'views': path.resolve('./src/views'),\n        'utils': path.resolve('./src/utils')\n      }\n    },\n    module: {\n      // ESLint配置\n      preLoaders: [{\n        test: /\\.vue$/,\n        loader: 'eslint',\n        exclude: /node_modules/\n      },\n      {\n        test: /\\.js$/,\n        loader: 'eslint',\n        exclude: /node_modules/\n      }\n      ],\n      // 如果注释掉以上这段将不产生ESLint检查\n      loaders: [{\n        test: /\\.js$/,\n        loader: 'babel',\n        exclude: /node_modules/\n      }, {\n        test: /\\.vue(\\?[^?]+)?$/,\n        loaders: []\n      }]\n    },\n    vue: {\n    },\n    plugins: [bannerPlugin]\n  }\n}\n\nvar webConfig = getBaseConfig()\nwebConfig.output.filename = '[name].web.js'\nwebConfig.module.loaders[1].loaders.push('vue')\n\nvar weexConfig = getBaseConfig()\nweexConfig.output.filename = '[name].weex.js'\nweexConfig.module.loaders[1].loaders.push('weex')\n\nmodule.exports = [webConfig, weexConfig]\n```\n每一个入口文件都会产生两个相应名称的文件，如 `sign.js` 的入口文件就会生成 `sign.weex.js` 和 `sign.web.js` 文件，这里我们只关注 `weex` 后缀的文件，这就是我们跳转页面所需的文件。具体项目结构请看[源代码](https://github.com/violetjack/MobileNurseWeex)\n更多对于 `webpack` 的了解可以看[Vue.js学习系列四——Webpack学习实践](http://blog.csdn.net/violetjack0808/article/details/54915825)\n\n### navigator跳转的Activity哪里来的？\n在使用了 `navigator` 后一开始发现并没有页面跳转效果，而是报 `ActivityNotFoundException` 的错误。后来装了 `weex` 的 playground 之后发现可以跳转了，但是跳转过去的 `Activity` 有个 ActionBar 和一个性能调试的悬浮窗，是 playground 里面扫二维码显示的结果的那个 `Activity`。几经查阅后发现原来跳转的 `Activity` 是一个有着特殊 `intent-filter` 的 `Activity` 。\n关于这个问题我写过一篇文章：[WEEX 使用navigator跳转Android系统出现ActivityNotFoundException报错](http://blog.csdn.net/violetjack0808/article/details/74390249)\n解决方案是我把 Playground 里面的那个 `Activity` 移到了我的项目中来，并且去除了 `ActionBar` 和调试工具。然后卸载掉 `weex`  的 Playground，这样就能愉快的显示 `navigator` 跳转的 `Activity` 了。代码请看[WXPageActivity](https://github.com/violetjack/MobileNurseWeex/blob/master/android/app/src/main/java/com/weex/sample/activity/WXPageActivity.java)。\n\n## 网络通信\n网络通信上我用的是stream，这个很简单。说下两点：\n第一，stream所用的url需要是UTF-8格式的，如果URL中有中文需要转一下，URL可以参照utf8这个文件。\n第二，提交数据的时候需要添加头文件。我的项目中是这样~\n```\n      stream.fetch({\n        method: StreamType,\n        type: 'json',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        url: url,\n        body: JSON.stringify(this.DataObj)\n      }, res => {\n        console.log(res)\n        let json = eval('(' + res.data + ')')\n        modal.alert({\n          message: json.Message\n        }, event => {\n\n        })\n      })\n```\n\n## 图片加载\n图片加载需要在[ImageAdapter](https://github.com/violetjack/MobileNurseWeex/blob/master/android/app/src/main/java/com/weex/sample/ImageAdapter.java)中稍作处理，我这里用的是 `Picasso` 来显示图片的~\n```\npublic class ImageAdapter implements IWXImgLoaderAdapter {\n    \n    @Override\n    public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) {\n        WXSDKManager.getInstance().postOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                if (view == null || view.getLayoutParams() == null) {\n                    return;\n                }\n                if (TextUtils.isEmpty(url)) {\n                    view.setImageBitmap(null);\n                    return;\n                }\n                String temp = url;\n                if (url.startsWith(\"//\")) {\n                    temp = \"http:\" + url;\n                }\n                if (view.getLayoutParams().width <= 0 || view.getLayoutParams().height <= 0) {\n                    return;\n                }\n                Picasso.with(WXEnvironment.getApplication())\n                        .load(temp)\n                        .into(view);\n            }\n        }, 0);\n    }\n}\n```\n\n### 页面跳转的数据传输\n这一点上，我只想到了不太优雅的方式——使用 `storage` 来保存和读取。比如我需要将表单ID传递到下一个页面我是这么做的：\n```\n    toDetail(AssessID) {\n      storage.setItem('AssessID', AssessID)\n      navigator.push({\n        url: ViewServer + 'GAD.weex.js',\n        animated: 'true'\n      }, event => {\n        console.log('successful entry')\n      })\n    },\n```\n到第二个页面去获取数据：\n```\n    getData() {\n      let that = this\n      storage.getItem('AssessID', event => {\n        let AssessID = event.data\n        console.log('AssessID = ' + AssessID)\n      })\n    },\n```\n如果是比较多的数据，我会将数据以 `json` 字符串的形式保存，在需要的时候获取字符串并解析为 `json` 对象。\n\n### 如何在返回上一页面时做一些操作？\n我的解决方法是在Activity的onResume方法中发送一个消息，然后在weex端添加监听事件。\n**Android端**\n```\n    @Override\n    protected void onResume() {\n        super.onResume();\n        if (mInstance != null) {\n            mInstance.onActivityResume();\n\n            new Handler().postDelayed(new Runnable() {\n                public void run() {\n                    Map<String, Object> params = new HashMap<>();\n                    mInstance.fireGlobalEventCallback(\"onResume\", params);\n                }\n            }, 500);\n        }\n    }\n```\n**weex端**\n```\n\taddListener() {\n      globalEvent.addEventListener('onResume', e => {\n        storage.getItem('PopCallback', event => {\n          if (event.data === 'update level list') {\n            this.loadData()\n            storage.setItem('PopCallback', '')\n          }\n        })\n      })\n    }\n```\n由于加载 `weex` 有一些延时，`onResume` 往往会比 `weex` 加载快，所以我在 `onResume` 中添加了0.5秒延时。之后在 `weex` 中添加监听器监听 `onResume` 的生命周期，并监听返回的数据。\n\n### 如何控制weex的Slider显示第几页\n想实现Android的ViewPager效果，使用了weex提供的slider组件，具体坚决方案看[如何控制weex的Slider显示第几页。](https://segmentfault.com/q/1010000010728251)\n\n### 其他\n\n* 图片的存放好像只能是网络图片的URL，所以我将所有图片都放到服务器上让weex去访问。\n* CSS使用flex布局来做，官网上有例子。也可参照[Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)。\n\n# 最后\n啰嗦一大堆，希望某些东西能够对他人有所帮助吧~\n项目地址[在此](https://github.com/violetjack/MobileNurseWeex)，由于是公司项目，所以把服务器地址去掉了，后端数据获取不了。不过代码都是在的，可以进行参考。希望能对大家有所帮助~\n最终不用weex的原因么，因为这玩意看似简单，但是想实现点复杂的、和原生交互的功能都得折腾好一会儿。关键还是资料太少，不靠谱，万一哪个地方报个奇怪的错误找不出问题、查不到资料、看不懂源码，那不就挂了嘛~所以，爱折腾玩玩可以，放项目中还是有待考虑。毕竟还是要求稳~\n\n\n","source":"_posts/weex项目弃坑小结.md","raw":"---\ntitle: weex项目弃坑小结\ndate: 2017-12-01\n---\n\n> 由于`weex` 的不稳定性，所以中途放弃了 `weex` 方案。转而使用 Android原生开发。今天项目第一阶段开发结束，来总结一下 `weex` 的一些东西。\n\n`weex` 相比于原生开发的好处\n\n* 界面搭建速度快，特别是重复性界面。\n* 数据处理方便，尤其是json解析方面。\n\n坏处么\n\n* 用的人太少，所以网上资料也很少。\n* 坑还是比较多的，要玩的溜要踩上不少坑。\n* 还是需要一些原生开发的知识才能够玩的溜。\n\n说说我这个项目的一些东西吧~\n\n## 页面跳转\n第一个困扰我的就是页面跳转，我去SF上提问了[Weex的页面跳转方案的选择](https://segmentfault.com/q/1010000009999942)这个问题。\n\n* `vue-router` 方案由于 `Vue`和 `weex` 的差异性，用法有所不同，好像需要使用注入 `minixs` 机制，挺麻烦的，所以放弃了……这个如果有需要我会再去研究一下的。\n* 第二种方案就是每个页面都是单独的 `Activity`，各自嵌入一个 `weex` 页面。但是有个问题：`weex` 如何与当前 `Activity` 交互，比如我要从页面A跳转到页面B，我需要 `weex` 调用 `Activity` 的 `startActivity` 方法，这个交互方式我没有找到。不然倒是可以随心所欲的在原生开发和weex之间来回交互。暂时来说我只知道[通过globalEvent和Module扩展来实现两者的交互](http://blog.csdn.net/violetjack0808/article/details/74002599)\n* 最后，还是选择了官方推荐的 `Navigator` 来作为页面跳转的方式。这种方式能够很快速的实现页面跳转。不用瞎折腾~\n\n选定方案之后，就要解决几个问题了。多页面打包和跳转所需的 `Activity` 。\n### 多页面打包\n`navigator` 的跳转方式，需要获取打包好的 `weex` 的文件路径来进行页面跳转和显示，所以我们就需要多页 `weex` 文件代表每一个页面。\n```\nnavigator.push({\n  url: 'http://dotwe.org/raw/dist/519962541fcf6acd911986357ad9c2ed.js',\n  animated: \"true\"\n}, event => {\n  modal.toast({ message: 'callback: ' + event })\n})\n```\n需要配置 `Webpack` 来实现这一目的。我将每个页面的入口文件都放在 `./src/entrys`文件夹下，通过 `node` 的 `fs文件模块` 读取里面的入口文件，并将他们传给 `entry` 入口对象。最后将入口对象配置到 `webpack` 打包配置中。\n```\nvar path = require('path')\nvar webpack = require('webpack')\nvar fs = require('fs')\n\nvar files = fs.readdirSync('./src/entrys')\nvar entry = {}\nfiles.forEach(function (file) {\n  var item = file.replace('.js', '')\n  entry[item] = path.resolve('./src/entrys/' + file)\n})\n\nvar bannerPlugin = new webpack.BannerPlugin(\n  '// { \"framework\": \"Vue\" }\\n', { raw: true }\n)\n\nfunction getBaseConfig() {\n  return {\n    entry: entry,\n    output: {\n      path: 'dist'\n    },\n    resolve: {\n      alias: {\n        '@': path.resolve('./src'),\n        'views': path.resolve('./src/views'),\n        'utils': path.resolve('./src/utils')\n      }\n    },\n    module: {\n      // ESLint配置\n      preLoaders: [{\n        test: /\\.vue$/,\n        loader: 'eslint',\n        exclude: /node_modules/\n      },\n      {\n        test: /\\.js$/,\n        loader: 'eslint',\n        exclude: /node_modules/\n      }\n      ],\n      // 如果注释掉以上这段将不产生ESLint检查\n      loaders: [{\n        test: /\\.js$/,\n        loader: 'babel',\n        exclude: /node_modules/\n      }, {\n        test: /\\.vue(\\?[^?]+)?$/,\n        loaders: []\n      }]\n    },\n    vue: {\n    },\n    plugins: [bannerPlugin]\n  }\n}\n\nvar webConfig = getBaseConfig()\nwebConfig.output.filename = '[name].web.js'\nwebConfig.module.loaders[1].loaders.push('vue')\n\nvar weexConfig = getBaseConfig()\nweexConfig.output.filename = '[name].weex.js'\nweexConfig.module.loaders[1].loaders.push('weex')\n\nmodule.exports = [webConfig, weexConfig]\n```\n每一个入口文件都会产生两个相应名称的文件，如 `sign.js` 的入口文件就会生成 `sign.weex.js` 和 `sign.web.js` 文件，这里我们只关注 `weex` 后缀的文件，这就是我们跳转页面所需的文件。具体项目结构请看[源代码](https://github.com/violetjack/MobileNurseWeex)\n更多对于 `webpack` 的了解可以看[Vue.js学习系列四——Webpack学习实践](http://blog.csdn.net/violetjack0808/article/details/54915825)\n\n### navigator跳转的Activity哪里来的？\n在使用了 `navigator` 后一开始发现并没有页面跳转效果，而是报 `ActivityNotFoundException` 的错误。后来装了 `weex` 的 playground 之后发现可以跳转了，但是跳转过去的 `Activity` 有个 ActionBar 和一个性能调试的悬浮窗，是 playground 里面扫二维码显示的结果的那个 `Activity`。几经查阅后发现原来跳转的 `Activity` 是一个有着特殊 `intent-filter` 的 `Activity` 。\n关于这个问题我写过一篇文章：[WEEX 使用navigator跳转Android系统出现ActivityNotFoundException报错](http://blog.csdn.net/violetjack0808/article/details/74390249)\n解决方案是我把 Playground 里面的那个 `Activity` 移到了我的项目中来，并且去除了 `ActionBar` 和调试工具。然后卸载掉 `weex`  的 Playground，这样就能愉快的显示 `navigator` 跳转的 `Activity` 了。代码请看[WXPageActivity](https://github.com/violetjack/MobileNurseWeex/blob/master/android/app/src/main/java/com/weex/sample/activity/WXPageActivity.java)。\n\n## 网络通信\n网络通信上我用的是stream，这个很简单。说下两点：\n第一，stream所用的url需要是UTF-8格式的，如果URL中有中文需要转一下，URL可以参照utf8这个文件。\n第二，提交数据的时候需要添加头文件。我的项目中是这样~\n```\n      stream.fetch({\n        method: StreamType,\n        type: 'json',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        url: url,\n        body: JSON.stringify(this.DataObj)\n      }, res => {\n        console.log(res)\n        let json = eval('(' + res.data + ')')\n        modal.alert({\n          message: json.Message\n        }, event => {\n\n        })\n      })\n```\n\n## 图片加载\n图片加载需要在[ImageAdapter](https://github.com/violetjack/MobileNurseWeex/blob/master/android/app/src/main/java/com/weex/sample/ImageAdapter.java)中稍作处理，我这里用的是 `Picasso` 来显示图片的~\n```\npublic class ImageAdapter implements IWXImgLoaderAdapter {\n    \n    @Override\n    public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) {\n        WXSDKManager.getInstance().postOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                if (view == null || view.getLayoutParams() == null) {\n                    return;\n                }\n                if (TextUtils.isEmpty(url)) {\n                    view.setImageBitmap(null);\n                    return;\n                }\n                String temp = url;\n                if (url.startsWith(\"//\")) {\n                    temp = \"http:\" + url;\n                }\n                if (view.getLayoutParams().width <= 0 || view.getLayoutParams().height <= 0) {\n                    return;\n                }\n                Picasso.with(WXEnvironment.getApplication())\n                        .load(temp)\n                        .into(view);\n            }\n        }, 0);\n    }\n}\n```\n\n### 页面跳转的数据传输\n这一点上，我只想到了不太优雅的方式——使用 `storage` 来保存和读取。比如我需要将表单ID传递到下一个页面我是这么做的：\n```\n    toDetail(AssessID) {\n      storage.setItem('AssessID', AssessID)\n      navigator.push({\n        url: ViewServer + 'GAD.weex.js',\n        animated: 'true'\n      }, event => {\n        console.log('successful entry')\n      })\n    },\n```\n到第二个页面去获取数据：\n```\n    getData() {\n      let that = this\n      storage.getItem('AssessID', event => {\n        let AssessID = event.data\n        console.log('AssessID = ' + AssessID)\n      })\n    },\n```\n如果是比较多的数据，我会将数据以 `json` 字符串的形式保存，在需要的时候获取字符串并解析为 `json` 对象。\n\n### 如何在返回上一页面时做一些操作？\n我的解决方法是在Activity的onResume方法中发送一个消息，然后在weex端添加监听事件。\n**Android端**\n```\n    @Override\n    protected void onResume() {\n        super.onResume();\n        if (mInstance != null) {\n            mInstance.onActivityResume();\n\n            new Handler().postDelayed(new Runnable() {\n                public void run() {\n                    Map<String, Object> params = new HashMap<>();\n                    mInstance.fireGlobalEventCallback(\"onResume\", params);\n                }\n            }, 500);\n        }\n    }\n```\n**weex端**\n```\n\taddListener() {\n      globalEvent.addEventListener('onResume', e => {\n        storage.getItem('PopCallback', event => {\n          if (event.data === 'update level list') {\n            this.loadData()\n            storage.setItem('PopCallback', '')\n          }\n        })\n      })\n    }\n```\n由于加载 `weex` 有一些延时，`onResume` 往往会比 `weex` 加载快，所以我在 `onResume` 中添加了0.5秒延时。之后在 `weex` 中添加监听器监听 `onResume` 的生命周期，并监听返回的数据。\n\n### 如何控制weex的Slider显示第几页\n想实现Android的ViewPager效果，使用了weex提供的slider组件，具体坚决方案看[如何控制weex的Slider显示第几页。](https://segmentfault.com/q/1010000010728251)\n\n### 其他\n\n* 图片的存放好像只能是网络图片的URL，所以我将所有图片都放到服务器上让weex去访问。\n* CSS使用flex布局来做，官网上有例子。也可参照[Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)。\n\n# 最后\n啰嗦一大堆，希望某些东西能够对他人有所帮助吧~\n项目地址[在此](https://github.com/violetjack/MobileNurseWeex)，由于是公司项目，所以把服务器地址去掉了，后端数据获取不了。不过代码都是在的，可以进行参考。希望能对大家有所帮助~\n最终不用weex的原因么，因为这玩意看似简单，但是想实现点复杂的、和原生交互的功能都得折腾好一会儿。关键还是资料太少，不靠谱，万一哪个地方报个奇怪的错误找不出问题、查不到资料、看不懂源码，那不就挂了嘛~所以，爱折腾玩玩可以，放项目中还是有待考虑。毕竟还是要求稳~\n\n\n","slug":"weex项目弃坑小结","published":1,"updated":"2018-02-07T02:28:26.177Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjddwxbmp000fi8btf957ribo","content":"<blockquote>\n<p>由于<code>weex</code> 的不稳定性，所以中途放弃了 <code>weex</code> 方案。转而使用 Android原生开发。今天项目第一阶段开发结束，来总结一下 <code>weex</code> 的一些东西。</p>\n</blockquote>\n<p><code>weex</code> 相比于原生开发的好处</p>\n<ul>\n<li>界面搭建速度快，特别是重复性界面。</li>\n<li>数据处理方便，尤其是json解析方面。</li>\n</ul>\n<p>坏处么</p>\n<ul>\n<li>用的人太少，所以网上资料也很少。</li>\n<li>坑还是比较多的，要玩的溜要踩上不少坑。</li>\n<li>还是需要一些原生开发的知识才能够玩的溜。</li>\n</ul>\n<p>说说我这个项目的一些东西吧~</p>\n<h2 id=\"页面跳转\"><a href=\"#页面跳转\" class=\"headerlink\" title=\"页面跳转\"></a>页面跳转</h2><p>第一个困扰我的就是页面跳转，我去SF上提问了<a href=\"https://segmentfault.com/q/1010000009999942\" target=\"_blank\" rel=\"noopener\">Weex的页面跳转方案的选择</a>这个问题。</p>\n<ul>\n<li><code>vue-router</code> 方案由于 <code>Vue</code>和 <code>weex</code> 的差异性，用法有所不同，好像需要使用注入 <code>minixs</code> 机制，挺麻烦的，所以放弃了……这个如果有需要我会再去研究一下的。</li>\n<li>第二种方案就是每个页面都是单独的 <code>Activity</code>，各自嵌入一个 <code>weex</code> 页面。但是有个问题：<code>weex</code> 如何与当前 <code>Activity</code> 交互，比如我要从页面A跳转到页面B，我需要 <code>weex</code> 调用 <code>Activity</code> 的 <code>startActivity</code> 方法，这个交互方式我没有找到。不然倒是可以随心所欲的在原生开发和weex之间来回交互。暂时来说我只知道<a href=\"http://blog.csdn.net/violetjack0808/article/details/74002599\" target=\"_blank\" rel=\"noopener\">通过globalEvent和Module扩展来实现两者的交互</a></li>\n<li>最后，还是选择了官方推荐的 <code>Navigator</code> 来作为页面跳转的方式。这种方式能够很快速的实现页面跳转。不用瞎折腾~</li>\n</ul>\n<p>选定方案之后，就要解决几个问题了。多页面打包和跳转所需的 <code>Activity</code> 。</p>\n<h3 id=\"多页面打包\"><a href=\"#多页面打包\" class=\"headerlink\" title=\"多页面打包\"></a>多页面打包</h3><p><code>navigator</code> 的跳转方式，需要获取打包好的 <code>weex</code> 的文件路径来进行页面跳转和显示，所以我们就需要多页 <code>weex</code> 文件代表每一个页面。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">navigator.push(&#123;</span><br><span class=\"line\">  url: &apos;http://dotwe.org/raw/dist/519962541fcf6acd911986357ad9c2ed.js&apos;,</span><br><span class=\"line\">  animated: &quot;true&quot;</span><br><span class=\"line\">&#125;, event =&gt; &#123;</span><br><span class=\"line\">  modal.toast(&#123; message: &apos;callback: &apos; + event &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>需要配置 <code>Webpack</code> 来实现这一目的。我将每个页面的入口文件都放在 <code>./src/entrys</code>文件夹下，通过 <code>node</code> 的 <code>fs文件模块</code> 读取里面的入口文件，并将他们传给 <code>entry</code> 入口对象。最后将入口对象配置到 <code>webpack</code> 打包配置中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var path = require(&apos;path&apos;)</span><br><span class=\"line\">var webpack = require(&apos;webpack&apos;)</span><br><span class=\"line\">var fs = require(&apos;fs&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">var files = fs.readdirSync(&apos;./src/entrys&apos;)</span><br><span class=\"line\">var entry = &#123;&#125;</span><br><span class=\"line\">files.forEach(function (file) &#123;</span><br><span class=\"line\">  var item = file.replace(&apos;.js&apos;, &apos;&apos;)</span><br><span class=\"line\">  entry[item] = path.resolve(&apos;./src/entrys/&apos; + file)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">var bannerPlugin = new webpack.BannerPlugin(</span><br><span class=\"line\">  &apos;// &#123; &quot;framework&quot;: &quot;Vue&quot; &#125;\\n&apos;, &#123; raw: true &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">function getBaseConfig() &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    entry: entry,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">      path: &apos;dist&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    resolve: &#123;</span><br><span class=\"line\">      alias: &#123;</span><br><span class=\"line\">        &apos;@&apos;: path.resolve(&apos;./src&apos;),</span><br><span class=\"line\">        &apos;views&apos;: path.resolve(&apos;./src/views&apos;),</span><br><span class=\"line\">        &apos;utils&apos;: path.resolve(&apos;./src/utils&apos;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\">      // ESLint配置</span><br><span class=\"line\">      preLoaders: [&#123;</span><br><span class=\"line\">        test: /\\.vue$/,</span><br><span class=\"line\">        loader: &apos;eslint&apos;,</span><br><span class=\"line\">        exclude: /node_modules/</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.js$/,</span><br><span class=\"line\">        loader: &apos;eslint&apos;,</span><br><span class=\"line\">        exclude: /node_modules/</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">      // 如果注释掉以上这段将不产生ESLint检查</span><br><span class=\"line\">      loaders: [&#123;</span><br><span class=\"line\">        test: /\\.js$/,</span><br><span class=\"line\">        loader: &apos;babel&apos;,</span><br><span class=\"line\">        exclude: /node_modules/</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        test: /\\.vue(\\?[^?]+)?$/,</span><br><span class=\"line\">        loaders: []</span><br><span class=\"line\">      &#125;]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    vue: &#123;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins: [bannerPlugin]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var webConfig = getBaseConfig()</span><br><span class=\"line\">webConfig.output.filename = &apos;[name].web.js&apos;</span><br><span class=\"line\">webConfig.module.loaders[1].loaders.push(&apos;vue&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">var weexConfig = getBaseConfig()</span><br><span class=\"line\">weexConfig.output.filename = &apos;[name].weex.js&apos;</span><br><span class=\"line\">weexConfig.module.loaders[1].loaders.push(&apos;weex&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = [webConfig, weexConfig]</span><br></pre></td></tr></table></figure></p>\n<p>每一个入口文件都会产生两个相应名称的文件，如 <code>sign.js</code> 的入口文件就会生成 <code>sign.weex.js</code> 和 <code>sign.web.js</code> 文件，这里我们只关注 <code>weex</code> 后缀的文件，这就是我们跳转页面所需的文件。具体项目结构请看<a href=\"https://github.com/violetjack/MobileNurseWeex\" target=\"_blank\" rel=\"noopener\">源代码</a><br>更多对于 <code>webpack</code> 的了解可以看<a href=\"http://blog.csdn.net/violetjack0808/article/details/54915825\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四——Webpack学习实践</a></p>\n<h3 id=\"navigator跳转的Activity哪里来的？\"><a href=\"#navigator跳转的Activity哪里来的？\" class=\"headerlink\" title=\"navigator跳转的Activity哪里来的？\"></a>navigator跳转的Activity哪里来的？</h3><p>在使用了 <code>navigator</code> 后一开始发现并没有页面跳转效果，而是报 <code>ActivityNotFoundException</code> 的错误。后来装了 <code>weex</code> 的 playground 之后发现可以跳转了，但是跳转过去的 <code>Activity</code> 有个 ActionBar 和一个性能调试的悬浮窗，是 playground 里面扫二维码显示的结果的那个 <code>Activity</code>。几经查阅后发现原来跳转的 <code>Activity</code> 是一个有着特殊 <code>intent-filter</code> 的 <code>Activity</code> 。<br>关于这个问题我写过一篇文章：<a href=\"http://blog.csdn.net/violetjack0808/article/details/74390249\" target=\"_blank\" rel=\"noopener\">WEEX 使用navigator跳转Android系统出现ActivityNotFoundException报错</a><br>解决方案是我把 Playground 里面的那个 <code>Activity</code> 移到了我的项目中来，并且去除了 <code>ActionBar</code> 和调试工具。然后卸载掉 <code>weex</code>  的 Playground，这样就能愉快的显示 <code>navigator</code> 跳转的 <code>Activity</code> 了。代码请看<a href=\"https://github.com/violetjack/MobileNurseWeex/blob/master/android/app/src/main/java/com/weex/sample/activity/WXPageActivity.java\" target=\"_blank\" rel=\"noopener\">WXPageActivity</a>。</p>\n<h2 id=\"网络通信\"><a href=\"#网络通信\" class=\"headerlink\" title=\"网络通信\"></a>网络通信</h2><p>网络通信上我用的是stream，这个很简单。说下两点：<br>第一，stream所用的url需要是UTF-8格式的，如果URL中有中文需要转一下，URL可以参照utf8这个文件。<br>第二，提交数据的时候需要添加头文件。我的项目中是这样~<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stream.fetch(&#123;</span><br><span class=\"line\">  method: StreamType,</span><br><span class=\"line\">  type: &apos;json&apos;,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    &apos;Content-Type&apos;: &apos;application/json&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  url: url,</span><br><span class=\"line\">  body: JSON.stringify(this.DataObj)</span><br><span class=\"line\">&#125;, res =&gt; &#123;</span><br><span class=\"line\">  console.log(res)</span><br><span class=\"line\">  let json = eval(&apos;(&apos; + res.data + &apos;)&apos;)</span><br><span class=\"line\">  modal.alert(&#123;</span><br><span class=\"line\">    message: json.Message</span><br><span class=\"line\">  &#125;, event =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"图片加载\"><a href=\"#图片加载\" class=\"headerlink\" title=\"图片加载\"></a>图片加载</h2><p>图片加载需要在<a href=\"https://github.com/violetjack/MobileNurseWeex/blob/master/android/app/src/main/java/com/weex/sample/ImageAdapter.java\" target=\"_blank\" rel=\"noopener\">ImageAdapter</a>中稍作处理，我这里用的是 <code>Picasso</code> 来显示图片的~<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ImageAdapter implements IWXImgLoaderAdapter &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123;</span><br><span class=\"line\">        WXSDKManager.getInstance().postOnUiThread(new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                if (view == null || view.getLayoutParams() == null) &#123;</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (TextUtils.isEmpty(url)) &#123;</span><br><span class=\"line\">                    view.setImageBitmap(null);</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                String temp = url;</span><br><span class=\"line\">                if (url.startsWith(&quot;//&quot;)) &#123;</span><br><span class=\"line\">                    temp = &quot;http:&quot; + url;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (view.getLayoutParams().width &lt;= 0 || view.getLayoutParams().height &lt;= 0) &#123;</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Picasso.with(WXEnvironment.getApplication())</span><br><span class=\"line\">                        .load(temp)</span><br><span class=\"line\">                        .into(view);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"页面跳转的数据传输\"><a href=\"#页面跳转的数据传输\" class=\"headerlink\" title=\"页面跳转的数据传输\"></a>页面跳转的数据传输</h3><p>这一点上，我只想到了不太优雅的方式——使用 <code>storage</code> 来保存和读取。比如我需要将表单ID传递到下一个页面我是这么做的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">toDetail(AssessID) &#123;</span><br><span class=\"line\">  storage.setItem(&apos;AssessID&apos;, AssessID)</span><br><span class=\"line\">  navigator.push(&#123;</span><br><span class=\"line\">    url: ViewServer + &apos;GAD.weex.js&apos;,</span><br><span class=\"line\">    animated: &apos;true&apos;</span><br><span class=\"line\">  &#125;, event =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;successful entry&apos;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>到第二个页面去获取数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getData() &#123;</span><br><span class=\"line\">  let that = this</span><br><span class=\"line\">  storage.getItem(&apos;AssessID&apos;, event =&gt; &#123;</span><br><span class=\"line\">    let AssessID = event.data</span><br><span class=\"line\">    console.log(&apos;AssessID = &apos; + AssessID)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>如果是比较多的数据，我会将数据以 <code>json</code> 字符串的形式保存，在需要的时候获取字符串并解析为 <code>json</code> 对象。</p>\n<h3 id=\"如何在返回上一页面时做一些操作？\"><a href=\"#如何在返回上一页面时做一些操作？\" class=\"headerlink\" title=\"如何在返回上一页面时做一些操作？\"></a>如何在返回上一页面时做一些操作？</h3><p>我的解决方法是在Activity的onResume方法中发送一个消息，然后在weex端添加监听事件。<br><strong>Android端</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onResume() &#123;</span><br><span class=\"line\">    super.onResume();</span><br><span class=\"line\">    if (mInstance != null) &#123;</span><br><span class=\"line\">        mInstance.onActivityResume();</span><br><span class=\"line\"></span><br><span class=\"line\">        new Handler().postDelayed(new Runnable() &#123;</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();</span><br><span class=\"line\">                mInstance.fireGlobalEventCallback(&quot;onResume&quot;, params);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, 500);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>weex端</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addListener() &#123;</span><br><span class=\"line\">     globalEvent.addEventListener(&apos;onResume&apos;, e =&gt; &#123;</span><br><span class=\"line\">       storage.getItem(&apos;PopCallback&apos;, event =&gt; &#123;</span><br><span class=\"line\">         if (event.data === &apos;update level list&apos;) &#123;</span><br><span class=\"line\">           this.loadData()</span><br><span class=\"line\">           storage.setItem(&apos;PopCallback&apos;, &apos;&apos;)</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于加载 <code>weex</code> 有一些延时，<code>onResume</code> 往往会比 <code>weex</code> 加载快，所以我在 <code>onResume</code> 中添加了0.5秒延时。之后在 <code>weex</code> 中添加监听器监听 <code>onResume</code> 的生命周期，并监听返回的数据。</p>\n<h3 id=\"如何控制weex的Slider显示第几页\"><a href=\"#如何控制weex的Slider显示第几页\" class=\"headerlink\" title=\"如何控制weex的Slider显示第几页\"></a>如何控制weex的Slider显示第几页</h3><p>想实现Android的ViewPager效果，使用了weex提供的slider组件，具体坚决方案看<a href=\"https://segmentfault.com/q/1010000010728251\" target=\"_blank\" rel=\"noopener\">如何控制weex的Slider显示第几页。</a></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>图片的存放好像只能是网络图片的URL，所以我将所有图片都放到服务器上让weex去访问。</li>\n<li>CSS使用flex布局来做，官网上有例子。也可参照<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"noopener\">Flex 布局教程：语法篇</a>。</li>\n</ul>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>啰嗦一大堆，希望某些东西能够对他人有所帮助吧~<br>项目地址<a href=\"https://github.com/violetjack/MobileNurseWeex\" target=\"_blank\" rel=\"noopener\">在此</a>，由于是公司项目，所以把服务器地址去掉了，后端数据获取不了。不过代码都是在的，可以进行参考。希望能对大家有所帮助~<br>最终不用weex的原因么，因为这玩意看似简单，但是想实现点复杂的、和原生交互的功能都得折腾好一会儿。关键还是资料太少，不靠谱，万一哪个地方报个奇怪的错误找不出问题、查不到资料、看不懂源码，那不就挂了嘛~所以，爱折腾玩玩可以，放项目中还是有待考虑。毕竟还是要求稳~</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>由于<code>weex</code> 的不稳定性，所以中途放弃了 <code>weex</code> 方案。转而使用 Android原生开发。今天项目第一阶段开发结束，来总结一下 <code>weex</code> 的一些东西。</p>\n</blockquote>\n<p><code>weex</code> 相比于原生开发的好处</p>\n<ul>\n<li>界面搭建速度快，特别是重复性界面。</li>\n<li>数据处理方便，尤其是json解析方面。</li>\n</ul>\n<p>坏处么</p>\n<ul>\n<li>用的人太少，所以网上资料也很少。</li>\n<li>坑还是比较多的，要玩的溜要踩上不少坑。</li>\n<li>还是需要一些原生开发的知识才能够玩的溜。</li>\n</ul>\n<p>说说我这个项目的一些东西吧~</p>\n<h2 id=\"页面跳转\"><a href=\"#页面跳转\" class=\"headerlink\" title=\"页面跳转\"></a>页面跳转</h2><p>第一个困扰我的就是页面跳转，我去SF上提问了<a href=\"https://segmentfault.com/q/1010000009999942\" target=\"_blank\" rel=\"noopener\">Weex的页面跳转方案的选择</a>这个问题。</p>\n<ul>\n<li><code>vue-router</code> 方案由于 <code>Vue</code>和 <code>weex</code> 的差异性，用法有所不同，好像需要使用注入 <code>minixs</code> 机制，挺麻烦的，所以放弃了……这个如果有需要我会再去研究一下的。</li>\n<li>第二种方案就是每个页面都是单独的 <code>Activity</code>，各自嵌入一个 <code>weex</code> 页面。但是有个问题：<code>weex</code> 如何与当前 <code>Activity</code> 交互，比如我要从页面A跳转到页面B，我需要 <code>weex</code> 调用 <code>Activity</code> 的 <code>startActivity</code> 方法，这个交互方式我没有找到。不然倒是可以随心所欲的在原生开发和weex之间来回交互。暂时来说我只知道<a href=\"http://blog.csdn.net/violetjack0808/article/details/74002599\" target=\"_blank\" rel=\"noopener\">通过globalEvent和Module扩展来实现两者的交互</a></li>\n<li>最后，还是选择了官方推荐的 <code>Navigator</code> 来作为页面跳转的方式。这种方式能够很快速的实现页面跳转。不用瞎折腾~</li>\n</ul>\n<p>选定方案之后，就要解决几个问题了。多页面打包和跳转所需的 <code>Activity</code> 。</p>\n<h3 id=\"多页面打包\"><a href=\"#多页面打包\" class=\"headerlink\" title=\"多页面打包\"></a>多页面打包</h3><p><code>navigator</code> 的跳转方式，需要获取打包好的 <code>weex</code> 的文件路径来进行页面跳转和显示，所以我们就需要多页 <code>weex</code> 文件代表每一个页面。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">navigator.push(&#123;</span><br><span class=\"line\">  url: &apos;http://dotwe.org/raw/dist/519962541fcf6acd911986357ad9c2ed.js&apos;,</span><br><span class=\"line\">  animated: &quot;true&quot;</span><br><span class=\"line\">&#125;, event =&gt; &#123;</span><br><span class=\"line\">  modal.toast(&#123; message: &apos;callback: &apos; + event &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>需要配置 <code>Webpack</code> 来实现这一目的。我将每个页面的入口文件都放在 <code>./src/entrys</code>文件夹下，通过 <code>node</code> 的 <code>fs文件模块</code> 读取里面的入口文件，并将他们传给 <code>entry</code> 入口对象。最后将入口对象配置到 <code>webpack</code> 打包配置中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var path = require(&apos;path&apos;)</span><br><span class=\"line\">var webpack = require(&apos;webpack&apos;)</span><br><span class=\"line\">var fs = require(&apos;fs&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">var files = fs.readdirSync(&apos;./src/entrys&apos;)</span><br><span class=\"line\">var entry = &#123;&#125;</span><br><span class=\"line\">files.forEach(function (file) &#123;</span><br><span class=\"line\">  var item = file.replace(&apos;.js&apos;, &apos;&apos;)</span><br><span class=\"line\">  entry[item] = path.resolve(&apos;./src/entrys/&apos; + file)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">var bannerPlugin = new webpack.BannerPlugin(</span><br><span class=\"line\">  &apos;// &#123; &quot;framework&quot;: &quot;Vue&quot; &#125;\\n&apos;, &#123; raw: true &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">function getBaseConfig() &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    entry: entry,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">      path: &apos;dist&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    resolve: &#123;</span><br><span class=\"line\">      alias: &#123;</span><br><span class=\"line\">        &apos;@&apos;: path.resolve(&apos;./src&apos;),</span><br><span class=\"line\">        &apos;views&apos;: path.resolve(&apos;./src/views&apos;),</span><br><span class=\"line\">        &apos;utils&apos;: path.resolve(&apos;./src/utils&apos;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    module: &#123;</span><br><span class=\"line\">      // ESLint配置</span><br><span class=\"line\">      preLoaders: [&#123;</span><br><span class=\"line\">        test: /\\.vue$/,</span><br><span class=\"line\">        loader: &apos;eslint&apos;,</span><br><span class=\"line\">        exclude: /node_modules/</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.js$/,</span><br><span class=\"line\">        loader: &apos;eslint&apos;,</span><br><span class=\"line\">        exclude: /node_modules/</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">      // 如果注释掉以上这段将不产生ESLint检查</span><br><span class=\"line\">      loaders: [&#123;</span><br><span class=\"line\">        test: /\\.js$/,</span><br><span class=\"line\">        loader: &apos;babel&apos;,</span><br><span class=\"line\">        exclude: /node_modules/</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        test: /\\.vue(\\?[^?]+)?$/,</span><br><span class=\"line\">        loaders: []</span><br><span class=\"line\">      &#125;]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    vue: &#123;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins: [bannerPlugin]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var webConfig = getBaseConfig()</span><br><span class=\"line\">webConfig.output.filename = &apos;[name].web.js&apos;</span><br><span class=\"line\">webConfig.module.loaders[1].loaders.push(&apos;vue&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">var weexConfig = getBaseConfig()</span><br><span class=\"line\">weexConfig.output.filename = &apos;[name].weex.js&apos;</span><br><span class=\"line\">weexConfig.module.loaders[1].loaders.push(&apos;weex&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = [webConfig, weexConfig]</span><br></pre></td></tr></table></figure></p>\n<p>每一个入口文件都会产生两个相应名称的文件，如 <code>sign.js</code> 的入口文件就会生成 <code>sign.weex.js</code> 和 <code>sign.web.js</code> 文件，这里我们只关注 <code>weex</code> 后缀的文件，这就是我们跳转页面所需的文件。具体项目结构请看<a href=\"https://github.com/violetjack/MobileNurseWeex\" target=\"_blank\" rel=\"noopener\">源代码</a><br>更多对于 <code>webpack</code> 的了解可以看<a href=\"http://blog.csdn.net/violetjack0808/article/details/54915825\" target=\"_blank\" rel=\"noopener\">Vue.js学习系列四——Webpack学习实践</a></p>\n<h3 id=\"navigator跳转的Activity哪里来的？\"><a href=\"#navigator跳转的Activity哪里来的？\" class=\"headerlink\" title=\"navigator跳转的Activity哪里来的？\"></a>navigator跳转的Activity哪里来的？</h3><p>在使用了 <code>navigator</code> 后一开始发现并没有页面跳转效果，而是报 <code>ActivityNotFoundException</code> 的错误。后来装了 <code>weex</code> 的 playground 之后发现可以跳转了，但是跳转过去的 <code>Activity</code> 有个 ActionBar 和一个性能调试的悬浮窗，是 playground 里面扫二维码显示的结果的那个 <code>Activity</code>。几经查阅后发现原来跳转的 <code>Activity</code> 是一个有着特殊 <code>intent-filter</code> 的 <code>Activity</code> 。<br>关于这个问题我写过一篇文章：<a href=\"http://blog.csdn.net/violetjack0808/article/details/74390249\" target=\"_blank\" rel=\"noopener\">WEEX 使用navigator跳转Android系统出现ActivityNotFoundException报错</a><br>解决方案是我把 Playground 里面的那个 <code>Activity</code> 移到了我的项目中来，并且去除了 <code>ActionBar</code> 和调试工具。然后卸载掉 <code>weex</code>  的 Playground，这样就能愉快的显示 <code>navigator</code> 跳转的 <code>Activity</code> 了。代码请看<a href=\"https://github.com/violetjack/MobileNurseWeex/blob/master/android/app/src/main/java/com/weex/sample/activity/WXPageActivity.java\" target=\"_blank\" rel=\"noopener\">WXPageActivity</a>。</p>\n<h2 id=\"网络通信\"><a href=\"#网络通信\" class=\"headerlink\" title=\"网络通信\"></a>网络通信</h2><p>网络通信上我用的是stream，这个很简单。说下两点：<br>第一，stream所用的url需要是UTF-8格式的，如果URL中有中文需要转一下，URL可以参照utf8这个文件。<br>第二，提交数据的时候需要添加头文件。我的项目中是这样~<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stream.fetch(&#123;</span><br><span class=\"line\">  method: StreamType,</span><br><span class=\"line\">  type: &apos;json&apos;,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    &apos;Content-Type&apos;: &apos;application/json&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  url: url,</span><br><span class=\"line\">  body: JSON.stringify(this.DataObj)</span><br><span class=\"line\">&#125;, res =&gt; &#123;</span><br><span class=\"line\">  console.log(res)</span><br><span class=\"line\">  let json = eval(&apos;(&apos; + res.data + &apos;)&apos;)</span><br><span class=\"line\">  modal.alert(&#123;</span><br><span class=\"line\">    message: json.Message</span><br><span class=\"line\">  &#125;, event =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"图片加载\"><a href=\"#图片加载\" class=\"headerlink\" title=\"图片加载\"></a>图片加载</h2><p>图片加载需要在<a href=\"https://github.com/violetjack/MobileNurseWeex/blob/master/android/app/src/main/java/com/weex/sample/ImageAdapter.java\" target=\"_blank\" rel=\"noopener\">ImageAdapter</a>中稍作处理，我这里用的是 <code>Picasso</code> 来显示图片的~<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ImageAdapter implements IWXImgLoaderAdapter &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123;</span><br><span class=\"line\">        WXSDKManager.getInstance().postOnUiThread(new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                if (view == null || view.getLayoutParams() == null) &#123;</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (TextUtils.isEmpty(url)) &#123;</span><br><span class=\"line\">                    view.setImageBitmap(null);</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                String temp = url;</span><br><span class=\"line\">                if (url.startsWith(&quot;//&quot;)) &#123;</span><br><span class=\"line\">                    temp = &quot;http:&quot; + url;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (view.getLayoutParams().width &lt;= 0 || view.getLayoutParams().height &lt;= 0) &#123;</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Picasso.with(WXEnvironment.getApplication())</span><br><span class=\"line\">                        .load(temp)</span><br><span class=\"line\">                        .into(view);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"页面跳转的数据传输\"><a href=\"#页面跳转的数据传输\" class=\"headerlink\" title=\"页面跳转的数据传输\"></a>页面跳转的数据传输</h3><p>这一点上，我只想到了不太优雅的方式——使用 <code>storage</code> 来保存和读取。比如我需要将表单ID传递到下一个页面我是这么做的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">toDetail(AssessID) &#123;</span><br><span class=\"line\">  storage.setItem(&apos;AssessID&apos;, AssessID)</span><br><span class=\"line\">  navigator.push(&#123;</span><br><span class=\"line\">    url: ViewServer + &apos;GAD.weex.js&apos;,</span><br><span class=\"line\">    animated: &apos;true&apos;</span><br><span class=\"line\">  &#125;, event =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;successful entry&apos;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>到第二个页面去获取数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getData() &#123;</span><br><span class=\"line\">  let that = this</span><br><span class=\"line\">  storage.getItem(&apos;AssessID&apos;, event =&gt; &#123;</span><br><span class=\"line\">    let AssessID = event.data</span><br><span class=\"line\">    console.log(&apos;AssessID = &apos; + AssessID)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>如果是比较多的数据，我会将数据以 <code>json</code> 字符串的形式保存，在需要的时候获取字符串并解析为 <code>json</code> 对象。</p>\n<h3 id=\"如何在返回上一页面时做一些操作？\"><a href=\"#如何在返回上一页面时做一些操作？\" class=\"headerlink\" title=\"如何在返回上一页面时做一些操作？\"></a>如何在返回上一页面时做一些操作？</h3><p>我的解决方法是在Activity的onResume方法中发送一个消息，然后在weex端添加监听事件。<br><strong>Android端</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void onResume() &#123;</span><br><span class=\"line\">    super.onResume();</span><br><span class=\"line\">    if (mInstance != null) &#123;</span><br><span class=\"line\">        mInstance.onActivityResume();</span><br><span class=\"line\"></span><br><span class=\"line\">        new Handler().postDelayed(new Runnable() &#123;</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();</span><br><span class=\"line\">                mInstance.fireGlobalEventCallback(&quot;onResume&quot;, params);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, 500);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>weex端</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addListener() &#123;</span><br><span class=\"line\">     globalEvent.addEventListener(&apos;onResume&apos;, e =&gt; &#123;</span><br><span class=\"line\">       storage.getItem(&apos;PopCallback&apos;, event =&gt; &#123;</span><br><span class=\"line\">         if (event.data === &apos;update level list&apos;) &#123;</span><br><span class=\"line\">           this.loadData()</span><br><span class=\"line\">           storage.setItem(&apos;PopCallback&apos;, &apos;&apos;)</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于加载 <code>weex</code> 有一些延时，<code>onResume</code> 往往会比 <code>weex</code> 加载快，所以我在 <code>onResume</code> 中添加了0.5秒延时。之后在 <code>weex</code> 中添加监听器监听 <code>onResume</code> 的生命周期，并监听返回的数据。</p>\n<h3 id=\"如何控制weex的Slider显示第几页\"><a href=\"#如何控制weex的Slider显示第几页\" class=\"headerlink\" title=\"如何控制weex的Slider显示第几页\"></a>如何控制weex的Slider显示第几页</h3><p>想实现Android的ViewPager效果，使用了weex提供的slider组件，具体坚决方案看<a href=\"https://segmentfault.com/q/1010000010728251\" target=\"_blank\" rel=\"noopener\">如何控制weex的Slider显示第几页。</a></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>图片的存放好像只能是网络图片的URL，所以我将所有图片都放到服务器上让weex去访问。</li>\n<li>CSS使用flex布局来做，官网上有例子。也可参照<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" target=\"_blank\" rel=\"noopener\">Flex 布局教程：语法篇</a>。</li>\n</ul>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>啰嗦一大堆，希望某些东西能够对他人有所帮助吧~<br>项目地址<a href=\"https://github.com/violetjack/MobileNurseWeex\" target=\"_blank\" rel=\"noopener\">在此</a>，由于是公司项目，所以把服务器地址去掉了，后端数据获取不了。不过代码都是在的，可以进行参考。希望能对大家有所帮助~<br>最终不用weex的原因么，因为这玩意看似简单，但是想实现点复杂的、和原生交互的功能都得折腾好一会儿。关键还是资料太少，不靠谱，万一哪个地方报个奇怪的错误找不出问题、查不到资料、看不懂源码，那不就挂了嘛~所以，爱折腾玩玩可以，放项目中还是有待考虑。毕竟还是要求稳~</p>\n"},{"title":"将表单从jQuery转Vue框架实践总结","date":"2016-05-18T16:00:00.000Z","_content":"\n> 工作需要，将公司项目从jQuery转成Vue来写。这里分享下转变项目的过程并写了一个小demo，希望能对遇到同样问题的朋友一些帮助。\nPS： 本人Android开发，兼职前端，前端知识浅薄，有什么不对的地方还请指出，大家共同进步。谢谢~\n由于代码较多，我把源码放在了博客最后了。\n\n# jQuery和Vue的区别\njQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：`$(\"lable\").val();`,它还是依赖DOM元素的值。\nVue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。\n\n# jQuery to Vue\n## 1. 导入Vue.js，去除jQuery。\n下载Vue.js，导入工程,我将其放在头文件中。\n```\n<script src=\"vue.js\"></script>\n```\n[Vue.js下载地址](http://cn.vuejs.org/guide/installation.html)\n## 2. 根视图id绑定\n为最外层的div标签定义id，然后使用Vue的el属性进行绑定\n```\n<div id=\"app\">\n        <h2>学生信息登记</h2>\n        ...\n        <label>{{ result }}</label>    \n</div>\n...\n<script>\n    new Vue({\n        el: '#app',\n        ...\n    });\n</script>\n...\n```\n\n\n## 3. 为input添加v-model\n使用v-model属性将input标签的value值绑定到data的相应数据中。\n```\n<div>\n    <label>姓名：</label>\n    <input type=\"text\" placeholder=\"请输入姓名\" v-model=\"name\">\n</div>\n<div>\n    <label>性别：</label>\n    <input id=\"sex01\" type=\"radio\" value=\"1\" v-model=\"sex\">\n    <label for=\"sex01\">男</label>\n    <input id=\"sex02\" type=\"radio\" value=\"2\" v-model=\"sex\">\n    <label for=\"sex02\">女</label>\n</div>\n<div>\n    <label>年龄：</label>\n    <select v-model=\"age\">\n        <option selected>18</option>\n        <option>19</option>\n        <option>20</option>\n        <option>21</option>\n    </select></div><div>\n    <label>党员：</label>\n    <input type=\"checkbox\" v-model=\"member\">\n</div>\n```\n注意上方的v-model，我们在Vue对象的data属性中绑定数据：\n```\nnew Vue({\n    el: '#app',\n    data: {\n        name: '',\n        sex: '',\n        age: '',\n        member: '',\n        result: ''\n    },\n    ...\n})\n```\n到这里就实现了将表单input框和数据的绑定。更多Vue表单绑定可以查看[表单控件绑定](http://cn.vuejs.org/guide/forms.html)\n## 4. 删除id、name这些用于jQuery的属性\n在使用jQuery时，在HTML中需要定义大量的id、name之类的属性用于jQuery选择器获取元素。\n```\n<input type=\"text\" placeholder=\"请输入姓名\" id=\"name\">\n...\nvar name = $('#name').val();\n```\n我们这里就不需要了。去除HTML中的这些属性。\n（其实这里v-model和id的作用有些类似，都是一个桥梁作用。我在修改的时候偷懒直接将id改成v-model，后面的name不改~）\n## 5. 将点击事件onclick改为v-on:click\nVue提供了v-on来监听DOM事件，如demo中的点击事件监听属性v-on:click。\n```\n<button id=\"btnCommit\" v-on:click=\"commit\">提交</button>\n<button id=\"btnReset\" v-on:click=\"reset\">重置</button>\n```\n然后在Vue对象的methods属性中创建这两个事件方法。\n```\nnew Vue ({\n    ...\n    methods: {\n        commit: function () {...},\n        reset: function () {...},\n    ...\n...\n```\n另外，Vue还提供了其他v-on:属性，如v-on:change、v-on:keyup等。具体请看：[方法与事件处理](http://cn.vuejs.org/guide/events.html)\n\n## 6. 引用数据\n作为MVVM，当然是双向绑定的。Vue用v-model属性使input可以修改数据内容，实现界面修改数据；使用双大括号来引用数据内容，实现数据修改界面。\n具体写法如下：\n```\n<label>{{ result }}</label>\n...\ndata: {\n    result: 'hello world',\n    ...\n}\n```\n如上引用后，数据`hello world`将会实时同步显示在labal标签上，每当result数据有所改变，label的内容立即会改变。\n## 7. 替换ready方法\njQuery中为我们提供了一个document的ready方法，Vue中有ready属性，它们的触发时间差不多，具体要参考各自的生命周期。\n**jQuery写法：**\n```\n$(document).ready(function () {\n    alert(\"加载完成\");\n});\n```\n**Vue写法：**\n```\nnew Vue ({\n    ...\n    ready: function () {\n        alert(\"加载完成\");\n    },\n    ...\n})\n```\n## 8.修改获取和修改元素属性的方式\n这是jQuery和Vue的最大不同点了。先看代码:\n**jQuery:**\n```\nvar name = $('#name').val();\nvar sex = '';\nif (getChackedValue('input[name=sex]') == 1){\n    sex = '男'\n}else if (getChackedValue('input[name=sex]') == 2){\n    sex = '女'\n}\nvar age = $('#age').val();\nvar member = '';\nif($('#member').is(':checked')) {\n    member = '党员';\n}else {\n    member = \"非党员\";\n}\nvar result = name + ' ' + sex + ' ' + age + ' ' + member;\n$('#result').text(result);\n```\n这是显示表单结果的函数。jQuery是通过美元符号$来获取指定元素，然后通过val()、text()等方法获取指定元素的内容或者为指定元素赋值。\n**Vue：**\n```\nvar name = this.name;\nvar sex = '';\nif (this.sex == 1){\n    sex = '男';\n}else if (this.sex == 2){\n    sex = '女';\n}\nvar age = this.age;\nvar member = '';\nif (this.member){\n    member = '党员';\n}else {\n    member = '非党员'\n}\nvar result = name + ' ' + sex + ' ' + age + ' ' + member;\nthis.result = result;\n```\n同样是显示表单结果的函数。Vue不需要获取DOM元素，只需要获得和修改data对象中的数据就可以了。\n这里需要注意的是：要用jQuery获得或者修改一组radio很麻烦，需要操作checked属性；而Vue处理radio只需通过数据，数据内容就是radio的value值，修改value值radio就会自动选择目标项。checkbox也是如此，jQuery要使用checked，而Vue只需要知道checkbox绑定的data为true或者false就可以知道checkbox是否被选中。\n## 9. Vue使用watch方法测试\nVue的watch方法真的挺好用，当程序出现问题时可以将出问题的data使用watch打log，每当该数据发生变化时，watch方法都会被触发。很好用~\n```\nwatch: {\n    'sex': function (val, oldVal) {\n        console.log('oldVal = ' + oldVal + ' val = ' + val);\n    }\n}\n```\n# 总结心得\njQuery完全是通过美元符号来对各种元素进行操作！根据HTML元素的id、name等属性来获取到元素并对其进行取值、赋值、修改属性能行为。\nVue的使用过程 是：先绘制HTML界面，然后在需要绑定数据的地方写下v-model、v-on等这些绑定属性和方法，在显示数据内容的地方使用双大括号显示内容。然后在Vue中，el属性绑定根视图的id，data属性定义并初始化v-model、双大括号用到的数据和一些其他数据。methods属性定义在v-on中用到的和一些其他方法。更新界面修改数据实现。而修改数据通过操作界面实现。\n写完了这个demo后，感觉到Vue的确有它的魅力所在。它的MVVM让业务逻辑变得更加清晰和简单。\n\n# 所有代码\n## jQueryPage\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <script src=\"jquery-2.2.3.js\"></script>\n</head>\n<body>\n    <div>\n        <h2>学生信息登记</h2>\n        <br>\n        <div>\n            <label>姓名：</label>\n            <input type=\"text\" placeholder=\"请输入姓名\" id=\"name\">\n        </div>\n        <div>\n            <label>性别：</label>\n            <input id=\"sex01\" type=\"radio\" value=\"1\" name=\"sex\">\n            <label for=\"sex01\">男</label>\n            <input id=\"sex02\" type=\"radio\" value=\"2\" name=\"sex\">\n            <label for=\"sex02\">女</label>\n        </div>\n        <div>\n            <label>年龄：</label>\n            <select id=\"age\">\n                <option selected>18</option>\n                <option>19</option>\n                <option>20</option>\n                <option>21</option>\n            </select>\n        </div>\n        <div>\n            <label>党员：</label>\n            <input type=\"checkbox\" id=\"member\">\n        </div>\n        <br>\n        <button id=\"btnCommit\" onclick=\"commit()\">提交</button>\n        <button id=\"btnReset\" onclick=\"reset()\">重置</button>\n        <br>\n        <br>\n        <label id=\"result\"></label>\n    </div>\n    <script type=\"text/javascript\">\n        $(document).ready(function () {\n            alert(\"加载完成\");\n        });\n        function commit() {\n            var name = $('#name').val(); \n            var sex = '';\n            if (getChackedValue('input[name=sex]') == 1){\n                sex = '男'\n            }else if (getChackedValue('input[name=sex]') == 2){\n                sex = '女'\n            }\n            var age = $('#age').val();\n            var member = '';\n            if($('#member').is(':checked')) {\n                member = '党员';\n            }else {\n                member = \"非党员\";\n            }\n            var result = name + ' ' + sex + ' ' + age + ' ' + member;\n            $('#result').text(result);\n        }\n        function reset() {\n            $('#result').text('');\n        }\n        function getChackedValue (CheckboxId) {\n            var value = 0;\n            var i = 0;\n            $(CheckboxId).each(function () {\n                if($(CheckboxId).eq(i).is(':checked'))                {\n                    value = $(CheckboxId).eq(i).val(); \n                   return;\n                }\n                i++;\n            });\n            return value;\n        }\n    </script>\n</body>\n</html>\n```\n## VuePage\n```\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\"><head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <script src=\"vue.js\"></script>\n</head>\n<body>\n    <div id=\"app\">\n        <h2>学生信息登记</h2>\n        <br>\n        <div>\n            <label>姓名：</label>\n            <input type=\"text\" placeholder=\"请输入姓名\" v-model=\"name\">\n        </div>\n        <div>\n            <label>性别：</label>\n            <input id=\"sex01\" type=\"radio\" value=\"1\" v-model=\"sex\">\n            <label for=\"sex01\">男</label>\n            <input id=\"sex02\" type=\"radio\" value=\"2\" v-model=\"sex\">\n            <label for=\"sex02\">女</label>\n        </div>\n        <div>\n            <label>年龄：</label>\n            <select v-model=\"age\">\n                <option selected>18</option>\n                <option>19</option>\n                <option>20</option>\n                <option>21</option>\n            </select>\n        </div>\n        <div>\n            <label>党员：</label>\n            <input type=\"checkbox\" v-model=\"member\">\n        </div>\n        <br>\n        <button id=\"btnCommit\" v-on:click=\"commit\">提交</button>\n        <button id=\"btnReset\" v-on:click=\"reset\">重置</button>\n        <br>\n        <br>\n        <label>{{ result }}</label>\n    </div>\n    <script>\n        new Vue({\n            el: '#app',\n            data: {\n                name: '',\n                sex: '',\n                age: '',\n                member: '',\n                result: ''\n            }, \n            ready: function () {\n                alert(\"加载完成\");\n            },\n            methods: {\n                commit: function () {\n                    var name = this.name;\n                    var sex = '';\n                    if (this.sex == 1){\n                        sex = '男';\n                    }else if (this.sex == 2){\n                        sex = '女';\n                    }\n                    var age = this.age;\n                    var member = '';\n                    if (this.member){\n                        member = '党员';\n                    } else {\n                        member = '非党员';\n                    }\n                    var result = name + ' ' + sex + ' ' + age + ' ' + member;\n                    this.result = result;\n                },\n                reset: function () {\n                    this.result = '';\n                }\n            },\n            watch: {\n                'sex': function (val, oldVal) {\n                    console.log('oldVal = ' + oldVal + ' val = ' + val);\n                }\n            }\n        });\n    </script>\n</body>\n</html>\n```","source":"_posts/将表单从jQuery转Vue框架实践总结.md","raw":"---\ntitle: 将表单从jQuery转Vue框架实践总结\ndate: 2016-05-19\n---\n\n> 工作需要，将公司项目从jQuery转成Vue来写。这里分享下转变项目的过程并写了一个小demo，希望能对遇到同样问题的朋友一些帮助。\nPS： 本人Android开发，兼职前端，前端知识浅薄，有什么不对的地方还请指出，大家共同进步。谢谢~\n由于代码较多，我把源码放在了博客最后了。\n\n# jQuery和Vue的区别\njQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：`$(\"lable\").val();`,它还是依赖DOM元素的值。\nVue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。\n\n# jQuery to Vue\n## 1. 导入Vue.js，去除jQuery。\n下载Vue.js，导入工程,我将其放在头文件中。\n```\n<script src=\"vue.js\"></script>\n```\n[Vue.js下载地址](http://cn.vuejs.org/guide/installation.html)\n## 2. 根视图id绑定\n为最外层的div标签定义id，然后使用Vue的el属性进行绑定\n```\n<div id=\"app\">\n        <h2>学生信息登记</h2>\n        ...\n        <label>{{ result }}</label>    \n</div>\n...\n<script>\n    new Vue({\n        el: '#app',\n        ...\n    });\n</script>\n...\n```\n\n\n## 3. 为input添加v-model\n使用v-model属性将input标签的value值绑定到data的相应数据中。\n```\n<div>\n    <label>姓名：</label>\n    <input type=\"text\" placeholder=\"请输入姓名\" v-model=\"name\">\n</div>\n<div>\n    <label>性别：</label>\n    <input id=\"sex01\" type=\"radio\" value=\"1\" v-model=\"sex\">\n    <label for=\"sex01\">男</label>\n    <input id=\"sex02\" type=\"radio\" value=\"2\" v-model=\"sex\">\n    <label for=\"sex02\">女</label>\n</div>\n<div>\n    <label>年龄：</label>\n    <select v-model=\"age\">\n        <option selected>18</option>\n        <option>19</option>\n        <option>20</option>\n        <option>21</option>\n    </select></div><div>\n    <label>党员：</label>\n    <input type=\"checkbox\" v-model=\"member\">\n</div>\n```\n注意上方的v-model，我们在Vue对象的data属性中绑定数据：\n```\nnew Vue({\n    el: '#app',\n    data: {\n        name: '',\n        sex: '',\n        age: '',\n        member: '',\n        result: ''\n    },\n    ...\n})\n```\n到这里就实现了将表单input框和数据的绑定。更多Vue表单绑定可以查看[表单控件绑定](http://cn.vuejs.org/guide/forms.html)\n## 4. 删除id、name这些用于jQuery的属性\n在使用jQuery时，在HTML中需要定义大量的id、name之类的属性用于jQuery选择器获取元素。\n```\n<input type=\"text\" placeholder=\"请输入姓名\" id=\"name\">\n...\nvar name = $('#name').val();\n```\n我们这里就不需要了。去除HTML中的这些属性。\n（其实这里v-model和id的作用有些类似，都是一个桥梁作用。我在修改的时候偷懒直接将id改成v-model，后面的name不改~）\n## 5. 将点击事件onclick改为v-on:click\nVue提供了v-on来监听DOM事件，如demo中的点击事件监听属性v-on:click。\n```\n<button id=\"btnCommit\" v-on:click=\"commit\">提交</button>\n<button id=\"btnReset\" v-on:click=\"reset\">重置</button>\n```\n然后在Vue对象的methods属性中创建这两个事件方法。\n```\nnew Vue ({\n    ...\n    methods: {\n        commit: function () {...},\n        reset: function () {...},\n    ...\n...\n```\n另外，Vue还提供了其他v-on:属性，如v-on:change、v-on:keyup等。具体请看：[方法与事件处理](http://cn.vuejs.org/guide/events.html)\n\n## 6. 引用数据\n作为MVVM，当然是双向绑定的。Vue用v-model属性使input可以修改数据内容，实现界面修改数据；使用双大括号来引用数据内容，实现数据修改界面。\n具体写法如下：\n```\n<label>{{ result }}</label>\n...\ndata: {\n    result: 'hello world',\n    ...\n}\n```\n如上引用后，数据`hello world`将会实时同步显示在labal标签上，每当result数据有所改变，label的内容立即会改变。\n## 7. 替换ready方法\njQuery中为我们提供了一个document的ready方法，Vue中有ready属性，它们的触发时间差不多，具体要参考各自的生命周期。\n**jQuery写法：**\n```\n$(document).ready(function () {\n    alert(\"加载完成\");\n});\n```\n**Vue写法：**\n```\nnew Vue ({\n    ...\n    ready: function () {\n        alert(\"加载完成\");\n    },\n    ...\n})\n```\n## 8.修改获取和修改元素属性的方式\n这是jQuery和Vue的最大不同点了。先看代码:\n**jQuery:**\n```\nvar name = $('#name').val();\nvar sex = '';\nif (getChackedValue('input[name=sex]') == 1){\n    sex = '男'\n}else if (getChackedValue('input[name=sex]') == 2){\n    sex = '女'\n}\nvar age = $('#age').val();\nvar member = '';\nif($('#member').is(':checked')) {\n    member = '党员';\n}else {\n    member = \"非党员\";\n}\nvar result = name + ' ' + sex + ' ' + age + ' ' + member;\n$('#result').text(result);\n```\n这是显示表单结果的函数。jQuery是通过美元符号$来获取指定元素，然后通过val()、text()等方法获取指定元素的内容或者为指定元素赋值。\n**Vue：**\n```\nvar name = this.name;\nvar sex = '';\nif (this.sex == 1){\n    sex = '男';\n}else if (this.sex == 2){\n    sex = '女';\n}\nvar age = this.age;\nvar member = '';\nif (this.member){\n    member = '党员';\n}else {\n    member = '非党员'\n}\nvar result = name + ' ' + sex + ' ' + age + ' ' + member;\nthis.result = result;\n```\n同样是显示表单结果的函数。Vue不需要获取DOM元素，只需要获得和修改data对象中的数据就可以了。\n这里需要注意的是：要用jQuery获得或者修改一组radio很麻烦，需要操作checked属性；而Vue处理radio只需通过数据，数据内容就是radio的value值，修改value值radio就会自动选择目标项。checkbox也是如此，jQuery要使用checked，而Vue只需要知道checkbox绑定的data为true或者false就可以知道checkbox是否被选中。\n## 9. Vue使用watch方法测试\nVue的watch方法真的挺好用，当程序出现问题时可以将出问题的data使用watch打log，每当该数据发生变化时，watch方法都会被触发。很好用~\n```\nwatch: {\n    'sex': function (val, oldVal) {\n        console.log('oldVal = ' + oldVal + ' val = ' + val);\n    }\n}\n```\n# 总结心得\njQuery完全是通过美元符号来对各种元素进行操作！根据HTML元素的id、name等属性来获取到元素并对其进行取值、赋值、修改属性能行为。\nVue的使用过程 是：先绘制HTML界面，然后在需要绑定数据的地方写下v-model、v-on等这些绑定属性和方法，在显示数据内容的地方使用双大括号显示内容。然后在Vue中，el属性绑定根视图的id，data属性定义并初始化v-model、双大括号用到的数据和一些其他数据。methods属性定义在v-on中用到的和一些其他方法。更新界面修改数据实现。而修改数据通过操作界面实现。\n写完了这个demo后，感觉到Vue的确有它的魅力所在。它的MVVM让业务逻辑变得更加清晰和简单。\n\n# 所有代码\n## jQueryPage\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <script src=\"jquery-2.2.3.js\"></script>\n</head>\n<body>\n    <div>\n        <h2>学生信息登记</h2>\n        <br>\n        <div>\n            <label>姓名：</label>\n            <input type=\"text\" placeholder=\"请输入姓名\" id=\"name\">\n        </div>\n        <div>\n            <label>性别：</label>\n            <input id=\"sex01\" type=\"radio\" value=\"1\" name=\"sex\">\n            <label for=\"sex01\">男</label>\n            <input id=\"sex02\" type=\"radio\" value=\"2\" name=\"sex\">\n            <label for=\"sex02\">女</label>\n        </div>\n        <div>\n            <label>年龄：</label>\n            <select id=\"age\">\n                <option selected>18</option>\n                <option>19</option>\n                <option>20</option>\n                <option>21</option>\n            </select>\n        </div>\n        <div>\n            <label>党员：</label>\n            <input type=\"checkbox\" id=\"member\">\n        </div>\n        <br>\n        <button id=\"btnCommit\" onclick=\"commit()\">提交</button>\n        <button id=\"btnReset\" onclick=\"reset()\">重置</button>\n        <br>\n        <br>\n        <label id=\"result\"></label>\n    </div>\n    <script type=\"text/javascript\">\n        $(document).ready(function () {\n            alert(\"加载完成\");\n        });\n        function commit() {\n            var name = $('#name').val(); \n            var sex = '';\n            if (getChackedValue('input[name=sex]') == 1){\n                sex = '男'\n            }else if (getChackedValue('input[name=sex]') == 2){\n                sex = '女'\n            }\n            var age = $('#age').val();\n            var member = '';\n            if($('#member').is(':checked')) {\n                member = '党员';\n            }else {\n                member = \"非党员\";\n            }\n            var result = name + ' ' + sex + ' ' + age + ' ' + member;\n            $('#result').text(result);\n        }\n        function reset() {\n            $('#result').text('');\n        }\n        function getChackedValue (CheckboxId) {\n            var value = 0;\n            var i = 0;\n            $(CheckboxId).each(function () {\n                if($(CheckboxId).eq(i).is(':checked'))                {\n                    value = $(CheckboxId).eq(i).val(); \n                   return;\n                }\n                i++;\n            });\n            return value;\n        }\n    </script>\n</body>\n</html>\n```\n## VuePage\n```\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:v-on=\"http://www.w3.org/1999/xhtml\"><head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <script src=\"vue.js\"></script>\n</head>\n<body>\n    <div id=\"app\">\n        <h2>学生信息登记</h2>\n        <br>\n        <div>\n            <label>姓名：</label>\n            <input type=\"text\" placeholder=\"请输入姓名\" v-model=\"name\">\n        </div>\n        <div>\n            <label>性别：</label>\n            <input id=\"sex01\" type=\"radio\" value=\"1\" v-model=\"sex\">\n            <label for=\"sex01\">男</label>\n            <input id=\"sex02\" type=\"radio\" value=\"2\" v-model=\"sex\">\n            <label for=\"sex02\">女</label>\n        </div>\n        <div>\n            <label>年龄：</label>\n            <select v-model=\"age\">\n                <option selected>18</option>\n                <option>19</option>\n                <option>20</option>\n                <option>21</option>\n            </select>\n        </div>\n        <div>\n            <label>党员：</label>\n            <input type=\"checkbox\" v-model=\"member\">\n        </div>\n        <br>\n        <button id=\"btnCommit\" v-on:click=\"commit\">提交</button>\n        <button id=\"btnReset\" v-on:click=\"reset\">重置</button>\n        <br>\n        <br>\n        <label>{{ result }}</label>\n    </div>\n    <script>\n        new Vue({\n            el: '#app',\n            data: {\n                name: '',\n                sex: '',\n                age: '',\n                member: '',\n                result: ''\n            }, \n            ready: function () {\n                alert(\"加载完成\");\n            },\n            methods: {\n                commit: function () {\n                    var name = this.name;\n                    var sex = '';\n                    if (this.sex == 1){\n                        sex = '男';\n                    }else if (this.sex == 2){\n                        sex = '女';\n                    }\n                    var age = this.age;\n                    var member = '';\n                    if (this.member){\n                        member = '党员';\n                    } else {\n                        member = '非党员';\n                    }\n                    var result = name + ' ' + sex + ' ' + age + ' ' + member;\n                    this.result = result;\n                },\n                reset: function () {\n                    this.result = '';\n                }\n            },\n            watch: {\n                'sex': function (val, oldVal) {\n                    console.log('oldVal = ' + oldVal + ' val = ' + val);\n                }\n            }\n        });\n    </script>\n</body>\n</html>\n```","slug":"将表单从jQuery转Vue框架实践总结","published":1,"updated":"2018-02-07T02:31:40.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjddwxbmq000gi8btkrpilmd2","content":"<blockquote>\n<p>工作需要，将公司项目从jQuery转成Vue来写。这里分享下转变项目的过程并写了一个小demo，希望能对遇到同样问题的朋友一些帮助。<br>PS： 本人Android开发，兼职前端，前端知识浅薄，有什么不对的地方还请指出，大家共同进步。谢谢~<br>由于代码较多，我把源码放在了博客最后了。</p>\n</blockquote>\n<h1 id=\"jQuery和Vue的区别\"><a href=\"#jQuery和Vue的区别\" class=\"headerlink\" title=\"jQuery和Vue的区别\"></a>jQuery和Vue的区别</h1><p>jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：<code>$(&quot;lable&quot;).val();</code>,它还是依赖DOM元素的值。<br>Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。</p>\n<h1 id=\"jQuery-to-Vue\"><a href=\"#jQuery-to-Vue\" class=\"headerlink\" title=\"jQuery to Vue\"></a>jQuery to Vue</h1><h2 id=\"1-导入Vue-js，去除jQuery。\"><a href=\"#1-导入Vue-js，去除jQuery。\" class=\"headerlink\" title=\"1. 导入Vue.js，去除jQuery。\"></a>1. 导入Vue.js，去除jQuery。</h2><p>下载Vue.js，导入工程,我将其放在头文件中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://cn.vuejs.org/guide/installation.html\" target=\"_blank\" rel=\"noopener\">Vue.js下载地址</a></p>\n<h2 id=\"2-根视图id绑定\"><a href=\"#2-根视图id绑定\" class=\"headerlink\" title=\"2. 根视图id绑定\"></a>2. 根视图id绑定</h2><p>为最外层的div标签定义id，然后使用Vue的el属性进行绑定<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;h2&gt;学生信息登记&lt;/h2&gt;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        &lt;label&gt;&#123;&#123; result &#125;&#125;&lt;/label&gt;    </span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: &apos;#app&apos;,</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-为input添加v-model\"><a href=\"#3-为input添加v-model\" class=\"headerlink\" title=\"3. 为input添加v-model\"></a>3. 为input添加v-model</h2><p>使用v-model属性将input标签的value值绑定到data的相应数据中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &lt;label&gt;姓名：&lt;/label&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; placeholder=&quot;请输入姓名&quot; v-model=&quot;name&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &lt;label&gt;性别：&lt;/label&gt;</span><br><span class=\"line\">    &lt;input id=&quot;sex01&quot; type=&quot;radio&quot; value=&quot;1&quot; v-model=&quot;sex&quot;&gt;</span><br><span class=\"line\">    &lt;label for=&quot;sex01&quot;&gt;男&lt;/label&gt;</span><br><span class=\"line\">    &lt;input id=&quot;sex02&quot; type=&quot;radio&quot; value=&quot;2&quot; v-model=&quot;sex&quot;&gt;</span><br><span class=\"line\">    &lt;label for=&quot;sex02&quot;&gt;女&lt;/label&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &lt;label&gt;年龄：&lt;/label&gt;</span><br><span class=\"line\">    &lt;select v-model=&quot;age&quot;&gt;</span><br><span class=\"line\">        &lt;option selected&gt;18&lt;/option&gt;</span><br><span class=\"line\">        &lt;option&gt;19&lt;/option&gt;</span><br><span class=\"line\">        &lt;option&gt;20&lt;/option&gt;</span><br><span class=\"line\">        &lt;option&gt;21&lt;/option&gt;</span><br><span class=\"line\">    &lt;/select&gt;&lt;/div&gt;&lt;div&gt;</span><br><span class=\"line\">    &lt;label&gt;党员：&lt;/label&gt;</span><br><span class=\"line\">    &lt;input type=&quot;checkbox&quot; v-model=&quot;member&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>注意上方的v-model，我们在Vue对象的data属性中绑定数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: &apos;#app&apos;,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">        name: &apos;&apos;,</span><br><span class=\"line\">        sex: &apos;&apos;,</span><br><span class=\"line\">        age: &apos;&apos;,</span><br><span class=\"line\">        member: &apos;&apos;,</span><br><span class=\"line\">        result: &apos;&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>到这里就实现了将表单input框和数据的绑定。更多Vue表单绑定可以查看<a href=\"http://cn.vuejs.org/guide/forms.html\" target=\"_blank\" rel=\"noopener\">表单控件绑定</a></p>\n<h2 id=\"4-删除id、name这些用于jQuery的属性\"><a href=\"#4-删除id、name这些用于jQuery的属性\" class=\"headerlink\" title=\"4. 删除id、name这些用于jQuery的属性\"></a>4. 删除id、name这些用于jQuery的属性</h2><p>在使用jQuery时，在HTML中需要定义大量的id、name之类的属性用于jQuery选择器获取元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; placeholder=&quot;请输入姓名&quot; id=&quot;name&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">var name = $(&apos;#name&apos;).val();</span><br></pre></td></tr></table></figure></p>\n<p>我们这里就不需要了。去除HTML中的这些属性。<br>（其实这里v-model和id的作用有些类似，都是一个桥梁作用。我在修改的时候偷懒直接将id改成v-model，后面的name不改~）</p>\n<h2 id=\"5-将点击事件onclick改为v-on-click\"><a href=\"#5-将点击事件onclick改为v-on-click\" class=\"headerlink\" title=\"5. 将点击事件onclick改为v-on:click\"></a>5. 将点击事件onclick改为v-on:click</h2><p>Vue提供了v-on来监听DOM事件，如demo中的点击事件监听属性v-on:click。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button id=&quot;btnCommit&quot; v-on:click=&quot;commit&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"line\">&lt;button id=&quot;btnReset&quot; v-on:click=&quot;reset&quot;&gt;重置&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后在Vue对象的methods属性中创建这两个事件方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue (&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">        commit: function () &#123;...&#125;,</span><br><span class=\"line\">        reset: function () &#123;...&#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>另外，Vue还提供了其他v-on:属性，如v-on:change、v-on:keyup等。具体请看：<a href=\"http://cn.vuejs.org/guide/events.html\" target=\"_blank\" rel=\"noopener\">方法与事件处理</a></p>\n<h2 id=\"6-引用数据\"><a href=\"#6-引用数据\" class=\"headerlink\" title=\"6. 引用数据\"></a>6. 引用数据</h2><p>作为MVVM，当然是双向绑定的。Vue用v-model属性使input可以修改数据内容，实现界面修改数据；使用双大括号来引用数据内容，实现数据修改界面。<br>具体写法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;label&gt;&#123;&#123; result &#125;&#125;&lt;/label&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    result: &apos;hello world&apos;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如上引用后，数据<code>hello world</code>将会实时同步显示在labal标签上，每当result数据有所改变，label的内容立即会改变。</p>\n<h2 id=\"7-替换ready方法\"><a href=\"#7-替换ready方法\" class=\"headerlink\" title=\"7. 替换ready方法\"></a>7. 替换ready方法</h2><p>jQuery中为我们提供了一个document的ready方法，Vue中有ready属性，它们的触发时间差不多，具体要参考各自的生命周期。<br><strong>jQuery写法：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(document).ready(function () &#123;</span><br><span class=\"line\">    alert(&quot;加载完成&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><strong>Vue写法：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue (&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ready: function () &#123;</span><br><span class=\"line\">        alert(&quot;加载完成&quot;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"8-修改获取和修改元素属性的方式\"><a href=\"#8-修改获取和修改元素属性的方式\" class=\"headerlink\" title=\"8.修改获取和修改元素属性的方式\"></a>8.修改获取和修改元素属性的方式</h2><p>这是jQuery和Vue的最大不同点了。先看代码:<br><strong>jQuery:</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = $(&apos;#name&apos;).val();</span><br><span class=\"line\">var sex = &apos;&apos;;</span><br><span class=\"line\">if (getChackedValue(&apos;input[name=sex]&apos;) == 1)&#123;</span><br><span class=\"line\">    sex = &apos;男&apos;</span><br><span class=\"line\">&#125;else if (getChackedValue(&apos;input[name=sex]&apos;) == 2)&#123;</span><br><span class=\"line\">    sex = &apos;女&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var age = $(&apos;#age&apos;).val();</span><br><span class=\"line\">var member = &apos;&apos;;</span><br><span class=\"line\">if($(&apos;#member&apos;).is(&apos;:checked&apos;)) &#123;</span><br><span class=\"line\">    member = &apos;党员&apos;;</span><br><span class=\"line\">&#125;else &#123;</span><br><span class=\"line\">    member = &quot;非党员&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var result = name + &apos; &apos; + sex + &apos; &apos; + age + &apos; &apos; + member;</span><br><span class=\"line\">$(&apos;#result&apos;).text(result);</span><br></pre></td></tr></table></figure></p>\n<p>这是显示表单结果的函数。jQuery是通过美元符号$来获取指定元素，然后通过val()、text()等方法获取指定元素的内容或者为指定元素赋值。<br><strong>Vue：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = this.name;</span><br><span class=\"line\">var sex = &apos;&apos;;</span><br><span class=\"line\">if (this.sex == 1)&#123;</span><br><span class=\"line\">    sex = &apos;男&apos;;</span><br><span class=\"line\">&#125;else if (this.sex == 2)&#123;</span><br><span class=\"line\">    sex = &apos;女&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var age = this.age;</span><br><span class=\"line\">var member = &apos;&apos;;</span><br><span class=\"line\">if (this.member)&#123;</span><br><span class=\"line\">    member = &apos;党员&apos;;</span><br><span class=\"line\">&#125;else &#123;</span><br><span class=\"line\">    member = &apos;非党员&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var result = name + &apos; &apos; + sex + &apos; &apos; + age + &apos; &apos; + member;</span><br><span class=\"line\">this.result = result;</span><br></pre></td></tr></table></figure></p>\n<p>同样是显示表单结果的函数。Vue不需要获取DOM元素，只需要获得和修改data对象中的数据就可以了。<br>这里需要注意的是：要用jQuery获得或者修改一组radio很麻烦，需要操作checked属性；而Vue处理radio只需通过数据，数据内容就是radio的value值，修改value值radio就会自动选择目标项。checkbox也是如此，jQuery要使用checked，而Vue只需要知道checkbox绑定的data为true或者false就可以知道checkbox是否被选中。</p>\n<h2 id=\"9-Vue使用watch方法测试\"><a href=\"#9-Vue使用watch方法测试\" class=\"headerlink\" title=\"9. Vue使用watch方法测试\"></a>9. Vue使用watch方法测试</h2><p>Vue的watch方法真的挺好用，当程序出现问题时可以将出问题的data使用watch打log，每当该数据发生变化时，watch方法都会被触发。很好用~<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch: &#123;</span><br><span class=\"line\">    &apos;sex&apos;: function (val, oldVal) &#123;</span><br><span class=\"line\">        console.log(&apos;oldVal = &apos; + oldVal + &apos; val = &apos; + val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"总结心得\"><a href=\"#总结心得\" class=\"headerlink\" title=\"总结心得\"></a>总结心得</h1><p>jQuery完全是通过美元符号来对各种元素进行操作！根据HTML元素的id、name等属性来获取到元素并对其进行取值、赋值、修改属性能行为。<br>Vue的使用过程 是：先绘制HTML界面，然后在需要绑定数据的地方写下v-model、v-on等这些绑定属性和方法，在显示数据内容的地方使用双大括号显示内容。然后在Vue中，el属性绑定根视图的id，data属性定义并初始化v-model、双大括号用到的数据和一些其他数据。methods属性定义在v-on中用到的和一些其他方法。更新界面修改数据实现。而修改数据通过操作界面实现。<br>写完了这个demo后，感觉到Vue的确有它的魅力所在。它的MVVM让业务逻辑变得更加清晰和简单。</p>\n<h1 id=\"所有代码\"><a href=\"#所有代码\" class=\"headerlink\" title=\"所有代码\"></a>所有代码</h1><h2 id=\"jQueryPage\"><a href=\"#jQueryPage\" class=\"headerlink\" title=\"jQueryPage\"></a>jQueryPage</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;script src=&quot;jquery-2.2.3.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;h2&gt;学生信息登记&lt;/h2&gt;</span><br><span class=\"line\">        &lt;br&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;姓名：&lt;/label&gt;</span><br><span class=\"line\">            &lt;input type=&quot;text&quot; placeholder=&quot;请输入姓名&quot; id=&quot;name&quot;&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;性别：&lt;/label&gt;</span><br><span class=\"line\">            &lt;input id=&quot;sex01&quot; type=&quot;radio&quot; value=&quot;1&quot; name=&quot;sex&quot;&gt;</span><br><span class=\"line\">            &lt;label for=&quot;sex01&quot;&gt;男&lt;/label&gt;</span><br><span class=\"line\">            &lt;input id=&quot;sex02&quot; type=&quot;radio&quot; value=&quot;2&quot; name=&quot;sex&quot;&gt;</span><br><span class=\"line\">            &lt;label for=&quot;sex02&quot;&gt;女&lt;/label&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;年龄：&lt;/label&gt;</span><br><span class=\"line\">            &lt;select id=&quot;age&quot;&gt;</span><br><span class=\"line\">                &lt;option selected&gt;18&lt;/option&gt;</span><br><span class=\"line\">                &lt;option&gt;19&lt;/option&gt;</span><br><span class=\"line\">                &lt;option&gt;20&lt;/option&gt;</span><br><span class=\"line\">                &lt;option&gt;21&lt;/option&gt;</span><br><span class=\"line\">            &lt;/select&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;党员：&lt;/label&gt;</span><br><span class=\"line\">            &lt;input type=&quot;checkbox&quot; id=&quot;member&quot;&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;br&gt;</span><br><span class=\"line\">        &lt;button id=&quot;btnCommit&quot; onclick=&quot;commit()&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"line\">        &lt;button id=&quot;btnReset&quot; onclick=&quot;reset()&quot;&gt;重置&lt;/button&gt;</span><br><span class=\"line\">        &lt;br&gt;</span><br><span class=\"line\">        &lt;br&gt;</span><br><span class=\"line\">        &lt;label id=&quot;result&quot;&gt;&lt;/label&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">        $(document).ready(function () &#123;</span><br><span class=\"line\">            alert(&quot;加载完成&quot;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        function commit() &#123;</span><br><span class=\"line\">            var name = $(&apos;#name&apos;).val(); </span><br><span class=\"line\">            var sex = &apos;&apos;;</span><br><span class=\"line\">            if (getChackedValue(&apos;input[name=sex]&apos;) == 1)&#123;</span><br><span class=\"line\">                sex = &apos;男&apos;</span><br><span class=\"line\">            &#125;else if (getChackedValue(&apos;input[name=sex]&apos;) == 2)&#123;</span><br><span class=\"line\">                sex = &apos;女&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            var age = $(&apos;#age&apos;).val();</span><br><span class=\"line\">            var member = &apos;&apos;;</span><br><span class=\"line\">            if($(&apos;#member&apos;).is(&apos;:checked&apos;)) &#123;</span><br><span class=\"line\">                member = &apos;党员&apos;;</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                member = &quot;非党员&quot;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            var result = name + &apos; &apos; + sex + &apos; &apos; + age + &apos; &apos; + member;</span><br><span class=\"line\">            $(&apos;#result&apos;).text(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        function reset() &#123;</span><br><span class=\"line\">            $(&apos;#result&apos;).text(&apos;&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        function getChackedValue (CheckboxId) &#123;</span><br><span class=\"line\">            var value = 0;</span><br><span class=\"line\">            var i = 0;</span><br><span class=\"line\">            $(CheckboxId).each(function () &#123;</span><br><span class=\"line\">                if($(CheckboxId).eq(i).is(&apos;:checked&apos;))                &#123;</span><br><span class=\"line\">                    value = $(CheckboxId).eq(i).val(); </span><br><span class=\"line\">                   return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            return value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"VuePage\"><a href=\"#VuePage\" class=\"headerlink\" title=\"VuePage\"></a>VuePage</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;h2&gt;学生信息登记&lt;/h2&gt;</span><br><span class=\"line\">        &lt;br&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;姓名：&lt;/label&gt;</span><br><span class=\"line\">            &lt;input type=&quot;text&quot; placeholder=&quot;请输入姓名&quot; v-model=&quot;name&quot;&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;性别：&lt;/label&gt;</span><br><span class=\"line\">            &lt;input id=&quot;sex01&quot; type=&quot;radio&quot; value=&quot;1&quot; v-model=&quot;sex&quot;&gt;</span><br><span class=\"line\">            &lt;label for=&quot;sex01&quot;&gt;男&lt;/label&gt;</span><br><span class=\"line\">            &lt;input id=&quot;sex02&quot; type=&quot;radio&quot; value=&quot;2&quot; v-model=&quot;sex&quot;&gt;</span><br><span class=\"line\">            &lt;label for=&quot;sex02&quot;&gt;女&lt;/label&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;年龄：&lt;/label&gt;</span><br><span class=\"line\">            &lt;select v-model=&quot;age&quot;&gt;</span><br><span class=\"line\">                &lt;option selected&gt;18&lt;/option&gt;</span><br><span class=\"line\">                &lt;option&gt;19&lt;/option&gt;</span><br><span class=\"line\">                &lt;option&gt;20&lt;/option&gt;</span><br><span class=\"line\">                &lt;option&gt;21&lt;/option&gt;</span><br><span class=\"line\">            &lt;/select&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;党员：&lt;/label&gt;</span><br><span class=\"line\">            &lt;input type=&quot;checkbox&quot; v-model=&quot;member&quot;&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;br&gt;</span><br><span class=\"line\">        &lt;button id=&quot;btnCommit&quot; v-on:click=&quot;commit&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"line\">        &lt;button id=&quot;btnReset&quot; v-on:click=&quot;reset&quot;&gt;重置&lt;/button&gt;</span><br><span class=\"line\">        &lt;br&gt;</span><br><span class=\"line\">        &lt;br&gt;</span><br><span class=\"line\">        &lt;label&gt;&#123;&#123; result &#125;&#125;&lt;/label&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        new Vue(&#123;</span><br><span class=\"line\">            el: &apos;#app&apos;,</span><br><span class=\"line\">            data: &#123;</span><br><span class=\"line\">                name: &apos;&apos;,</span><br><span class=\"line\">                sex: &apos;&apos;,</span><br><span class=\"line\">                age: &apos;&apos;,</span><br><span class=\"line\">                member: &apos;&apos;,</span><br><span class=\"line\">                result: &apos;&apos;</span><br><span class=\"line\">            &#125;, </span><br><span class=\"line\">            ready: function () &#123;</span><br><span class=\"line\">                alert(&quot;加载完成&quot;);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            methods: &#123;</span><br><span class=\"line\">                commit: function () &#123;</span><br><span class=\"line\">                    var name = this.name;</span><br><span class=\"line\">                    var sex = &apos;&apos;;</span><br><span class=\"line\">                    if (this.sex == 1)&#123;</span><br><span class=\"line\">                        sex = &apos;男&apos;;</span><br><span class=\"line\">                    &#125;else if (this.sex == 2)&#123;</span><br><span class=\"line\">                        sex = &apos;女&apos;;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    var age = this.age;</span><br><span class=\"line\">                    var member = &apos;&apos;;</span><br><span class=\"line\">                    if (this.member)&#123;</span><br><span class=\"line\">                        member = &apos;党员&apos;;</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        member = &apos;非党员&apos;;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    var result = name + &apos; &apos; + sex + &apos; &apos; + age + &apos; &apos; + member;</span><br><span class=\"line\">                    this.result = result;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                reset: function () &#123;</span><br><span class=\"line\">                    this.result = &apos;&apos;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            watch: &#123;</span><br><span class=\"line\">                &apos;sex&apos;: function (val, oldVal) &#123;</span><br><span class=\"line\">                    console.log(&apos;oldVal = &apos; + oldVal + &apos; val = &apos; + val);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>工作需要，将公司项目从jQuery转成Vue来写。这里分享下转变项目的过程并写了一个小demo，希望能对遇到同样问题的朋友一些帮助。<br>PS： 本人Android开发，兼职前端，前端知识浅薄，有什么不对的地方还请指出，大家共同进步。谢谢~<br>由于代码较多，我把源码放在了博客最后了。</p>\n</blockquote>\n<h1 id=\"jQuery和Vue的区别\"><a href=\"#jQuery和Vue的区别\" class=\"headerlink\" title=\"jQuery和Vue的区别\"></a>jQuery和Vue的区别</h1><p>jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：<code>$(&quot;lable&quot;).val();</code>,它还是依赖DOM元素的值。<br>Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定。这就是传说中的MVVM。</p>\n<h1 id=\"jQuery-to-Vue\"><a href=\"#jQuery-to-Vue\" class=\"headerlink\" title=\"jQuery to Vue\"></a>jQuery to Vue</h1><h2 id=\"1-导入Vue-js，去除jQuery。\"><a href=\"#1-导入Vue-js，去除jQuery。\" class=\"headerlink\" title=\"1. 导入Vue.js，去除jQuery。\"></a>1. 导入Vue.js，去除jQuery。</h2><p>下载Vue.js，导入工程,我将其放在头文件中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://cn.vuejs.org/guide/installation.html\" target=\"_blank\" rel=\"noopener\">Vue.js下载地址</a></p>\n<h2 id=\"2-根视图id绑定\"><a href=\"#2-根视图id绑定\" class=\"headerlink\" title=\"2. 根视图id绑定\"></a>2. 根视图id绑定</h2><p>为最外层的div标签定义id，然后使用Vue的el属性进行绑定<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;h2&gt;学生信息登记&lt;/h2&gt;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        &lt;label&gt;&#123;&#123; result &#125;&#125;&lt;/label&gt;    </span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    new Vue(&#123;</span><br><span class=\"line\">        el: &apos;#app&apos;,</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-为input添加v-model\"><a href=\"#3-为input添加v-model\" class=\"headerlink\" title=\"3. 为input添加v-model\"></a>3. 为input添加v-model</h2><p>使用v-model属性将input标签的value值绑定到data的相应数据中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &lt;label&gt;姓名：&lt;/label&gt;</span><br><span class=\"line\">    &lt;input type=&quot;text&quot; placeholder=&quot;请输入姓名&quot; v-model=&quot;name&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &lt;label&gt;性别：&lt;/label&gt;</span><br><span class=\"line\">    &lt;input id=&quot;sex01&quot; type=&quot;radio&quot; value=&quot;1&quot; v-model=&quot;sex&quot;&gt;</span><br><span class=\"line\">    &lt;label for=&quot;sex01&quot;&gt;男&lt;/label&gt;</span><br><span class=\"line\">    &lt;input id=&quot;sex02&quot; type=&quot;radio&quot; value=&quot;2&quot; v-model=&quot;sex&quot;&gt;</span><br><span class=\"line\">    &lt;label for=&quot;sex02&quot;&gt;女&lt;/label&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &lt;label&gt;年龄：&lt;/label&gt;</span><br><span class=\"line\">    &lt;select v-model=&quot;age&quot;&gt;</span><br><span class=\"line\">        &lt;option selected&gt;18&lt;/option&gt;</span><br><span class=\"line\">        &lt;option&gt;19&lt;/option&gt;</span><br><span class=\"line\">        &lt;option&gt;20&lt;/option&gt;</span><br><span class=\"line\">        &lt;option&gt;21&lt;/option&gt;</span><br><span class=\"line\">    &lt;/select&gt;&lt;/div&gt;&lt;div&gt;</span><br><span class=\"line\">    &lt;label&gt;党员：&lt;/label&gt;</span><br><span class=\"line\">    &lt;input type=&quot;checkbox&quot; v-model=&quot;member&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>注意上方的v-model，我们在Vue对象的data属性中绑定数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: &apos;#app&apos;,</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">        name: &apos;&apos;,</span><br><span class=\"line\">        sex: &apos;&apos;,</span><br><span class=\"line\">        age: &apos;&apos;,</span><br><span class=\"line\">        member: &apos;&apos;,</span><br><span class=\"line\">        result: &apos;&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>到这里就实现了将表单input框和数据的绑定。更多Vue表单绑定可以查看<a href=\"http://cn.vuejs.org/guide/forms.html\" target=\"_blank\" rel=\"noopener\">表单控件绑定</a></p>\n<h2 id=\"4-删除id、name这些用于jQuery的属性\"><a href=\"#4-删除id、name这些用于jQuery的属性\" class=\"headerlink\" title=\"4. 删除id、name这些用于jQuery的属性\"></a>4. 删除id、name这些用于jQuery的属性</h2><p>在使用jQuery时，在HTML中需要定义大量的id、name之类的属性用于jQuery选择器获取元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; placeholder=&quot;请输入姓名&quot; id=&quot;name&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">var name = $(&apos;#name&apos;).val();</span><br></pre></td></tr></table></figure></p>\n<p>我们这里就不需要了。去除HTML中的这些属性。<br>（其实这里v-model和id的作用有些类似，都是一个桥梁作用。我在修改的时候偷懒直接将id改成v-model，后面的name不改~）</p>\n<h2 id=\"5-将点击事件onclick改为v-on-click\"><a href=\"#5-将点击事件onclick改为v-on-click\" class=\"headerlink\" title=\"5. 将点击事件onclick改为v-on:click\"></a>5. 将点击事件onclick改为v-on:click</h2><p>Vue提供了v-on来监听DOM事件，如demo中的点击事件监听属性v-on:click。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button id=&quot;btnCommit&quot; v-on:click=&quot;commit&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"line\">&lt;button id=&quot;btnReset&quot; v-on:click=&quot;reset&quot;&gt;重置&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后在Vue对象的methods属性中创建这两个事件方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue (&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">        commit: function () &#123;...&#125;,</span><br><span class=\"line\">        reset: function () &#123;...&#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>另外，Vue还提供了其他v-on:属性，如v-on:change、v-on:keyup等。具体请看：<a href=\"http://cn.vuejs.org/guide/events.html\" target=\"_blank\" rel=\"noopener\">方法与事件处理</a></p>\n<h2 id=\"6-引用数据\"><a href=\"#6-引用数据\" class=\"headerlink\" title=\"6. 引用数据\"></a>6. 引用数据</h2><p>作为MVVM，当然是双向绑定的。Vue用v-model属性使input可以修改数据内容，实现界面修改数据；使用双大括号来引用数据内容，实现数据修改界面。<br>具体写法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;label&gt;&#123;&#123; result &#125;&#125;&lt;/label&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    result: &apos;hello world&apos;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如上引用后，数据<code>hello world</code>将会实时同步显示在labal标签上，每当result数据有所改变，label的内容立即会改变。</p>\n<h2 id=\"7-替换ready方法\"><a href=\"#7-替换ready方法\" class=\"headerlink\" title=\"7. 替换ready方法\"></a>7. 替换ready方法</h2><p>jQuery中为我们提供了一个document的ready方法，Vue中有ready属性，它们的触发时间差不多，具体要参考各自的生命周期。<br><strong>jQuery写法：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(document).ready(function () &#123;</span><br><span class=\"line\">    alert(&quot;加载完成&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><strong>Vue写法：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue (&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ready: function () &#123;</span><br><span class=\"line\">        alert(&quot;加载完成&quot;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"8-修改获取和修改元素属性的方式\"><a href=\"#8-修改获取和修改元素属性的方式\" class=\"headerlink\" title=\"8.修改获取和修改元素属性的方式\"></a>8.修改获取和修改元素属性的方式</h2><p>这是jQuery和Vue的最大不同点了。先看代码:<br><strong>jQuery:</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = $(&apos;#name&apos;).val();</span><br><span class=\"line\">var sex = &apos;&apos;;</span><br><span class=\"line\">if (getChackedValue(&apos;input[name=sex]&apos;) == 1)&#123;</span><br><span class=\"line\">    sex = &apos;男&apos;</span><br><span class=\"line\">&#125;else if (getChackedValue(&apos;input[name=sex]&apos;) == 2)&#123;</span><br><span class=\"line\">    sex = &apos;女&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var age = $(&apos;#age&apos;).val();</span><br><span class=\"line\">var member = &apos;&apos;;</span><br><span class=\"line\">if($(&apos;#member&apos;).is(&apos;:checked&apos;)) &#123;</span><br><span class=\"line\">    member = &apos;党员&apos;;</span><br><span class=\"line\">&#125;else &#123;</span><br><span class=\"line\">    member = &quot;非党员&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var result = name + &apos; &apos; + sex + &apos; &apos; + age + &apos; &apos; + member;</span><br><span class=\"line\">$(&apos;#result&apos;).text(result);</span><br></pre></td></tr></table></figure></p>\n<p>这是显示表单结果的函数。jQuery是通过美元符号$来获取指定元素，然后通过val()、text()等方法获取指定元素的内容或者为指定元素赋值。<br><strong>Vue：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = this.name;</span><br><span class=\"line\">var sex = &apos;&apos;;</span><br><span class=\"line\">if (this.sex == 1)&#123;</span><br><span class=\"line\">    sex = &apos;男&apos;;</span><br><span class=\"line\">&#125;else if (this.sex == 2)&#123;</span><br><span class=\"line\">    sex = &apos;女&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var age = this.age;</span><br><span class=\"line\">var member = &apos;&apos;;</span><br><span class=\"line\">if (this.member)&#123;</span><br><span class=\"line\">    member = &apos;党员&apos;;</span><br><span class=\"line\">&#125;else &#123;</span><br><span class=\"line\">    member = &apos;非党员&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var result = name + &apos; &apos; + sex + &apos; &apos; + age + &apos; &apos; + member;</span><br><span class=\"line\">this.result = result;</span><br></pre></td></tr></table></figure></p>\n<p>同样是显示表单结果的函数。Vue不需要获取DOM元素，只需要获得和修改data对象中的数据就可以了。<br>这里需要注意的是：要用jQuery获得或者修改一组radio很麻烦，需要操作checked属性；而Vue处理radio只需通过数据，数据内容就是radio的value值，修改value值radio就会自动选择目标项。checkbox也是如此，jQuery要使用checked，而Vue只需要知道checkbox绑定的data为true或者false就可以知道checkbox是否被选中。</p>\n<h2 id=\"9-Vue使用watch方法测试\"><a href=\"#9-Vue使用watch方法测试\" class=\"headerlink\" title=\"9. Vue使用watch方法测试\"></a>9. Vue使用watch方法测试</h2><p>Vue的watch方法真的挺好用，当程序出现问题时可以将出问题的data使用watch打log，每当该数据发生变化时，watch方法都会被触发。很好用~<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch: &#123;</span><br><span class=\"line\">    &apos;sex&apos;: function (val, oldVal) &#123;</span><br><span class=\"line\">        console.log(&apos;oldVal = &apos; + oldVal + &apos; val = &apos; + val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"总结心得\"><a href=\"#总结心得\" class=\"headerlink\" title=\"总结心得\"></a>总结心得</h1><p>jQuery完全是通过美元符号来对各种元素进行操作！根据HTML元素的id、name等属性来获取到元素并对其进行取值、赋值、修改属性能行为。<br>Vue的使用过程 是：先绘制HTML界面，然后在需要绑定数据的地方写下v-model、v-on等这些绑定属性和方法，在显示数据内容的地方使用双大括号显示内容。然后在Vue中，el属性绑定根视图的id，data属性定义并初始化v-model、双大括号用到的数据和一些其他数据。methods属性定义在v-on中用到的和一些其他方法。更新界面修改数据实现。而修改数据通过操作界面实现。<br>写完了这个demo后，感觉到Vue的确有它的魅力所在。它的MVVM让业务逻辑变得更加清晰和简单。</p>\n<h1 id=\"所有代码\"><a href=\"#所有代码\" class=\"headerlink\" title=\"所有代码\"></a>所有代码</h1><h2 id=\"jQueryPage\"><a href=\"#jQueryPage\" class=\"headerlink\" title=\"jQueryPage\"></a>jQueryPage</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;script src=&quot;jquery-2.2.3.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;h2&gt;学生信息登记&lt;/h2&gt;</span><br><span class=\"line\">        &lt;br&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;姓名：&lt;/label&gt;</span><br><span class=\"line\">            &lt;input type=&quot;text&quot; placeholder=&quot;请输入姓名&quot; id=&quot;name&quot;&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;性别：&lt;/label&gt;</span><br><span class=\"line\">            &lt;input id=&quot;sex01&quot; type=&quot;radio&quot; value=&quot;1&quot; name=&quot;sex&quot;&gt;</span><br><span class=\"line\">            &lt;label for=&quot;sex01&quot;&gt;男&lt;/label&gt;</span><br><span class=\"line\">            &lt;input id=&quot;sex02&quot; type=&quot;radio&quot; value=&quot;2&quot; name=&quot;sex&quot;&gt;</span><br><span class=\"line\">            &lt;label for=&quot;sex02&quot;&gt;女&lt;/label&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;年龄：&lt;/label&gt;</span><br><span class=\"line\">            &lt;select id=&quot;age&quot;&gt;</span><br><span class=\"line\">                &lt;option selected&gt;18&lt;/option&gt;</span><br><span class=\"line\">                &lt;option&gt;19&lt;/option&gt;</span><br><span class=\"line\">                &lt;option&gt;20&lt;/option&gt;</span><br><span class=\"line\">                &lt;option&gt;21&lt;/option&gt;</span><br><span class=\"line\">            &lt;/select&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;党员：&lt;/label&gt;</span><br><span class=\"line\">            &lt;input type=&quot;checkbox&quot; id=&quot;member&quot;&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;br&gt;</span><br><span class=\"line\">        &lt;button id=&quot;btnCommit&quot; onclick=&quot;commit()&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"line\">        &lt;button id=&quot;btnReset&quot; onclick=&quot;reset()&quot;&gt;重置&lt;/button&gt;</span><br><span class=\"line\">        &lt;br&gt;</span><br><span class=\"line\">        &lt;br&gt;</span><br><span class=\"line\">        &lt;label id=&quot;result&quot;&gt;&lt;/label&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">        $(document).ready(function () &#123;</span><br><span class=\"line\">            alert(&quot;加载完成&quot;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        function commit() &#123;</span><br><span class=\"line\">            var name = $(&apos;#name&apos;).val(); </span><br><span class=\"line\">            var sex = &apos;&apos;;</span><br><span class=\"line\">            if (getChackedValue(&apos;input[name=sex]&apos;) == 1)&#123;</span><br><span class=\"line\">                sex = &apos;男&apos;</span><br><span class=\"line\">            &#125;else if (getChackedValue(&apos;input[name=sex]&apos;) == 2)&#123;</span><br><span class=\"line\">                sex = &apos;女&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            var age = $(&apos;#age&apos;).val();</span><br><span class=\"line\">            var member = &apos;&apos;;</span><br><span class=\"line\">            if($(&apos;#member&apos;).is(&apos;:checked&apos;)) &#123;</span><br><span class=\"line\">                member = &apos;党员&apos;;</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                member = &quot;非党员&quot;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            var result = name + &apos; &apos; + sex + &apos; &apos; + age + &apos; &apos; + member;</span><br><span class=\"line\">            $(&apos;#result&apos;).text(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        function reset() &#123;</span><br><span class=\"line\">            $(&apos;#result&apos;).text(&apos;&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        function getChackedValue (CheckboxId) &#123;</span><br><span class=\"line\">            var value = 0;</span><br><span class=\"line\">            var i = 0;</span><br><span class=\"line\">            $(CheckboxId).each(function () &#123;</span><br><span class=\"line\">                if($(CheckboxId).eq(i).is(&apos;:checked&apos;))                &#123;</span><br><span class=\"line\">                    value = $(CheckboxId).eq(i).val(); </span><br><span class=\"line\">                   return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            return value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"VuePage\"><a href=\"#VuePage\" class=\"headerlink\" title=\"VuePage\"></a>VuePage</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;h2&gt;学生信息登记&lt;/h2&gt;</span><br><span class=\"line\">        &lt;br&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;姓名：&lt;/label&gt;</span><br><span class=\"line\">            &lt;input type=&quot;text&quot; placeholder=&quot;请输入姓名&quot; v-model=&quot;name&quot;&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;性别：&lt;/label&gt;</span><br><span class=\"line\">            &lt;input id=&quot;sex01&quot; type=&quot;radio&quot; value=&quot;1&quot; v-model=&quot;sex&quot;&gt;</span><br><span class=\"line\">            &lt;label for=&quot;sex01&quot;&gt;男&lt;/label&gt;</span><br><span class=\"line\">            &lt;input id=&quot;sex02&quot; type=&quot;radio&quot; value=&quot;2&quot; v-model=&quot;sex&quot;&gt;</span><br><span class=\"line\">            &lt;label for=&quot;sex02&quot;&gt;女&lt;/label&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;年龄：&lt;/label&gt;</span><br><span class=\"line\">            &lt;select v-model=&quot;age&quot;&gt;</span><br><span class=\"line\">                &lt;option selected&gt;18&lt;/option&gt;</span><br><span class=\"line\">                &lt;option&gt;19&lt;/option&gt;</span><br><span class=\"line\">                &lt;option&gt;20&lt;/option&gt;</span><br><span class=\"line\">                &lt;option&gt;21&lt;/option&gt;</span><br><span class=\"line\">            &lt;/select&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;党员：&lt;/label&gt;</span><br><span class=\"line\">            &lt;input type=&quot;checkbox&quot; v-model=&quot;member&quot;&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;br&gt;</span><br><span class=\"line\">        &lt;button id=&quot;btnCommit&quot; v-on:click=&quot;commit&quot;&gt;提交&lt;/button&gt;</span><br><span class=\"line\">        &lt;button id=&quot;btnReset&quot; v-on:click=&quot;reset&quot;&gt;重置&lt;/button&gt;</span><br><span class=\"line\">        &lt;br&gt;</span><br><span class=\"line\">        &lt;br&gt;</span><br><span class=\"line\">        &lt;label&gt;&#123;&#123; result &#125;&#125;&lt;/label&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        new Vue(&#123;</span><br><span class=\"line\">            el: &apos;#app&apos;,</span><br><span class=\"line\">            data: &#123;</span><br><span class=\"line\">                name: &apos;&apos;,</span><br><span class=\"line\">                sex: &apos;&apos;,</span><br><span class=\"line\">                age: &apos;&apos;,</span><br><span class=\"line\">                member: &apos;&apos;,</span><br><span class=\"line\">                result: &apos;&apos;</span><br><span class=\"line\">            &#125;, </span><br><span class=\"line\">            ready: function () &#123;</span><br><span class=\"line\">                alert(&quot;加载完成&quot;);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            methods: &#123;</span><br><span class=\"line\">                commit: function () &#123;</span><br><span class=\"line\">                    var name = this.name;</span><br><span class=\"line\">                    var sex = &apos;&apos;;</span><br><span class=\"line\">                    if (this.sex == 1)&#123;</span><br><span class=\"line\">                        sex = &apos;男&apos;;</span><br><span class=\"line\">                    &#125;else if (this.sex == 2)&#123;</span><br><span class=\"line\">                        sex = &apos;女&apos;;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    var age = this.age;</span><br><span class=\"line\">                    var member = &apos;&apos;;</span><br><span class=\"line\">                    if (this.member)&#123;</span><br><span class=\"line\">                        member = &apos;党员&apos;;</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        member = &apos;非党员&apos;;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    var result = name + &apos; &apos; + sex + &apos; &apos; + age + &apos; &apos; + member;</span><br><span class=\"line\">                    this.result = result;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                reset: function () &#123;</span><br><span class=\"line\">                    this.result = &apos;&apos;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            watch: &#123;</span><br><span class=\"line\">                &apos;sex&apos;: function (val, oldVal) &#123;</span><br><span class=\"line\">                    console.log(&apos;oldVal = &apos; + oldVal + &apos; val = &apos; + val);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>"},{"title":"用hexo搭建博客笔记","data":"2018-02-06T16:00:00.000Z","_content":"\n> 一直想有个自己的 Github.io 博客，感觉逼格能够上升一大截。\n\n很久之前就看到网上各种博客搭建的文章，但是从内心中总感觉好像是个很麻烦的事情。所以，一直没有动手去做。\n\n昨天，趁着年前工作不忙，搭建了个博客，这里记录下过程。\n其实，搭建hexo博客是非常简单的事情。\n\n# 安装前提\nMac安装前提\n\n* Xcode\n* Node.js\n* Git\n\n这三个玩意儿对于我们开发者基本都是有的，没有装个就好。\n\n# 创建博客的过程\n简单的几条 bash 命令就好。\n```\n$ npm install -g hexo-cli\n$ hexo init [文件夹名]\n$ cd [文件夹名]\n$ npm install\n```\n以上步骤就已经安装完毕了。\n\n# 常用命令\n```\n// 新建文章 layout为模板，title为文章名\n$ hexo new [layout] <title>\n// 启动本地服务器看hexo博客，地址为 `http://localhost:4000/`\n$ hexo server\n// 生成静态文件\n$ hexo generate\n$ hexo g\n// 部署建站\n$ hexo deploy\n$ hexo d\n// 去除缓存文件\n$ hexo clean\n```\n这几个命令就能应付常用博客发布了。\n\n# 创建Github.io\n\n在我的Github中创建 [github名].github.io这个项目，比如像我的 [violetjack.github.io](https://github.com/violetjack/violetjack.github.io) 。\n\n# 上传博客配置\n\n如果是通过git开源发布的，那么只需要在hexo项目根目录的 `_config.yml` 文件中添加如下配置：\n```\ndeploy:\n  type: git\n  repo: [github.io 仓库]\n  branch: [发布的分支]\n  message: [发布消息]\n```\n\n# 主题\n\nhexo搭建的博客有很多的主题样式，可以在 [这里](https://hexo.io/themes/) 查看选择。安装过程里面都会说。\n\n比如我们安装 `Ada` 主题，首先用git克隆下仓库。这里，可以在hexo博客项目中去执行克隆行为，直接下载到hexo项目的themes目录下。\n```\ngit clone https://github.com/shuiRong/hexo-theme-Ada.git themes/Ada\n```\n有些主题需要安装依赖库，在hexo项目根目录中安装：\n```\nnpm install hexo-renderer-jade --save\n```\n最后，修改hexo项目根目录下 `_config.yml` 中的 theme 选项\n```\ntheme: Ada\n```\n这就完成了主题的修改。\n主题的配置工作呢，在 `./themes/Ada/_config.yml` 中，具体修改看相应的 Github README。\n其实如果有任何对主题不满意的地方可以直接去主题中修改，代码并不难，如果只是想改几个文本全局搜一下就能搜到了。\n\n# 添加关于页面\n样式中一般只有首页和文章两个标签可用，如果我们想添加其他标签，如 关于我，该怎么办呢？\n创建 关于我 页面（添加 layout 选项，默认为post）\n```\n$ hexo new page about\n```\n这样，项目中就多了 about 这个文件夹，修改其中的 md 文件即可编辑关于我页面。\n然后将主题的配置 `./themes/Ada/_config.yml` 中的页面链接指向 about 即可。\n```\n# Header\nmenu:\n  首页: /\n  文章: /archives\n  关于: /about\n```\n\n好啦，这里就简单介绍下Hexo的用法~主要是记录下搭建的过程。整理下步骤：\n* 搭建环境\n* 创建 Github.io，或者说GithubPage\n* 使用hexo搭建博客\n* 选择样式，添加页面、添加文章内容。\n* 发布\n\n就这么多啦~快去选择一个喜欢的样式做一个自己的博客，提升逼格把~\n**最后展示一下我的博客：**[Vue实验室](https://violetjack.github.io/)\n\n# 参考资料\n[hexo中文网](https://hexo.io/zh-cn/docs/)\n[github page](https://pages.github.com/)","source":"_posts/用hexo搭建博客笔记.md","raw":"---\ntitle: 用hexo搭建博客笔记\ndata: 2018-02-07\n---\n\n> 一直想有个自己的 Github.io 博客，感觉逼格能够上升一大截。\n\n很久之前就看到网上各种博客搭建的文章，但是从内心中总感觉好像是个很麻烦的事情。所以，一直没有动手去做。\n\n昨天，趁着年前工作不忙，搭建了个博客，这里记录下过程。\n其实，搭建hexo博客是非常简单的事情。\n\n# 安装前提\nMac安装前提\n\n* Xcode\n* Node.js\n* Git\n\n这三个玩意儿对于我们开发者基本都是有的，没有装个就好。\n\n# 创建博客的过程\n简单的几条 bash 命令就好。\n```\n$ npm install -g hexo-cli\n$ hexo init [文件夹名]\n$ cd [文件夹名]\n$ npm install\n```\n以上步骤就已经安装完毕了。\n\n# 常用命令\n```\n// 新建文章 layout为模板，title为文章名\n$ hexo new [layout] <title>\n// 启动本地服务器看hexo博客，地址为 `http://localhost:4000/`\n$ hexo server\n// 生成静态文件\n$ hexo generate\n$ hexo g\n// 部署建站\n$ hexo deploy\n$ hexo d\n// 去除缓存文件\n$ hexo clean\n```\n这几个命令就能应付常用博客发布了。\n\n# 创建Github.io\n\n在我的Github中创建 [github名].github.io这个项目，比如像我的 [violetjack.github.io](https://github.com/violetjack/violetjack.github.io) 。\n\n# 上传博客配置\n\n如果是通过git开源发布的，那么只需要在hexo项目根目录的 `_config.yml` 文件中添加如下配置：\n```\ndeploy:\n  type: git\n  repo: [github.io 仓库]\n  branch: [发布的分支]\n  message: [发布消息]\n```\n\n# 主题\n\nhexo搭建的博客有很多的主题样式，可以在 [这里](https://hexo.io/themes/) 查看选择。安装过程里面都会说。\n\n比如我们安装 `Ada` 主题，首先用git克隆下仓库。这里，可以在hexo博客项目中去执行克隆行为，直接下载到hexo项目的themes目录下。\n```\ngit clone https://github.com/shuiRong/hexo-theme-Ada.git themes/Ada\n```\n有些主题需要安装依赖库，在hexo项目根目录中安装：\n```\nnpm install hexo-renderer-jade --save\n```\n最后，修改hexo项目根目录下 `_config.yml` 中的 theme 选项\n```\ntheme: Ada\n```\n这就完成了主题的修改。\n主题的配置工作呢，在 `./themes/Ada/_config.yml` 中，具体修改看相应的 Github README。\n其实如果有任何对主题不满意的地方可以直接去主题中修改，代码并不难，如果只是想改几个文本全局搜一下就能搜到了。\n\n# 添加关于页面\n样式中一般只有首页和文章两个标签可用，如果我们想添加其他标签，如 关于我，该怎么办呢？\n创建 关于我 页面（添加 layout 选项，默认为post）\n```\n$ hexo new page about\n```\n这样，项目中就多了 about 这个文件夹，修改其中的 md 文件即可编辑关于我页面。\n然后将主题的配置 `./themes/Ada/_config.yml` 中的页面链接指向 about 即可。\n```\n# Header\nmenu:\n  首页: /\n  文章: /archives\n  关于: /about\n```\n\n好啦，这里就简单介绍下Hexo的用法~主要是记录下搭建的过程。整理下步骤：\n* 搭建环境\n* 创建 Github.io，或者说GithubPage\n* 使用hexo搭建博客\n* 选择样式，添加页面、添加文章内容。\n* 发布\n\n就这么多啦~快去选择一个喜欢的样式做一个自己的博客，提升逼格把~\n**最后展示一下我的博客：**[Vue实验室](https://violetjack.github.io/)\n\n# 参考资料\n[hexo中文网](https://hexo.io/zh-cn/docs/)\n[github page](https://pages.github.com/)","slug":"用hexo搭建博客笔记","published":1,"date":"2018-02-08T01:41:25.543Z","updated":"2018-02-08T01:41:58.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjddwxbmr000hi8btbvpe2c3v","content":"<blockquote>\n<p>一直想有个自己的 Github.io 博客，感觉逼格能够上升一大截。</p>\n</blockquote>\n<p>很久之前就看到网上各种博客搭建的文章，但是从内心中总感觉好像是个很麻烦的事情。所以，一直没有动手去做。</p>\n<p>昨天，趁着年前工作不忙，搭建了个博客，这里记录下过程。<br>其实，搭建hexo博客是非常简单的事情。</p>\n<h1 id=\"安装前提\"><a href=\"#安装前提\" class=\"headerlink\" title=\"安装前提\"></a>安装前提</h1><p>Mac安装前提</p>\n<ul>\n<li>Xcode</li>\n<li>Node.js</li>\n<li>Git</li>\n</ul>\n<p>这三个玩意儿对于我们开发者基本都是有的，没有装个就好。</p>\n<h1 id=\"创建博客的过程\"><a href=\"#创建博客的过程\" class=\"headerlink\" title=\"创建博客的过程\"></a>创建博客的过程</h1><p>简单的几条 bash 命令就好。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br><span class=\"line\">$ hexo init [文件夹名]</span><br><span class=\"line\">$ cd [文件夹名]</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure></p>\n<p>以上步骤就已经安装完毕了。</p>\n<h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 新建文章 layout为模板，title为文章名</span><br><span class=\"line\">$ hexo new [layout] &lt;title&gt;</span><br><span class=\"line\">// 启动本地服务器看hexo博客，地址为 `http://localhost:4000/`</span><br><span class=\"line\">$ hexo server</span><br><span class=\"line\">// 生成静态文件</span><br><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo g</span><br><span class=\"line\">// 部署建站</span><br><span class=\"line\">$ hexo deploy</span><br><span class=\"line\">$ hexo d</span><br><span class=\"line\">// 去除缓存文件</span><br><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n<p>这几个命令就能应付常用博客发布了。</p>\n<h1 id=\"创建Github-io\"><a href=\"#创建Github-io\" class=\"headerlink\" title=\"创建Github.io\"></a>创建Github.io</h1><p>在我的Github中创建 [github名].github.io这个项目，比如像我的 <a href=\"https://github.com/violetjack/violetjack.github.io\" target=\"_blank\" rel=\"noopener\">violetjack.github.io</a> 。</p>\n<h1 id=\"上传博客配置\"><a href=\"#上传博客配置\" class=\"headerlink\" title=\"上传博客配置\"></a>上传博客配置</h1><p>如果是通过git开源发布的，那么只需要在hexo项目根目录的 <code>_config.yml</code> 文件中添加如下配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: [github.io 仓库]</span><br><span class=\"line\">  branch: [发布的分支]</span><br><span class=\"line\">  message: [发布消息]</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h1><p>hexo搭建的博客有很多的主题样式，可以在 <a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">这里</a> 查看选择。安装过程里面都会说。</p>\n<p>比如我们安装 <code>Ada</code> 主题，首先用git克隆下仓库。这里，可以在hexo博客项目中去执行克隆行为，直接下载到hexo项目的themes目录下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/shuiRong/hexo-theme-Ada.git themes/Ada</span><br></pre></td></tr></table></figure></p>\n<p>有些主题需要安装依赖库，在hexo项目根目录中安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-jade --save</span><br></pre></td></tr></table></figure></p>\n<p>最后，修改hexo项目根目录下 <code>_config.yml</code> 中的 theme 选项<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme: Ada</span><br></pre></td></tr></table></figure></p>\n<p>这就完成了主题的修改。<br>主题的配置工作呢，在 <code>./themes/Ada/_config.yml</code> 中，具体修改看相应的 Github README。<br>其实如果有任何对主题不满意的地方可以直接去主题中修改，代码并不难，如果只是想改几个文本全局搜一下就能搜到了。</p>\n<h1 id=\"添加关于页面\"><a href=\"#添加关于页面\" class=\"headerlink\" title=\"添加关于页面\"></a>添加关于页面</h1><p>样式中一般只有首页和文章两个标签可用，如果我们想添加其他标签，如 关于我，该怎么办呢？<br>创建 关于我 页面（添加 layout 选项，默认为post）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page about</span><br></pre></td></tr></table></figure></p>\n<p>这样，项目中就多了 about 这个文件夹，修改其中的 md 文件即可编辑关于我页面。<br>然后将主题的配置 <code>./themes/Ada/_config.yml</code> 中的页面链接指向 about 即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Header</span><br><span class=\"line\">menu:</span><br><span class=\"line\">  首页: /</span><br><span class=\"line\">  文章: /archives</span><br><span class=\"line\">  关于: /about</span><br></pre></td></tr></table></figure></p>\n<p>好啦，这里就简单介绍下Hexo的用法~主要是记录下搭建的过程。整理下步骤：</p>\n<ul>\n<li>搭建环境</li>\n<li>创建 Github.io，或者说GithubPage</li>\n<li>使用hexo搭建博客</li>\n<li>选择样式，添加页面、添加文章内容。</li>\n<li>发布</li>\n</ul>\n<p>就这么多啦~快去选择一个喜欢的样式做一个自己的博客，提升逼格把~<br><strong>最后展示一下我的博客：</strong><a href=\"https://violetjack.github.io/\">Vue实验室</a></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">hexo中文网</a><br><a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener\">github page</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>一直想有个自己的 Github.io 博客，感觉逼格能够上升一大截。</p>\n</blockquote>\n<p>很久之前就看到网上各种博客搭建的文章，但是从内心中总感觉好像是个很麻烦的事情。所以，一直没有动手去做。</p>\n<p>昨天，趁着年前工作不忙，搭建了个博客，这里记录下过程。<br>其实，搭建hexo博客是非常简单的事情。</p>\n<h1 id=\"安装前提\"><a href=\"#安装前提\" class=\"headerlink\" title=\"安装前提\"></a>安装前提</h1><p>Mac安装前提</p>\n<ul>\n<li>Xcode</li>\n<li>Node.js</li>\n<li>Git</li>\n</ul>\n<p>这三个玩意儿对于我们开发者基本都是有的，没有装个就好。</p>\n<h1 id=\"创建博客的过程\"><a href=\"#创建博客的过程\" class=\"headerlink\" title=\"创建博客的过程\"></a>创建博客的过程</h1><p>简单的几条 bash 命令就好。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br><span class=\"line\">$ hexo init [文件夹名]</span><br><span class=\"line\">$ cd [文件夹名]</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure></p>\n<p>以上步骤就已经安装完毕了。</p>\n<h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 新建文章 layout为模板，title为文章名</span><br><span class=\"line\">$ hexo new [layout] &lt;title&gt;</span><br><span class=\"line\">// 启动本地服务器看hexo博客，地址为 `http://localhost:4000/`</span><br><span class=\"line\">$ hexo server</span><br><span class=\"line\">// 生成静态文件</span><br><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo g</span><br><span class=\"line\">// 部署建站</span><br><span class=\"line\">$ hexo deploy</span><br><span class=\"line\">$ hexo d</span><br><span class=\"line\">// 去除缓存文件</span><br><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n<p>这几个命令就能应付常用博客发布了。</p>\n<h1 id=\"创建Github-io\"><a href=\"#创建Github-io\" class=\"headerlink\" title=\"创建Github.io\"></a>创建Github.io</h1><p>在我的Github中创建 [github名].github.io这个项目，比如像我的 <a href=\"https://github.com/violetjack/violetjack.github.io\" target=\"_blank\" rel=\"noopener\">violetjack.github.io</a> 。</p>\n<h1 id=\"上传博客配置\"><a href=\"#上传博客配置\" class=\"headerlink\" title=\"上传博客配置\"></a>上传博客配置</h1><p>如果是通过git开源发布的，那么只需要在hexo项目根目录的 <code>_config.yml</code> 文件中添加如下配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: [github.io 仓库]</span><br><span class=\"line\">  branch: [发布的分支]</span><br><span class=\"line\">  message: [发布消息]</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"主题\"><a href=\"#主题\" class=\"headerlink\" title=\"主题\"></a>主题</h1><p>hexo搭建的博客有很多的主题样式，可以在 <a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">这里</a> 查看选择。安装过程里面都会说。</p>\n<p>比如我们安装 <code>Ada</code> 主题，首先用git克隆下仓库。这里，可以在hexo博客项目中去执行克隆行为，直接下载到hexo项目的themes目录下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/shuiRong/hexo-theme-Ada.git themes/Ada</span><br></pre></td></tr></table></figure></p>\n<p>有些主题需要安装依赖库，在hexo项目根目录中安装：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-jade --save</span><br></pre></td></tr></table></figure></p>\n<p>最后，修改hexo项目根目录下 <code>_config.yml</code> 中的 theme 选项<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme: Ada</span><br></pre></td></tr></table></figure></p>\n<p>这就完成了主题的修改。<br>主题的配置工作呢，在 <code>./themes/Ada/_config.yml</code> 中，具体修改看相应的 Github README。<br>其实如果有任何对主题不满意的地方可以直接去主题中修改，代码并不难，如果只是想改几个文本全局搜一下就能搜到了。</p>\n<h1 id=\"添加关于页面\"><a href=\"#添加关于页面\" class=\"headerlink\" title=\"添加关于页面\"></a>添加关于页面</h1><p>样式中一般只有首页和文章两个标签可用，如果我们想添加其他标签，如 关于我，该怎么办呢？<br>创建 关于我 页面（添加 layout 选项，默认为post）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page about</span><br></pre></td></tr></table></figure></p>\n<p>这样，项目中就多了 about 这个文件夹，修改其中的 md 文件即可编辑关于我页面。<br>然后将主题的配置 <code>./themes/Ada/_config.yml</code> 中的页面链接指向 about 即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Header</span><br><span class=\"line\">menu:</span><br><span class=\"line\">  首页: /</span><br><span class=\"line\">  文章: /archives</span><br><span class=\"line\">  关于: /about</span><br></pre></td></tr></table></figure></p>\n<p>好啦，这里就简单介绍下Hexo的用法~主要是记录下搭建的过程。整理下步骤：</p>\n<ul>\n<li>搭建环境</li>\n<li>创建 Github.io，或者说GithubPage</li>\n<li>使用hexo搭建博客</li>\n<li>选择样式，添加页面、添加文章内容。</li>\n<li>发布</li>\n</ul>\n<p>就这么多啦~快去选择一个喜欢的样式做一个自己的博客，提升逼格把~<br><strong>最后展示一下我的博客：</strong><a href=\"https://violetjack.github.io/\">Vue实验室</a></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://hexo.io/zh-cn/docs/\" target=\"_blank\" rel=\"noopener\">hexo中文网</a><br><a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener\">github page</a></p>\n"},{"title":"巧用jQuery选择器写表单办法总结（提高效率）","date":"2016-12-30T16:00:00.000Z","_content":"\n> 相信很多小伙伴都会遇到需要做表单的需求，就像我现在做的医院项目，茫茫多的表单无穷无尽。一开始做表单使用最笨的方法：一个个span去定义ID，每个数据都用ajax获取后赋值显示，然后在表单提交前一个个用jQuery根据ID获取元素的value，组成一个model来提交给服务器。\n后来发现使用jQuery可以大大简化这个过程。于是我修改了工作方法，总结了我的一些提高写表单效率的方法。\n\n## 需求\n表单中存在最多的无非就是文本、文本框、单选框、多选框。而一些表单中会有几十个甚至几百个选项。我们的目标就是以最高的效率来完成这些表单的数据获取和数据提交。\n**注意：如果元素ID和服务器上获取的json字段的名字是一样的，那么这篇文章或许能对你提高工作效率有所帮助。**\n\n## 文本和文本框\n对于文本和文本框，我们通常需要为元素添加ID来绑定和获取数据。\n\n### 将数据显示到界面中\n* 用for循环遍历解析成功的JSON数据\n* 通过if判断过滤数据是span的还是input的。\n* 将数据传给和数据名同名的ID元素。\n```\nfor (var key in json) {\n   //过滤type为text的文本框\n   if ($('#' + key).attr('type') == 'text') {\n       $('#' + key).val(json[key]);\n   }\n   if($('#' + key).prop('tagName') == 'SPAN'){\n       $('#' + key).text(json[key]);\n   }\n}\n```\n### 快速获取数据对象用于提交服务器\n* 定义空model对象。\n* 通过jQuery选择器获取目标元素的value。\n* 将数据传入model中，对象元素的字段就是HTML元素的ID。\n```\nvar model = {};\n$('input[type=\"text\"]').each(function () {\n   model[$(this).attr('id')]=$(this).val();\n});\n$('span').each(function () {\n   model[$(this).attr('id')]=$(this).text();\n});\nconsole.log(model);\n```\n按照如下方法，我们只需要照着后端提供的数据字段给HTML定义id，而JS就不需要写太多代码就可以完成表单了。再也不怕表单字段太多了。\n\n### 全部代码\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script src=\"jquery-2.2.3.js\"></script>\n</head>\n<body>\n    <div>\n        <div>\n            <label>姓名：<input type=\"text\" id=\"name\"></label>\n            <label>性别：<input type=\"text\" id=\"sex\"></label>\n            <label>年龄：<input type=\"text\" id=\"age\"></label>\n            <label>时间：<input type=\"text\" id=\"time\"></label>\n        </div>\n        <div>\n            <label>a：<span id=\"param01\">1</span></label>\n            <label>b：<span id=\"param02\">2</span></label>\n            <label>c：<span id=\"param03\">3</span></label>\n            <label>d：<span id=\"param04\">4</span></label>\n        </div>\n    </div>\n    <button onclick=\"showResult()\">显示结果</button>\n    <script>\n        //多条input或者span的快速赋值\n        //data是模拟服务器返回的JSON数据\n        var data = '{\"name\":\"张三\",\"sex\":\"女\",\"age\":22,\"time\":\"2016-5-10\",\"param01\":111,\"param02\":222,\"param03\":333,\"param04\":444}';\n        //将数据显示到页面中\n        var json = eval('(' + data + ')');\n        for (var key in json) {\n            if ($('#' + key).attr('type') == 'text') {\n                $('#' + key).val(json[key]);\n            }\n            if($('#' + key).prop('tagName') == 'SPAN'){\n                $('#' + key).text(json[key]);\n            }\n        }\n\n\t\t//获取文本和文本框的内容转为JSON对象\n        function showResult() {\n            var model = {};\n            $('input[type=\"text\"]').each(function () {\n                model[$(this).attr('id')]=$(this).val();\n            });\n            $('span').each(function () {\n                model[$(this).attr('id')]=$(this).text();\n            });\n            console.log(model);\n        }\n    </script>\n</body>\n</html>\n```\n\n## Radio和Checkbox\n\n另外一种经常出现于表单中的就是radio、checkbox这些单选多选的元素了。这些元素通常用name命名一组选项。下面我同样用jQuery简化数据的显示和提交。\n\n### 显示数据\n和之前的文本一样，用for循环遍历json数据，然后通过if过滤后显示到界面。不同之处是这边是通过name来显示和绑定数据的。\n**注：对radio和checkbox处理的方法写在了后面，所以复制粘贴的同学们请注意别漏了~**\n```\nfor(var key in json){\n   if ($('input[name=' + key +  ']').attr('type') == 'radio') {\n      showRadioValue(key, json[key]);\n   }\n   if ($('input[name=' + key +  ']').attr('type') == 'checkbox') {\n     showCheckBoxValue(key, json[key]);\n   }\n}\n```\n### 获取数据model的方法\n* 定义空model对象。\n* 定义name避免重复添加。\n* 遍历所有radio获取结果传给model\n* 遍历所有checkbox获取结果传给model\n\n```\n        function showResult() {\n            var model = {};\n            var radioName = '';\n            var checkboxName = '';\n            $(\"input[type='radio']\").each(function () {\n                if($(this).attr('name') != radioName){\n                    radioName = $(this).attr('name');\n                    model[radioName] = getRadioValue(radioName);\n                }\n            });\n            $(\"input[type='checkbox']\").each(function () {\n                if($(this).attr('name') != checkboxName){\n                    checkboxName = $(this).attr('name');\n                    model[checkboxName] = getCheckboxValue(checkboxName);\n                }\n            });\n            console.log(model);\n        }\n```\n### 处理radio和checkbox的一些方法\n这里我对radio和checkbox的显示和获取结果写了几个方法。\n```\n        function showRadioValue(name, value) {\n            $('input[name=' + name +  ']').each(function () {\n                if(value == $(this).val()){\n                    $(this).attr('checked', 'true');\n                }\n            });\n        }\n\n        function getRadioValue(name) {\n            var value = 0;\n            var i = 0;\n            $('input[name=' + name + ']' ).each(function () {\n                if ($('input[name=' + name + ']').eq(i).is( ':checked')) {\n                    value = $('input[name=' + name + ']').eq(i).val();\n                    return;\n                }\n                i++;\n            });\n            return value;\n        }\n\n        function showCheckBoxValue (name, value) {\n            var values = value.split(',' );\n            var row = 1;\n            $('input[name=\"' + name + '\"]').each( function () {\n                if (values[row] == 1) {\n                    $(this).attr(\"checked\" , 'true');\n                }\n                row++;\n            });\n        }\n\n        function getCheckboxValue (name) {\n            var text = \"\" ;\n            $('input[name=\"' + name + '\"]').each( function () {\n                var t = '' ;\n                if ($(this ).is(':checked')) {\n                    t = \"1\";\n                } else {\n                    t = \"0\";\n                }\n                text += \",\" + t;\n            });\n            return text;\n        }\n```\n\n### 代码\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script src=\"jquery-2.2.3.js\"></script>\n</head>\n<body>\n    <div>\n        <div>\n            <label><input type=\"radio\" name=\"param01\" value=\"1\">1</label>\n            <label><input type=\"radio\" name=\"param01\" value=\"2\">2</label>\n            <label><input type=\"radio\" name=\"param01\" value=\"3\">3</label>\n        </div>\n        <div>\n            <label><input type=\"radio\" name=\"param02\" value=\"1\">1</label>\n            <label><input type=\"radio\" name=\"param02\" value=\"2\">2</label>\n            <label><input type=\"radio\" name=\"param02\" value=\"3\">3</label>\n        </div>\n        <div>\n            <label><input type=\"radio\" name=\"param03\" value=\"1\">1</label>\n            <label><input type=\"radio\" name=\"param03\" value=\"2\">2</label>\n            <label><input type=\"radio\" name=\"param03\" value=\"3\">3</label>\n        </div>\n        <div>\n            <label><input type=\"checkbox\" name=\"param04\">1</label>\n            <label><input type=\"checkbox\" name=\"param04\">2</label>\n            <label><input type=\"checkbox\" name=\"param04\">3</label>\n            <label><input type=\"checkbox\" name=\"param04\">3</label>\n        </div>\n        <div>\n            <label><input type=\"checkbox\" name=\"param05\">1</label>\n            <label><input type=\"checkbox\" name=\"param05\">2</label>\n            <label><input type=\"checkbox\" name=\"param05\">3</label>\n            <label><input type=\"checkbox\" name=\"param05\">3</label>\n        </div>\n        <button onclick=\"showResult()\">显示结果</button>\n        <label id=\"result\">result</label>\n    </div>\n    <script>\n        //多条radio或者checkbox的快速赋值\n        var data = '{\"param01\":\"1\",\"param02\":\"3\",\"param03\":\"2\",\"param04\":\",1,0,0,0\",\"param05\":\",0,0,1,1\"}';\n        var json =eval( '(' + data + ')');\n        for(var key in json){\n            if ($('input[name=' + key +  ']').attr('type') == 'radio') {\n                showRadioValue(key, json[key]);\n            }\n            if ($('input[name=' + key +  ']').attr('type') == 'checkbox') {\n                showCheckBoxValue(key, json[key]);\n            }\n        }\n\n        function showRadioValue(name, value) {\n            $('input[name=' + name +  ']').each(function () {\n                if(value == $(this).val()){\n                    $(this).attr('checked', 'true');\n                }\n            });\n        }\n\n        function getRadioValue(name) {\n            var value = 0;\n            var i = 0;\n            $('input[name=' + name + ']' ).each(function () {\n                if ($('input[name=' + name + ']').eq(i).is( ':checked')) {\n                    value = $('input[name=' + name + ']').eq(i).val();\n                    return;\n                }\n                i++;\n            });\n            return value;\n        }\n\n        function showCheckBoxValue (name, value) {\n            var values = value.split(',' );\n            var row = 1;\n            $('input[name=\"' + name + '\"]').each( function () {\n                if (values[row] == 1) {\n                    $(this).attr(\"checked\" , 'true');\n                }\n                row++;\n            });\n        }\n\n        function getCheckboxValue (name) {\n            var text = \"\" ;\n            $('input[name=\"' + name + '\"]').each( function () {\n                var t = '' ;\n                if ($(this ).is(':checked')) {\n                    t = \"1\";\n                } else {\n                    t = \"0\";\n                }\n                text += \",\" + t;\n            });\n            return text;\n        }\n\n        function showResult() {\n            var model = {};\n            var radioName = '';\n            var checkboxName = '';\n            $(\"input[type='radio']\").each(function () {\n                if($(this).attr('name') != radioName){\n                    radioName = $(this).attr('name');\n                    model[radioName] = getRadioValue(radioName);\n                }\n            });\n            $(\"input[type='checkbox']\").each(function () {\n                if($(this).attr('name') != checkboxName){\n                    checkboxName = $(this).attr('name');\n                    model[checkboxName] = getCheckboxValue(checkboxName);\n                }\n            });\n            console.log(model);\n        }\n    </script>\n</body>\n</html>\n```\n## Tips\n* 如果有一些特殊处理的内容（如时间格式文本），可以先遍历后在遍历之后单独进行赋值。\n* 以上方法可以用于所有以ID定义的用于显示和获取数据的HTML元素。\n* 用好jQuery的选择器可以获取到任何所需的元素、元素集合。\n* 在each()方法中`$(this)`表示当前元素。\n* 获取所选ID的元素标签：`$('#' + key).prop('tagName') == 'SPAN'`，注意：标签结果`'SPAN'`都是大写的,可以打log验证。\n* 不断找规律、总结提炼，找出最好的偷懒方法，尽量避免体力劳动。\n\n","source":"_posts/巧用jQuery选择器写表单办法总结（提高效率）.md","raw":"---\ntitle: 巧用jQuery选择器写表单办法总结（提高效率）\ndate: 2016-12-31\n---\n\n> 相信很多小伙伴都会遇到需要做表单的需求，就像我现在做的医院项目，茫茫多的表单无穷无尽。一开始做表单使用最笨的方法：一个个span去定义ID，每个数据都用ajax获取后赋值显示，然后在表单提交前一个个用jQuery根据ID获取元素的value，组成一个model来提交给服务器。\n后来发现使用jQuery可以大大简化这个过程。于是我修改了工作方法，总结了我的一些提高写表单效率的方法。\n\n## 需求\n表单中存在最多的无非就是文本、文本框、单选框、多选框。而一些表单中会有几十个甚至几百个选项。我们的目标就是以最高的效率来完成这些表单的数据获取和数据提交。\n**注意：如果元素ID和服务器上获取的json字段的名字是一样的，那么这篇文章或许能对你提高工作效率有所帮助。**\n\n## 文本和文本框\n对于文本和文本框，我们通常需要为元素添加ID来绑定和获取数据。\n\n### 将数据显示到界面中\n* 用for循环遍历解析成功的JSON数据\n* 通过if判断过滤数据是span的还是input的。\n* 将数据传给和数据名同名的ID元素。\n```\nfor (var key in json) {\n   //过滤type为text的文本框\n   if ($('#' + key).attr('type') == 'text') {\n       $('#' + key).val(json[key]);\n   }\n   if($('#' + key).prop('tagName') == 'SPAN'){\n       $('#' + key).text(json[key]);\n   }\n}\n```\n### 快速获取数据对象用于提交服务器\n* 定义空model对象。\n* 通过jQuery选择器获取目标元素的value。\n* 将数据传入model中，对象元素的字段就是HTML元素的ID。\n```\nvar model = {};\n$('input[type=\"text\"]').each(function () {\n   model[$(this).attr('id')]=$(this).val();\n});\n$('span').each(function () {\n   model[$(this).attr('id')]=$(this).text();\n});\nconsole.log(model);\n```\n按照如下方法，我们只需要照着后端提供的数据字段给HTML定义id，而JS就不需要写太多代码就可以完成表单了。再也不怕表单字段太多了。\n\n### 全部代码\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script src=\"jquery-2.2.3.js\"></script>\n</head>\n<body>\n    <div>\n        <div>\n            <label>姓名：<input type=\"text\" id=\"name\"></label>\n            <label>性别：<input type=\"text\" id=\"sex\"></label>\n            <label>年龄：<input type=\"text\" id=\"age\"></label>\n            <label>时间：<input type=\"text\" id=\"time\"></label>\n        </div>\n        <div>\n            <label>a：<span id=\"param01\">1</span></label>\n            <label>b：<span id=\"param02\">2</span></label>\n            <label>c：<span id=\"param03\">3</span></label>\n            <label>d：<span id=\"param04\">4</span></label>\n        </div>\n    </div>\n    <button onclick=\"showResult()\">显示结果</button>\n    <script>\n        //多条input或者span的快速赋值\n        //data是模拟服务器返回的JSON数据\n        var data = '{\"name\":\"张三\",\"sex\":\"女\",\"age\":22,\"time\":\"2016-5-10\",\"param01\":111,\"param02\":222,\"param03\":333,\"param04\":444}';\n        //将数据显示到页面中\n        var json = eval('(' + data + ')');\n        for (var key in json) {\n            if ($('#' + key).attr('type') == 'text') {\n                $('#' + key).val(json[key]);\n            }\n            if($('#' + key).prop('tagName') == 'SPAN'){\n                $('#' + key).text(json[key]);\n            }\n        }\n\n\t\t//获取文本和文本框的内容转为JSON对象\n        function showResult() {\n            var model = {};\n            $('input[type=\"text\"]').each(function () {\n                model[$(this).attr('id')]=$(this).val();\n            });\n            $('span').each(function () {\n                model[$(this).attr('id')]=$(this).text();\n            });\n            console.log(model);\n        }\n    </script>\n</body>\n</html>\n```\n\n## Radio和Checkbox\n\n另外一种经常出现于表单中的就是radio、checkbox这些单选多选的元素了。这些元素通常用name命名一组选项。下面我同样用jQuery简化数据的显示和提交。\n\n### 显示数据\n和之前的文本一样，用for循环遍历json数据，然后通过if过滤后显示到界面。不同之处是这边是通过name来显示和绑定数据的。\n**注：对radio和checkbox处理的方法写在了后面，所以复制粘贴的同学们请注意别漏了~**\n```\nfor(var key in json){\n   if ($('input[name=' + key +  ']').attr('type') == 'radio') {\n      showRadioValue(key, json[key]);\n   }\n   if ($('input[name=' + key +  ']').attr('type') == 'checkbox') {\n     showCheckBoxValue(key, json[key]);\n   }\n}\n```\n### 获取数据model的方法\n* 定义空model对象。\n* 定义name避免重复添加。\n* 遍历所有radio获取结果传给model\n* 遍历所有checkbox获取结果传给model\n\n```\n        function showResult() {\n            var model = {};\n            var radioName = '';\n            var checkboxName = '';\n            $(\"input[type='radio']\").each(function () {\n                if($(this).attr('name') != radioName){\n                    radioName = $(this).attr('name');\n                    model[radioName] = getRadioValue(radioName);\n                }\n            });\n            $(\"input[type='checkbox']\").each(function () {\n                if($(this).attr('name') != checkboxName){\n                    checkboxName = $(this).attr('name');\n                    model[checkboxName] = getCheckboxValue(checkboxName);\n                }\n            });\n            console.log(model);\n        }\n```\n### 处理radio和checkbox的一些方法\n这里我对radio和checkbox的显示和获取结果写了几个方法。\n```\n        function showRadioValue(name, value) {\n            $('input[name=' + name +  ']').each(function () {\n                if(value == $(this).val()){\n                    $(this).attr('checked', 'true');\n                }\n            });\n        }\n\n        function getRadioValue(name) {\n            var value = 0;\n            var i = 0;\n            $('input[name=' + name + ']' ).each(function () {\n                if ($('input[name=' + name + ']').eq(i).is( ':checked')) {\n                    value = $('input[name=' + name + ']').eq(i).val();\n                    return;\n                }\n                i++;\n            });\n            return value;\n        }\n\n        function showCheckBoxValue (name, value) {\n            var values = value.split(',' );\n            var row = 1;\n            $('input[name=\"' + name + '\"]').each( function () {\n                if (values[row] == 1) {\n                    $(this).attr(\"checked\" , 'true');\n                }\n                row++;\n            });\n        }\n\n        function getCheckboxValue (name) {\n            var text = \"\" ;\n            $('input[name=\"' + name + '\"]').each( function () {\n                var t = '' ;\n                if ($(this ).is(':checked')) {\n                    t = \"1\";\n                } else {\n                    t = \"0\";\n                }\n                text += \",\" + t;\n            });\n            return text;\n        }\n```\n\n### 代码\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script src=\"jquery-2.2.3.js\"></script>\n</head>\n<body>\n    <div>\n        <div>\n            <label><input type=\"radio\" name=\"param01\" value=\"1\">1</label>\n            <label><input type=\"radio\" name=\"param01\" value=\"2\">2</label>\n            <label><input type=\"radio\" name=\"param01\" value=\"3\">3</label>\n        </div>\n        <div>\n            <label><input type=\"radio\" name=\"param02\" value=\"1\">1</label>\n            <label><input type=\"radio\" name=\"param02\" value=\"2\">2</label>\n            <label><input type=\"radio\" name=\"param02\" value=\"3\">3</label>\n        </div>\n        <div>\n            <label><input type=\"radio\" name=\"param03\" value=\"1\">1</label>\n            <label><input type=\"radio\" name=\"param03\" value=\"2\">2</label>\n            <label><input type=\"radio\" name=\"param03\" value=\"3\">3</label>\n        </div>\n        <div>\n            <label><input type=\"checkbox\" name=\"param04\">1</label>\n            <label><input type=\"checkbox\" name=\"param04\">2</label>\n            <label><input type=\"checkbox\" name=\"param04\">3</label>\n            <label><input type=\"checkbox\" name=\"param04\">3</label>\n        </div>\n        <div>\n            <label><input type=\"checkbox\" name=\"param05\">1</label>\n            <label><input type=\"checkbox\" name=\"param05\">2</label>\n            <label><input type=\"checkbox\" name=\"param05\">3</label>\n            <label><input type=\"checkbox\" name=\"param05\">3</label>\n        </div>\n        <button onclick=\"showResult()\">显示结果</button>\n        <label id=\"result\">result</label>\n    </div>\n    <script>\n        //多条radio或者checkbox的快速赋值\n        var data = '{\"param01\":\"1\",\"param02\":\"3\",\"param03\":\"2\",\"param04\":\",1,0,0,0\",\"param05\":\",0,0,1,1\"}';\n        var json =eval( '(' + data + ')');\n        for(var key in json){\n            if ($('input[name=' + key +  ']').attr('type') == 'radio') {\n                showRadioValue(key, json[key]);\n            }\n            if ($('input[name=' + key +  ']').attr('type') == 'checkbox') {\n                showCheckBoxValue(key, json[key]);\n            }\n        }\n\n        function showRadioValue(name, value) {\n            $('input[name=' + name +  ']').each(function () {\n                if(value == $(this).val()){\n                    $(this).attr('checked', 'true');\n                }\n            });\n        }\n\n        function getRadioValue(name) {\n            var value = 0;\n            var i = 0;\n            $('input[name=' + name + ']' ).each(function () {\n                if ($('input[name=' + name + ']').eq(i).is( ':checked')) {\n                    value = $('input[name=' + name + ']').eq(i).val();\n                    return;\n                }\n                i++;\n            });\n            return value;\n        }\n\n        function showCheckBoxValue (name, value) {\n            var values = value.split(',' );\n            var row = 1;\n            $('input[name=\"' + name + '\"]').each( function () {\n                if (values[row] == 1) {\n                    $(this).attr(\"checked\" , 'true');\n                }\n                row++;\n            });\n        }\n\n        function getCheckboxValue (name) {\n            var text = \"\" ;\n            $('input[name=\"' + name + '\"]').each( function () {\n                var t = '' ;\n                if ($(this ).is(':checked')) {\n                    t = \"1\";\n                } else {\n                    t = \"0\";\n                }\n                text += \",\" + t;\n            });\n            return text;\n        }\n\n        function showResult() {\n            var model = {};\n            var radioName = '';\n            var checkboxName = '';\n            $(\"input[type='radio']\").each(function () {\n                if($(this).attr('name') != radioName){\n                    radioName = $(this).attr('name');\n                    model[radioName] = getRadioValue(radioName);\n                }\n            });\n            $(\"input[type='checkbox']\").each(function () {\n                if($(this).attr('name') != checkboxName){\n                    checkboxName = $(this).attr('name');\n                    model[checkboxName] = getCheckboxValue(checkboxName);\n                }\n            });\n            console.log(model);\n        }\n    </script>\n</body>\n</html>\n```\n## Tips\n* 如果有一些特殊处理的内容（如时间格式文本），可以先遍历后在遍历之后单独进行赋值。\n* 以上方法可以用于所有以ID定义的用于显示和获取数据的HTML元素。\n* 用好jQuery的选择器可以获取到任何所需的元素、元素集合。\n* 在each()方法中`$(this)`表示当前元素。\n* 获取所选ID的元素标签：`$('#' + key).prop('tagName') == 'SPAN'`，注意：标签结果`'SPAN'`都是大写的,可以打log验证。\n* 不断找规律、总结提炼，找出最好的偷懒方法，尽量避免体力劳动。\n\n","slug":"巧用jQuery选择器写表单办法总结（提高效率）","published":1,"updated":"2018-02-07T02:30:51.901Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjddwxbms000ii8btf0k12zv2","content":"<blockquote>\n<p>相信很多小伙伴都会遇到需要做表单的需求，就像我现在做的医院项目，茫茫多的表单无穷无尽。一开始做表单使用最笨的方法：一个个span去定义ID，每个数据都用ajax获取后赋值显示，然后在表单提交前一个个用jQuery根据ID获取元素的value，组成一个model来提交给服务器。<br>后来发现使用jQuery可以大大简化这个过程。于是我修改了工作方法，总结了我的一些提高写表单效率的方法。</p>\n</blockquote>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>表单中存在最多的无非就是文本、文本框、单选框、多选框。而一些表单中会有几十个甚至几百个选项。我们的目标就是以最高的效率来完成这些表单的数据获取和数据提交。<br><strong>注意：如果元素ID和服务器上获取的json字段的名字是一样的，那么这篇文章或许能对你提高工作效率有所帮助。</strong></p>\n<h2 id=\"文本和文本框\"><a href=\"#文本和文本框\" class=\"headerlink\" title=\"文本和文本框\"></a>文本和文本框</h2><p>对于文本和文本框，我们通常需要为元素添加ID来绑定和获取数据。</p>\n<h3 id=\"将数据显示到界面中\"><a href=\"#将数据显示到界面中\" class=\"headerlink\" title=\"将数据显示到界面中\"></a>将数据显示到界面中</h3><ul>\n<li>用for循环遍历解析成功的JSON数据</li>\n<li>通过if判断过滤数据是span的还是input的。</li>\n<li>将数据传给和数据名同名的ID元素。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (var key in json) &#123;</span><br><span class=\"line\">   //过滤type为text的文本框</span><br><span class=\"line\">   if ($(&apos;#&apos; + key).attr(&apos;type&apos;) == &apos;text&apos;) &#123;</span><br><span class=\"line\">       $(&apos;#&apos; + key).val(json[key]);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   if($(&apos;#&apos; + key).prop(&apos;tagName&apos;) == &apos;SPAN&apos;)&#123;</span><br><span class=\"line\">       $(&apos;#&apos; + key).text(json[key]);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"快速获取数据对象用于提交服务器\"><a href=\"#快速获取数据对象用于提交服务器\" class=\"headerlink\" title=\"快速获取数据对象用于提交服务器\"></a>快速获取数据对象用于提交服务器</h3><ul>\n<li>定义空model对象。</li>\n<li>通过jQuery选择器获取目标元素的value。</li>\n<li>将数据传入model中，对象元素的字段就是HTML元素的ID。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var model = &#123;&#125;;</span><br><span class=\"line\">$(&apos;input[type=&quot;text&quot;]&apos;).each(function () &#123;</span><br><span class=\"line\">   model[$(this).attr(&apos;id&apos;)]=$(this).val();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">$(&apos;span&apos;).each(function () &#123;</span><br><span class=\"line\">   model[$(this).attr(&apos;id&apos;)]=$(this).text();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(model);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>按照如下方法，我们只需要照着后端提供的数据字段给HTML定义id，而JS就不需要写太多代码就可以完成表单了。再也不怕表单字段太多了。</p>\n<h3 id=\"全部代码\"><a href=\"#全部代码\" class=\"headerlink\" title=\"全部代码\"></a>全部代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">    &lt;script src=&quot;jquery-2.2.3.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;姓名：&lt;input type=&quot;text&quot; id=&quot;name&quot;&gt;&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;性别：&lt;input type=&quot;text&quot; id=&quot;sex&quot;&gt;&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;年龄：&lt;input type=&quot;text&quot; id=&quot;age&quot;&gt;&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;时间：&lt;input type=&quot;text&quot; id=&quot;time&quot;&gt;&lt;/label&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;a：&lt;span id=&quot;param01&quot;&gt;1&lt;/span&gt;&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;b：&lt;span id=&quot;param02&quot;&gt;2&lt;/span&gt;&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;c：&lt;span id=&quot;param03&quot;&gt;3&lt;/span&gt;&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;d：&lt;span id=&quot;param04&quot;&gt;4&lt;/span&gt;&lt;/label&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;button onclick=&quot;showResult()&quot;&gt;显示结果&lt;/button&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        //多条input或者span的快速赋值</span><br><span class=\"line\">        //data是模拟服务器返回的JSON数据</span><br><span class=\"line\">        var data = &apos;&#123;&quot;name&quot;:&quot;张三&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:22,&quot;time&quot;:&quot;2016-5-10&quot;,&quot;param01&quot;:111,&quot;param02&quot;:222,&quot;param03&quot;:333,&quot;param04&quot;:444&#125;&apos;;</span><br><span class=\"line\">        //将数据显示到页面中</span><br><span class=\"line\">        var json = eval(&apos;(&apos; + data + &apos;)&apos;);</span><br><span class=\"line\">        for (var key in json) &#123;</span><br><span class=\"line\">            if ($(&apos;#&apos; + key).attr(&apos;type&apos;) == &apos;text&apos;) &#123;</span><br><span class=\"line\">                $(&apos;#&apos; + key).val(json[key]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if($(&apos;#&apos; + key).prop(&apos;tagName&apos;) == &apos;SPAN&apos;)&#123;</span><br><span class=\"line\">                $(&apos;#&apos; + key).text(json[key]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//获取文本和文本框的内容转为JSON对象</span><br><span class=\"line\">        function showResult() &#123;</span><br><span class=\"line\">            var model = &#123;&#125;;</span><br><span class=\"line\">            $(&apos;input[type=&quot;text&quot;]&apos;).each(function () &#123;</span><br><span class=\"line\">                model[$(this).attr(&apos;id&apos;)]=$(this).val();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            $(&apos;span&apos;).each(function () &#123;</span><br><span class=\"line\">                model[$(this).attr(&apos;id&apos;)]=$(this).text();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            console.log(model);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Radio和Checkbox\"><a href=\"#Radio和Checkbox\" class=\"headerlink\" title=\"Radio和Checkbox\"></a>Radio和Checkbox</h2><p>另外一种经常出现于表单中的就是radio、checkbox这些单选多选的元素了。这些元素通常用name命名一组选项。下面我同样用jQuery简化数据的显示和提交。</p>\n<h3 id=\"显示数据\"><a href=\"#显示数据\" class=\"headerlink\" title=\"显示数据\"></a>显示数据</h3><p>和之前的文本一样，用for循环遍历json数据，然后通过if过滤后显示到界面。不同之处是这边是通过name来显示和绑定数据的。<br><strong>注：对radio和checkbox处理的方法写在了后面，所以复制粘贴的同学们请注意别漏了~</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var key in json)&#123;</span><br><span class=\"line\">   if ($(&apos;input[name=&apos; + key +  &apos;]&apos;).attr(&apos;type&apos;) == &apos;radio&apos;) &#123;</span><br><span class=\"line\">      showRadioValue(key, json[key]);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   if ($(&apos;input[name=&apos; + key +  &apos;]&apos;).attr(&apos;type&apos;) == &apos;checkbox&apos;) &#123;</span><br><span class=\"line\">     showCheckBoxValue(key, json[key]);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"获取数据model的方法\"><a href=\"#获取数据model的方法\" class=\"headerlink\" title=\"获取数据model的方法\"></a>获取数据model的方法</h3><ul>\n<li>定义空model对象。</li>\n<li>定义name避免重复添加。</li>\n<li>遍历所有radio获取结果传给model</li>\n<li>遍历所有checkbox获取结果传给model</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function showResult() &#123;</span><br><span class=\"line\">    var model = &#123;&#125;;</span><br><span class=\"line\">    var radioName = &apos;&apos;;</span><br><span class=\"line\">    var checkboxName = &apos;&apos;;</span><br><span class=\"line\">    $(&quot;input[type=&apos;radio&apos;]&quot;).each(function () &#123;</span><br><span class=\"line\">        if($(this).attr(&apos;name&apos;) != radioName)&#123;</span><br><span class=\"line\">            radioName = $(this).attr(&apos;name&apos;);</span><br><span class=\"line\">            model[radioName] = getRadioValue(radioName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    $(&quot;input[type=&apos;checkbox&apos;]&quot;).each(function () &#123;</span><br><span class=\"line\">        if($(this).attr(&apos;name&apos;) != checkboxName)&#123;</span><br><span class=\"line\">            checkboxName = $(this).attr(&apos;name&apos;);</span><br><span class=\"line\">            model[checkboxName] = getCheckboxValue(checkboxName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    console.log(model);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"处理radio和checkbox的一些方法\"><a href=\"#处理radio和checkbox的一些方法\" class=\"headerlink\" title=\"处理radio和checkbox的一些方法\"></a>处理radio和checkbox的一些方法</h3><p>这里我对radio和checkbox的显示和获取结果写了几个方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function showRadioValue(name, value) &#123;</span><br><span class=\"line\">    $(&apos;input[name=&apos; + name +  &apos;]&apos;).each(function () &#123;</span><br><span class=\"line\">        if(value == $(this).val())&#123;</span><br><span class=\"line\">            $(this).attr(&apos;checked&apos;, &apos;true&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getRadioValue(name) &#123;</span><br><span class=\"line\">    var value = 0;</span><br><span class=\"line\">    var i = 0;</span><br><span class=\"line\">    $(&apos;input[name=&apos; + name + &apos;]&apos; ).each(function () &#123;</span><br><span class=\"line\">        if ($(&apos;input[name=&apos; + name + &apos;]&apos;).eq(i).is( &apos;:checked&apos;)) &#123;</span><br><span class=\"line\">            value = $(&apos;input[name=&apos; + name + &apos;]&apos;).eq(i).val();</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function showCheckBoxValue (name, value) &#123;</span><br><span class=\"line\">    var values = value.split(&apos;,&apos; );</span><br><span class=\"line\">    var row = 1;</span><br><span class=\"line\">    $(&apos;input[name=&quot;&apos; + name + &apos;&quot;]&apos;).each( function () &#123;</span><br><span class=\"line\">        if (values[row] == 1) &#123;</span><br><span class=\"line\">            $(this).attr(&quot;checked&quot; , &apos;true&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        row++;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getCheckboxValue (name) &#123;</span><br><span class=\"line\">    var text = &quot;&quot; ;</span><br><span class=\"line\">    $(&apos;input[name=&quot;&apos; + name + &apos;&quot;]&apos;).each( function () &#123;</span><br><span class=\"line\">        var t = &apos;&apos; ;</span><br><span class=\"line\">        if ($(this ).is(&apos;:checked&apos;)) &#123;</span><br><span class=\"line\">            t = &quot;1&quot;;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            t = &quot;0&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        text += &quot;,&quot; + t;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">    &lt;script src=&quot;jquery-2.2.3.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;param01&quot; value=&quot;1&quot;&gt;1&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;param01&quot; value=&quot;2&quot;&gt;2&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;param01&quot; value=&quot;3&quot;&gt;3&lt;/label&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;param02&quot; value=&quot;1&quot;&gt;1&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;param02&quot; value=&quot;2&quot;&gt;2&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;param02&quot; value=&quot;3&quot;&gt;3&lt;/label&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;param03&quot; value=&quot;1&quot;&gt;1&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;param03&quot; value=&quot;2&quot;&gt;2&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;param03&quot; value=&quot;3&quot;&gt;3&lt;/label&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;param04&quot;&gt;1&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;param04&quot;&gt;2&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;param04&quot;&gt;3&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;param04&quot;&gt;3&lt;/label&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;param05&quot;&gt;1&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;param05&quot;&gt;2&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;param05&quot;&gt;3&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;param05&quot;&gt;3&lt;/label&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;button onclick=&quot;showResult()&quot;&gt;显示结果&lt;/button&gt;</span><br><span class=\"line\">        &lt;label id=&quot;result&quot;&gt;result&lt;/label&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        //多条radio或者checkbox的快速赋值</span><br><span class=\"line\">        var data = &apos;&#123;&quot;param01&quot;:&quot;1&quot;,&quot;param02&quot;:&quot;3&quot;,&quot;param03&quot;:&quot;2&quot;,&quot;param04&quot;:&quot;,1,0,0,0&quot;,&quot;param05&quot;:&quot;,0,0,1,1&quot;&#125;&apos;;</span><br><span class=\"line\">        var json =eval( &apos;(&apos; + data + &apos;)&apos;);</span><br><span class=\"line\">        for(var key in json)&#123;</span><br><span class=\"line\">            if ($(&apos;input[name=&apos; + key +  &apos;]&apos;).attr(&apos;type&apos;) == &apos;radio&apos;) &#123;</span><br><span class=\"line\">                showRadioValue(key, json[key]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if ($(&apos;input[name=&apos; + key +  &apos;]&apos;).attr(&apos;type&apos;) == &apos;checkbox&apos;) &#123;</span><br><span class=\"line\">                showCheckBoxValue(key, json[key]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        function showRadioValue(name, value) &#123;</span><br><span class=\"line\">            $(&apos;input[name=&apos; + name +  &apos;]&apos;).each(function () &#123;</span><br><span class=\"line\">                if(value == $(this).val())&#123;</span><br><span class=\"line\">                    $(this).attr(&apos;checked&apos;, &apos;true&apos;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        function getRadioValue(name) &#123;</span><br><span class=\"line\">            var value = 0;</span><br><span class=\"line\">            var i = 0;</span><br><span class=\"line\">            $(&apos;input[name=&apos; + name + &apos;]&apos; ).each(function () &#123;</span><br><span class=\"line\">                if ($(&apos;input[name=&apos; + name + &apos;]&apos;).eq(i).is( &apos;:checked&apos;)) &#123;</span><br><span class=\"line\">                    value = $(&apos;input[name=&apos; + name + &apos;]&apos;).eq(i).val();</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            return value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        function showCheckBoxValue (name, value) &#123;</span><br><span class=\"line\">            var values = value.split(&apos;,&apos; );</span><br><span class=\"line\">            var row = 1;</span><br><span class=\"line\">            $(&apos;input[name=&quot;&apos; + name + &apos;&quot;]&apos;).each( function () &#123;</span><br><span class=\"line\">                if (values[row] == 1) &#123;</span><br><span class=\"line\">                    $(this).attr(&quot;checked&quot; , &apos;true&apos;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                row++;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        function getCheckboxValue (name) &#123;</span><br><span class=\"line\">            var text = &quot;&quot; ;</span><br><span class=\"line\">            $(&apos;input[name=&quot;&apos; + name + &apos;&quot;]&apos;).each( function () &#123;</span><br><span class=\"line\">                var t = &apos;&apos; ;</span><br><span class=\"line\">                if ($(this ).is(&apos;:checked&apos;)) &#123;</span><br><span class=\"line\">                    t = &quot;1&quot;;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    t = &quot;0&quot;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                text += &quot;,&quot; + t;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            return text;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        function showResult() &#123;</span><br><span class=\"line\">            var model = &#123;&#125;;</span><br><span class=\"line\">            var radioName = &apos;&apos;;</span><br><span class=\"line\">            var checkboxName = &apos;&apos;;</span><br><span class=\"line\">            $(&quot;input[type=&apos;radio&apos;]&quot;).each(function () &#123;</span><br><span class=\"line\">                if($(this).attr(&apos;name&apos;) != radioName)&#123;</span><br><span class=\"line\">                    radioName = $(this).attr(&apos;name&apos;);</span><br><span class=\"line\">                    model[radioName] = getRadioValue(radioName);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            $(&quot;input[type=&apos;checkbox&apos;]&quot;).each(function () &#123;</span><br><span class=\"line\">                if($(this).attr(&apos;name&apos;) != checkboxName)&#123;</span><br><span class=\"line\">                    checkboxName = $(this).attr(&apos;name&apos;);</span><br><span class=\"line\">                    model[checkboxName] = getCheckboxValue(checkboxName);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            console.log(model);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h2><ul>\n<li>如果有一些特殊处理的内容（如时间格式文本），可以先遍历后在遍历之后单独进行赋值。</li>\n<li>以上方法可以用于所有以ID定义的用于显示和获取数据的HTML元素。</li>\n<li>用好jQuery的选择器可以获取到任何所需的元素、元素集合。</li>\n<li>在each()方法中<code>$(this)</code>表示当前元素。</li>\n<li>获取所选ID的元素标签：<code>$(&#39;#&#39; + key).prop(&#39;tagName&#39;) == &#39;SPAN&#39;</code>，注意：标签结果<code>&#39;SPAN&#39;</code>都是大写的,可以打log验证。</li>\n<li>不断找规律、总结提炼，找出最好的偷懒方法，尽量避免体力劳动。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>相信很多小伙伴都会遇到需要做表单的需求，就像我现在做的医院项目，茫茫多的表单无穷无尽。一开始做表单使用最笨的方法：一个个span去定义ID，每个数据都用ajax获取后赋值显示，然后在表单提交前一个个用jQuery根据ID获取元素的value，组成一个model来提交给服务器。<br>后来发现使用jQuery可以大大简化这个过程。于是我修改了工作方法，总结了我的一些提高写表单效率的方法。</p>\n</blockquote>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>表单中存在最多的无非就是文本、文本框、单选框、多选框。而一些表单中会有几十个甚至几百个选项。我们的目标就是以最高的效率来完成这些表单的数据获取和数据提交。<br><strong>注意：如果元素ID和服务器上获取的json字段的名字是一样的，那么这篇文章或许能对你提高工作效率有所帮助。</strong></p>\n<h2 id=\"文本和文本框\"><a href=\"#文本和文本框\" class=\"headerlink\" title=\"文本和文本框\"></a>文本和文本框</h2><p>对于文本和文本框，我们通常需要为元素添加ID来绑定和获取数据。</p>\n<h3 id=\"将数据显示到界面中\"><a href=\"#将数据显示到界面中\" class=\"headerlink\" title=\"将数据显示到界面中\"></a>将数据显示到界面中</h3><ul>\n<li>用for循环遍历解析成功的JSON数据</li>\n<li>通过if判断过滤数据是span的还是input的。</li>\n<li>将数据传给和数据名同名的ID元素。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (var key in json) &#123;</span><br><span class=\"line\">   //过滤type为text的文本框</span><br><span class=\"line\">   if ($(&apos;#&apos; + key).attr(&apos;type&apos;) == &apos;text&apos;) &#123;</span><br><span class=\"line\">       $(&apos;#&apos; + key).val(json[key]);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   if($(&apos;#&apos; + key).prop(&apos;tagName&apos;) == &apos;SPAN&apos;)&#123;</span><br><span class=\"line\">       $(&apos;#&apos; + key).text(json[key]);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"快速获取数据对象用于提交服务器\"><a href=\"#快速获取数据对象用于提交服务器\" class=\"headerlink\" title=\"快速获取数据对象用于提交服务器\"></a>快速获取数据对象用于提交服务器</h3><ul>\n<li>定义空model对象。</li>\n<li>通过jQuery选择器获取目标元素的value。</li>\n<li>将数据传入model中，对象元素的字段就是HTML元素的ID。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var model = &#123;&#125;;</span><br><span class=\"line\">$(&apos;input[type=&quot;text&quot;]&apos;).each(function () &#123;</span><br><span class=\"line\">   model[$(this).attr(&apos;id&apos;)]=$(this).val();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">$(&apos;span&apos;).each(function () &#123;</span><br><span class=\"line\">   model[$(this).attr(&apos;id&apos;)]=$(this).text();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(model);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>按照如下方法，我们只需要照着后端提供的数据字段给HTML定义id，而JS就不需要写太多代码就可以完成表单了。再也不怕表单字段太多了。</p>\n<h3 id=\"全部代码\"><a href=\"#全部代码\" class=\"headerlink\" title=\"全部代码\"></a>全部代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">    &lt;script src=&quot;jquery-2.2.3.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;姓名：&lt;input type=&quot;text&quot; id=&quot;name&quot;&gt;&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;性别：&lt;input type=&quot;text&quot; id=&quot;sex&quot;&gt;&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;年龄：&lt;input type=&quot;text&quot; id=&quot;age&quot;&gt;&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;时间：&lt;input type=&quot;text&quot; id=&quot;time&quot;&gt;&lt;/label&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;a：&lt;span id=&quot;param01&quot;&gt;1&lt;/span&gt;&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;b：&lt;span id=&quot;param02&quot;&gt;2&lt;/span&gt;&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;c：&lt;span id=&quot;param03&quot;&gt;3&lt;/span&gt;&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;d：&lt;span id=&quot;param04&quot;&gt;4&lt;/span&gt;&lt;/label&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;button onclick=&quot;showResult()&quot;&gt;显示结果&lt;/button&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        //多条input或者span的快速赋值</span><br><span class=\"line\">        //data是模拟服务器返回的JSON数据</span><br><span class=\"line\">        var data = &apos;&#123;&quot;name&quot;:&quot;张三&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:22,&quot;time&quot;:&quot;2016-5-10&quot;,&quot;param01&quot;:111,&quot;param02&quot;:222,&quot;param03&quot;:333,&quot;param04&quot;:444&#125;&apos;;</span><br><span class=\"line\">        //将数据显示到页面中</span><br><span class=\"line\">        var json = eval(&apos;(&apos; + data + &apos;)&apos;);</span><br><span class=\"line\">        for (var key in json) &#123;</span><br><span class=\"line\">            if ($(&apos;#&apos; + key).attr(&apos;type&apos;) == &apos;text&apos;) &#123;</span><br><span class=\"line\">                $(&apos;#&apos; + key).val(json[key]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if($(&apos;#&apos; + key).prop(&apos;tagName&apos;) == &apos;SPAN&apos;)&#123;</span><br><span class=\"line\">                $(&apos;#&apos; + key).text(json[key]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t//获取文本和文本框的内容转为JSON对象</span><br><span class=\"line\">        function showResult() &#123;</span><br><span class=\"line\">            var model = &#123;&#125;;</span><br><span class=\"line\">            $(&apos;input[type=&quot;text&quot;]&apos;).each(function () &#123;</span><br><span class=\"line\">                model[$(this).attr(&apos;id&apos;)]=$(this).val();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            $(&apos;span&apos;).each(function () &#123;</span><br><span class=\"line\">                model[$(this).attr(&apos;id&apos;)]=$(this).text();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            console.log(model);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Radio和Checkbox\"><a href=\"#Radio和Checkbox\" class=\"headerlink\" title=\"Radio和Checkbox\"></a>Radio和Checkbox</h2><p>另外一种经常出现于表单中的就是radio、checkbox这些单选多选的元素了。这些元素通常用name命名一组选项。下面我同样用jQuery简化数据的显示和提交。</p>\n<h3 id=\"显示数据\"><a href=\"#显示数据\" class=\"headerlink\" title=\"显示数据\"></a>显示数据</h3><p>和之前的文本一样，用for循环遍历json数据，然后通过if过滤后显示到界面。不同之处是这边是通过name来显示和绑定数据的。<br><strong>注：对radio和checkbox处理的方法写在了后面，所以复制粘贴的同学们请注意别漏了~</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var key in json)&#123;</span><br><span class=\"line\">   if ($(&apos;input[name=&apos; + key +  &apos;]&apos;).attr(&apos;type&apos;) == &apos;radio&apos;) &#123;</span><br><span class=\"line\">      showRadioValue(key, json[key]);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   if ($(&apos;input[name=&apos; + key +  &apos;]&apos;).attr(&apos;type&apos;) == &apos;checkbox&apos;) &#123;</span><br><span class=\"line\">     showCheckBoxValue(key, json[key]);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"获取数据model的方法\"><a href=\"#获取数据model的方法\" class=\"headerlink\" title=\"获取数据model的方法\"></a>获取数据model的方法</h3><ul>\n<li>定义空model对象。</li>\n<li>定义name避免重复添加。</li>\n<li>遍历所有radio获取结果传给model</li>\n<li>遍历所有checkbox获取结果传给model</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function showResult() &#123;</span><br><span class=\"line\">    var model = &#123;&#125;;</span><br><span class=\"line\">    var radioName = &apos;&apos;;</span><br><span class=\"line\">    var checkboxName = &apos;&apos;;</span><br><span class=\"line\">    $(&quot;input[type=&apos;radio&apos;]&quot;).each(function () &#123;</span><br><span class=\"line\">        if($(this).attr(&apos;name&apos;) != radioName)&#123;</span><br><span class=\"line\">            radioName = $(this).attr(&apos;name&apos;);</span><br><span class=\"line\">            model[radioName] = getRadioValue(radioName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    $(&quot;input[type=&apos;checkbox&apos;]&quot;).each(function () &#123;</span><br><span class=\"line\">        if($(this).attr(&apos;name&apos;) != checkboxName)&#123;</span><br><span class=\"line\">            checkboxName = $(this).attr(&apos;name&apos;);</span><br><span class=\"line\">            model[checkboxName] = getCheckboxValue(checkboxName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    console.log(model);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"处理radio和checkbox的一些方法\"><a href=\"#处理radio和checkbox的一些方法\" class=\"headerlink\" title=\"处理radio和checkbox的一些方法\"></a>处理radio和checkbox的一些方法</h3><p>这里我对radio和checkbox的显示和获取结果写了几个方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function showRadioValue(name, value) &#123;</span><br><span class=\"line\">    $(&apos;input[name=&apos; + name +  &apos;]&apos;).each(function () &#123;</span><br><span class=\"line\">        if(value == $(this).val())&#123;</span><br><span class=\"line\">            $(this).attr(&apos;checked&apos;, &apos;true&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getRadioValue(name) &#123;</span><br><span class=\"line\">    var value = 0;</span><br><span class=\"line\">    var i = 0;</span><br><span class=\"line\">    $(&apos;input[name=&apos; + name + &apos;]&apos; ).each(function () &#123;</span><br><span class=\"line\">        if ($(&apos;input[name=&apos; + name + &apos;]&apos;).eq(i).is( &apos;:checked&apos;)) &#123;</span><br><span class=\"line\">            value = $(&apos;input[name=&apos; + name + &apos;]&apos;).eq(i).val();</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function showCheckBoxValue (name, value) &#123;</span><br><span class=\"line\">    var values = value.split(&apos;,&apos; );</span><br><span class=\"line\">    var row = 1;</span><br><span class=\"line\">    $(&apos;input[name=&quot;&apos; + name + &apos;&quot;]&apos;).each( function () &#123;</span><br><span class=\"line\">        if (values[row] == 1) &#123;</span><br><span class=\"line\">            $(this).attr(&quot;checked&quot; , &apos;true&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        row++;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getCheckboxValue (name) &#123;</span><br><span class=\"line\">    var text = &quot;&quot; ;</span><br><span class=\"line\">    $(&apos;input[name=&quot;&apos; + name + &apos;&quot;]&apos;).each( function () &#123;</span><br><span class=\"line\">        var t = &apos;&apos; ;</span><br><span class=\"line\">        if ($(this ).is(&apos;:checked&apos;)) &#123;</span><br><span class=\"line\">            t = &quot;1&quot;;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            t = &quot;0&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        text += &quot;,&quot; + t;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class=\"line\">    &lt;script src=&quot;jquery-2.2.3.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;param01&quot; value=&quot;1&quot;&gt;1&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;param01&quot; value=&quot;2&quot;&gt;2&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;param01&quot; value=&quot;3&quot;&gt;3&lt;/label&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;param02&quot; value=&quot;1&quot;&gt;1&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;param02&quot; value=&quot;2&quot;&gt;2&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;param02&quot; value=&quot;3&quot;&gt;3&lt;/label&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;param03&quot; value=&quot;1&quot;&gt;1&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;param03&quot; value=&quot;2&quot;&gt;2&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;param03&quot; value=&quot;3&quot;&gt;3&lt;/label&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;param04&quot;&gt;1&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;param04&quot;&gt;2&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;param04&quot;&gt;3&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;param04&quot;&gt;3&lt;/label&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;param05&quot;&gt;1&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;param05&quot;&gt;2&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;param05&quot;&gt;3&lt;/label&gt;</span><br><span class=\"line\">            &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;param05&quot;&gt;3&lt;/label&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;button onclick=&quot;showResult()&quot;&gt;显示结果&lt;/button&gt;</span><br><span class=\"line\">        &lt;label id=&quot;result&quot;&gt;result&lt;/label&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        //多条radio或者checkbox的快速赋值</span><br><span class=\"line\">        var data = &apos;&#123;&quot;param01&quot;:&quot;1&quot;,&quot;param02&quot;:&quot;3&quot;,&quot;param03&quot;:&quot;2&quot;,&quot;param04&quot;:&quot;,1,0,0,0&quot;,&quot;param05&quot;:&quot;,0,0,1,1&quot;&#125;&apos;;</span><br><span class=\"line\">        var json =eval( &apos;(&apos; + data + &apos;)&apos;);</span><br><span class=\"line\">        for(var key in json)&#123;</span><br><span class=\"line\">            if ($(&apos;input[name=&apos; + key +  &apos;]&apos;).attr(&apos;type&apos;) == &apos;radio&apos;) &#123;</span><br><span class=\"line\">                showRadioValue(key, json[key]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if ($(&apos;input[name=&apos; + key +  &apos;]&apos;).attr(&apos;type&apos;) == &apos;checkbox&apos;) &#123;</span><br><span class=\"line\">                showCheckBoxValue(key, json[key]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        function showRadioValue(name, value) &#123;</span><br><span class=\"line\">            $(&apos;input[name=&apos; + name +  &apos;]&apos;).each(function () &#123;</span><br><span class=\"line\">                if(value == $(this).val())&#123;</span><br><span class=\"line\">                    $(this).attr(&apos;checked&apos;, &apos;true&apos;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        function getRadioValue(name) &#123;</span><br><span class=\"line\">            var value = 0;</span><br><span class=\"line\">            var i = 0;</span><br><span class=\"line\">            $(&apos;input[name=&apos; + name + &apos;]&apos; ).each(function () &#123;</span><br><span class=\"line\">                if ($(&apos;input[name=&apos; + name + &apos;]&apos;).eq(i).is( &apos;:checked&apos;)) &#123;</span><br><span class=\"line\">                    value = $(&apos;input[name=&apos; + name + &apos;]&apos;).eq(i).val();</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            return value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        function showCheckBoxValue (name, value) &#123;</span><br><span class=\"line\">            var values = value.split(&apos;,&apos; );</span><br><span class=\"line\">            var row = 1;</span><br><span class=\"line\">            $(&apos;input[name=&quot;&apos; + name + &apos;&quot;]&apos;).each( function () &#123;</span><br><span class=\"line\">                if (values[row] == 1) &#123;</span><br><span class=\"line\">                    $(this).attr(&quot;checked&quot; , &apos;true&apos;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                row++;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        function getCheckboxValue (name) &#123;</span><br><span class=\"line\">            var text = &quot;&quot; ;</span><br><span class=\"line\">            $(&apos;input[name=&quot;&apos; + name + &apos;&quot;]&apos;).each( function () &#123;</span><br><span class=\"line\">                var t = &apos;&apos; ;</span><br><span class=\"line\">                if ($(this ).is(&apos;:checked&apos;)) &#123;</span><br><span class=\"line\">                    t = &quot;1&quot;;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    t = &quot;0&quot;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                text += &quot;,&quot; + t;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            return text;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        function showResult() &#123;</span><br><span class=\"line\">            var model = &#123;&#125;;</span><br><span class=\"line\">            var radioName = &apos;&apos;;</span><br><span class=\"line\">            var checkboxName = &apos;&apos;;</span><br><span class=\"line\">            $(&quot;input[type=&apos;radio&apos;]&quot;).each(function () &#123;</span><br><span class=\"line\">                if($(this).attr(&apos;name&apos;) != radioName)&#123;</span><br><span class=\"line\">                    radioName = $(this).attr(&apos;name&apos;);</span><br><span class=\"line\">                    model[radioName] = getRadioValue(radioName);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            $(&quot;input[type=&apos;checkbox&apos;]&quot;).each(function () &#123;</span><br><span class=\"line\">                if($(this).attr(&apos;name&apos;) != checkboxName)&#123;</span><br><span class=\"line\">                    checkboxName = $(this).attr(&apos;name&apos;);</span><br><span class=\"line\">                    model[checkboxName] = getCheckboxValue(checkboxName);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            console.log(model);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h2><ul>\n<li>如果有一些特殊处理的内容（如时间格式文本），可以先遍历后在遍历之后单独进行赋值。</li>\n<li>以上方法可以用于所有以ID定义的用于显示和获取数据的HTML元素。</li>\n<li>用好jQuery的选择器可以获取到任何所需的元素、元素集合。</li>\n<li>在each()方法中<code>$(this)</code>表示当前元素。</li>\n<li>获取所选ID的元素标签：<code>$(&#39;#&#39; + key).prop(&#39;tagName&#39;) == &#39;SPAN&#39;</code>，注意：标签结果<code>&#39;SPAN&#39;</code>都是大写的,可以打log验证。</li>\n<li>不断找规律、总结提炼，找出最好的偷懒方法，尽量避免体力劳动。</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}